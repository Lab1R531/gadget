/*
 *
 * Copyright 2021-2023 Software Radio Systems Limited
 *
 * This file is part of srsRAN.
 *
 * srsRAN is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * srsRAN is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * A copy of the GNU Affero General Public License can be found in
 * the LICENSE file in the top-level directory of this distribution
 * and at http://www.gnu.org/licenses/.
 *
 */

#include "srsran/asn1/ngap/ngap_pdu_contents.h"
#include <sstream>

using namespace asn1;
using namespace asn1::ngap;

/*******************************************************************************
 *                                Struct Methods
 ******************************************************************************/

// AMFCPRelocationIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t amf_cp_relocation_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 148, 0};
  return map_enum_number(names, 4, idx, "id");
}
bool amf_cp_relocation_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 148, 0};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e amf_cp_relocation_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 148:
      return crit_e::ignore;
    case 0:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
amf_cp_relocation_ind_ies_o::value_c amf_cp_relocation_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 148:
      ret.set(value_c::types::s_nssai);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e amf_cp_relocation_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 148:
      return presence_e::optional;
    case 0:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void amf_cp_relocation_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::s_nssai:
      c.destroy<s_nssai_s>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    default:
      break;
  }
}
void amf_cp_relocation_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::s_nssai:
      c.init<s_nssai_s>();
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cp_relocation_ind_ies_o::value_c");
  }
}
amf_cp_relocation_ind_ies_o::value_c::value_c(const amf_cp_relocation_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::s_nssai:
      c.init(other.c.get<s_nssai_s>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cp_relocation_ind_ies_o::value_c");
  }
}
amf_cp_relocation_ind_ies_o::value_c&
amf_cp_relocation_ind_ies_o::value_c::operator=(const amf_cp_relocation_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::s_nssai:
      c.set(other.c.get<s_nssai_s>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cp_relocation_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& amf_cp_relocation_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& amf_cp_relocation_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
s_nssai_s& amf_cp_relocation_ind_ies_o::value_c::s_nssai()
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
allowed_nssai_l& amf_cp_relocation_ind_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const uint64_t& amf_cp_relocation_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& amf_cp_relocation_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const s_nssai_s& amf_cp_relocation_ind_ies_o::value_c::s_nssai() const
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
const allowed_nssai_l& amf_cp_relocation_ind_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
void amf_cp_relocation_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::s_nssai:
      j.write_fieldname("S-NSSAI");
      c.get<s_nssai_s>().to_json(j);
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "amf_cp_relocation_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE amf_cp_relocation_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().pack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cp_relocation_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cp_relocation_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().unpack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cp_relocation_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

amf_cp_relocation_ind_ies_container::amf_cp_relocation_ind_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  s_nssai(148, crit_e::ignore),
  allowed_nssai(0, crit_e::ignore)
{
}
SRSASN_CODE amf_cp_relocation_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += s_nssai_present ? 1 : 0;
  nof_ies += allowed_nssai_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (s_nssai_present) {
    HANDLE_CODE(s_nssai.pack(bref));
  }
  if (allowed_nssai_present) {
    HANDLE_CODE(allowed_nssai.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cp_relocation_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 148: {
        s_nssai_present = true;
        s_nssai.id      = id;
        HANDLE_CODE(s_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(s_nssai.value.unpack(bref));
        break;
      }
      case 0: {
        allowed_nssai_present = true;
        allowed_nssai.id      = id;
        HANDLE_CODE(allowed_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(allowed_nssai.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void amf_cp_relocation_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (s_nssai_present) {
    j.write_fieldname("");
    s_nssai.to_json(j);
  }
  if (allowed_nssai_present) {
    j.write_fieldname("");
    allowed_nssai.to_json(j);
  }
  j.end_obj();
}

// AMFConfigurationUpdateIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t amf_cfg_upd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {1, 96, 86, 80, 6, 7, 8, 274};
  return map_enum_number(names, 8, idx, "id");
}
bool amf_cfg_upd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {1, 96, 86, 80, 6, 7, 8, 274};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e amf_cfg_upd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 1:
      return crit_e::reject;
    case 96:
      return crit_e::reject;
    case 86:
      return crit_e::ignore;
    case 80:
      return crit_e::reject;
    case 6:
      return crit_e::ignore;
    case 7:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 274:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
amf_cfg_upd_ies_o::value_c amf_cfg_upd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 1:
      ret.set(value_c::types::amf_name);
      break;
    case 96:
      ret.set(value_c::types::served_guami_list);
      break;
    case 86:
      ret.set(value_c::types::relative_amf_capacity);
      break;
    case 80:
      ret.set(value_c::types::plmn_support_list);
      break;
    case 6:
      ret.set(value_c::types::amf_tnl_assoc_to_add_list);
      break;
    case 7:
      ret.set(value_c::types::amf_tnl_assoc_to_rem_list);
      break;
    case 8:
      ret.set(value_c::types::amf_tnl_assoc_to_upd_list);
      break;
    case 274:
      ret.set(value_c::types::extended_amf_name);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e amf_cfg_upd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 1:
      return presence_e::optional;
    case 96:
      return presence_e::optional;
    case 86:
      return presence_e::optional;
    case 80:
      return presence_e::optional;
    case 6:
      return presence_e::optional;
    case 7:
      return presence_e::optional;
    case 8:
      return presence_e::optional;
    case 274:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void amf_cfg_upd_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::amf_name:
      c.destroy<printable_string<1, 150, true, true>>();
      break;
    case types::served_guami_list:
      c.destroy<served_guami_list_l>();
      break;
    case types::plmn_support_list:
      c.destroy<plmn_support_list_l>();
      break;
    case types::amf_tnl_assoc_to_add_list:
      c.destroy<amf_tnl_assoc_to_add_list_l>();
      break;
    case types::amf_tnl_assoc_to_rem_list:
      c.destroy<amf_tnl_assoc_to_rem_list_l>();
      break;
    case types::amf_tnl_assoc_to_upd_list:
      c.destroy<amf_tnl_assoc_to_upd_list_l>();
      break;
    case types::extended_amf_name:
      c.destroy<extended_amf_name_s>();
      break;
    default:
      break;
  }
}
void amf_cfg_upd_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_name:
      c.init<printable_string<1, 150, true, true>>();
      break;
    case types::served_guami_list:
      c.init<served_guami_list_l>();
      break;
    case types::relative_amf_capacity:
      break;
    case types::plmn_support_list:
      c.init<plmn_support_list_l>();
      break;
    case types::amf_tnl_assoc_to_add_list:
      c.init<amf_tnl_assoc_to_add_list_l>();
      break;
    case types::amf_tnl_assoc_to_rem_list:
      c.init<amf_tnl_assoc_to_rem_list_l>();
      break;
    case types::amf_tnl_assoc_to_upd_list:
      c.init<amf_tnl_assoc_to_upd_list_l>();
      break;
    case types::extended_amf_name:
      c.init<extended_amf_name_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ies_o::value_c");
  }
}
amf_cfg_upd_ies_o::value_c::value_c(const amf_cfg_upd_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_name:
      c.init(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::served_guami_list:
      c.init(other.c.get<served_guami_list_l>());
      break;
    case types::relative_amf_capacity:
      c.init(other.c.get<uint16_t>());
      break;
    case types::plmn_support_list:
      c.init(other.c.get<plmn_support_list_l>());
      break;
    case types::amf_tnl_assoc_to_add_list:
      c.init(other.c.get<amf_tnl_assoc_to_add_list_l>());
      break;
    case types::amf_tnl_assoc_to_rem_list:
      c.init(other.c.get<amf_tnl_assoc_to_rem_list_l>());
      break;
    case types::amf_tnl_assoc_to_upd_list:
      c.init(other.c.get<amf_tnl_assoc_to_upd_list_l>());
      break;
    case types::extended_amf_name:
      c.init(other.c.get<extended_amf_name_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ies_o::value_c");
  }
}
amf_cfg_upd_ies_o::value_c& amf_cfg_upd_ies_o::value_c::operator=(const amf_cfg_upd_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_name:
      c.set(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::served_guami_list:
      c.set(other.c.get<served_guami_list_l>());
      break;
    case types::relative_amf_capacity:
      c.set(other.c.get<uint16_t>());
      break;
    case types::plmn_support_list:
      c.set(other.c.get<plmn_support_list_l>());
      break;
    case types::amf_tnl_assoc_to_add_list:
      c.set(other.c.get<amf_tnl_assoc_to_add_list_l>());
      break;
    case types::amf_tnl_assoc_to_rem_list:
      c.set(other.c.get<amf_tnl_assoc_to_rem_list_l>());
      break;
    case types::amf_tnl_assoc_to_upd_list:
      c.set(other.c.get<amf_tnl_assoc_to_upd_list_l>());
      break;
    case types::extended_amf_name:
      c.set(other.c.get<extended_amf_name_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ies_o::value_c");
  }

  return *this;
}
printable_string<1, 150, true, true>& amf_cfg_upd_ies_o::value_c::amf_name()
{
  assert_choice_type(types::amf_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
served_guami_list_l& amf_cfg_upd_ies_o::value_c::served_guami_list()
{
  assert_choice_type(types::served_guami_list, type_, "Value");
  return c.get<served_guami_list_l>();
}
uint16_t& amf_cfg_upd_ies_o::value_c::relative_amf_capacity()
{
  assert_choice_type(types::relative_amf_capacity, type_, "Value");
  return c.get<uint16_t>();
}
plmn_support_list_l& amf_cfg_upd_ies_o::value_c::plmn_support_list()
{
  assert_choice_type(types::plmn_support_list, type_, "Value");
  return c.get<plmn_support_list_l>();
}
amf_tnl_assoc_to_add_list_l& amf_cfg_upd_ies_o::value_c::amf_tnl_assoc_to_add_list()
{
  assert_choice_type(types::amf_tnl_assoc_to_add_list, type_, "Value");
  return c.get<amf_tnl_assoc_to_add_list_l>();
}
amf_tnl_assoc_to_rem_list_l& amf_cfg_upd_ies_o::value_c::amf_tnl_assoc_to_rem_list()
{
  assert_choice_type(types::amf_tnl_assoc_to_rem_list, type_, "Value");
  return c.get<amf_tnl_assoc_to_rem_list_l>();
}
amf_tnl_assoc_to_upd_list_l& amf_cfg_upd_ies_o::value_c::amf_tnl_assoc_to_upd_list()
{
  assert_choice_type(types::amf_tnl_assoc_to_upd_list, type_, "Value");
  return c.get<amf_tnl_assoc_to_upd_list_l>();
}
extended_amf_name_s& amf_cfg_upd_ies_o::value_c::extended_amf_name()
{
  assert_choice_type(types::extended_amf_name, type_, "Value");
  return c.get<extended_amf_name_s>();
}
const printable_string<1, 150, true, true>& amf_cfg_upd_ies_o::value_c::amf_name() const
{
  assert_choice_type(types::amf_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
const served_guami_list_l& amf_cfg_upd_ies_o::value_c::served_guami_list() const
{
  assert_choice_type(types::served_guami_list, type_, "Value");
  return c.get<served_guami_list_l>();
}
const uint16_t& amf_cfg_upd_ies_o::value_c::relative_amf_capacity() const
{
  assert_choice_type(types::relative_amf_capacity, type_, "Value");
  return c.get<uint16_t>();
}
const plmn_support_list_l& amf_cfg_upd_ies_o::value_c::plmn_support_list() const
{
  assert_choice_type(types::plmn_support_list, type_, "Value");
  return c.get<plmn_support_list_l>();
}
const amf_tnl_assoc_to_add_list_l& amf_cfg_upd_ies_o::value_c::amf_tnl_assoc_to_add_list() const
{
  assert_choice_type(types::amf_tnl_assoc_to_add_list, type_, "Value");
  return c.get<amf_tnl_assoc_to_add_list_l>();
}
const amf_tnl_assoc_to_rem_list_l& amf_cfg_upd_ies_o::value_c::amf_tnl_assoc_to_rem_list() const
{
  assert_choice_type(types::amf_tnl_assoc_to_rem_list, type_, "Value");
  return c.get<amf_tnl_assoc_to_rem_list_l>();
}
const amf_tnl_assoc_to_upd_list_l& amf_cfg_upd_ies_o::value_c::amf_tnl_assoc_to_upd_list() const
{
  assert_choice_type(types::amf_tnl_assoc_to_upd_list, type_, "Value");
  return c.get<amf_tnl_assoc_to_upd_list_l>();
}
const extended_amf_name_s& amf_cfg_upd_ies_o::value_c::extended_amf_name() const
{
  assert_choice_type(types::extended_amf_name, type_, "Value");
  return c.get<extended_amf_name_s>();
}
void amf_cfg_upd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_name:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true>>().to_string());
      break;
    case types::served_guami_list:
      j.start_array("ServedGUAMIList");
      for (const auto& e1 : c.get<served_guami_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::relative_amf_capacity:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::plmn_support_list:
      j.start_array("PLMNSupportList");
      for (const auto& e1 : c.get<plmn_support_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::amf_tnl_assoc_to_add_list:
      j.start_array("AMF-TNLAssociationToAddList");
      for (const auto& e1 : c.get<amf_tnl_assoc_to_add_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::amf_tnl_assoc_to_rem_list:
      j.start_array("AMF-TNLAssociationToRemoveList");
      for (const auto& e1 : c.get<amf_tnl_assoc_to_rem_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::amf_tnl_assoc_to_upd_list:
      j.start_array("AMF-TNLAssociationToUpdateList");
      for (const auto& e1 : c.get<amf_tnl_assoc_to_upd_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::extended_amf_name:
      j.write_fieldname("Extended-AMFName");
      c.get<extended_amf_name_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE amf_cfg_upd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().pack(bref)));
      break;
    case types::served_guami_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<served_guami_list_l>(), 1, 256, true));
      break;
    case types::relative_amf_capacity:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::plmn_support_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<plmn_support_list_l>(), 1, 12, true));
      break;
    case types::amf_tnl_assoc_to_add_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<amf_tnl_assoc_to_add_list_l>(), 1, 32, true));
      break;
    case types::amf_tnl_assoc_to_rem_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<amf_tnl_assoc_to_rem_list_l>(), 1, 32, true));
      break;
    case types::amf_tnl_assoc_to_upd_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<amf_tnl_assoc_to_upd_list_l>(), 1, 32, true));
      break;
    case types::extended_amf_name:
      HANDLE_CODE(c.get<extended_amf_name_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cfg_upd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().unpack(bref)));
      break;
    case types::served_guami_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<served_guami_list_l>(), bref, 1, 256, true));
      break;
    case types::relative_amf_capacity:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::plmn_support_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<plmn_support_list_l>(), bref, 1, 12, true));
      break;
    case types::amf_tnl_assoc_to_add_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<amf_tnl_assoc_to_add_list_l>(), bref, 1, 32, true));
      break;
    case types::amf_tnl_assoc_to_rem_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<amf_tnl_assoc_to_rem_list_l>(), bref, 1, 32, true));
      break;
    case types::amf_tnl_assoc_to_upd_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<amf_tnl_assoc_to_upd_list_l>(), bref, 1, 32, true));
      break;
    case types::extended_amf_name:
      HANDLE_CODE(c.get<extended_amf_name_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

amf_cfg_upd_ies_container::amf_cfg_upd_ies_container() :
  amf_name(1, crit_e::reject),
  served_guami_list(96, crit_e::reject),
  relative_amf_capacity(86, crit_e::ignore),
  plmn_support_list(80, crit_e::reject),
  amf_tnl_assoc_to_add_list(6, crit_e::ignore),
  amf_tnl_assoc_to_rem_list(7, crit_e::ignore),
  amf_tnl_assoc_to_upd_list(8, crit_e::ignore),
  extended_amf_name(274, crit_e::ignore)
{
}
SRSASN_CODE amf_cfg_upd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += amf_name_present ? 1 : 0;
  nof_ies += served_guami_list_present ? 1 : 0;
  nof_ies += relative_amf_capacity_present ? 1 : 0;
  nof_ies += plmn_support_list_present ? 1 : 0;
  nof_ies += amf_tnl_assoc_to_add_list_present ? 1 : 0;
  nof_ies += amf_tnl_assoc_to_rem_list_present ? 1 : 0;
  nof_ies += amf_tnl_assoc_to_upd_list_present ? 1 : 0;
  nof_ies += extended_amf_name_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (amf_name_present) {
    HANDLE_CODE(amf_name.pack(bref));
  }
  if (served_guami_list_present) {
    HANDLE_CODE(served_guami_list.pack(bref));
  }
  if (relative_amf_capacity_present) {
    HANDLE_CODE(relative_amf_capacity.pack(bref));
  }
  if (plmn_support_list_present) {
    HANDLE_CODE(plmn_support_list.pack(bref));
  }
  if (amf_tnl_assoc_to_add_list_present) {
    HANDLE_CODE(amf_tnl_assoc_to_add_list.pack(bref));
  }
  if (amf_tnl_assoc_to_rem_list_present) {
    HANDLE_CODE(amf_tnl_assoc_to_rem_list.pack(bref));
  }
  if (amf_tnl_assoc_to_upd_list_present) {
    HANDLE_CODE(amf_tnl_assoc_to_upd_list.pack(bref));
  }
  if (extended_amf_name_present) {
    HANDLE_CODE(extended_amf_name.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cfg_upd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 1: {
        amf_name_present = true;
        amf_name.id      = id;
        HANDLE_CODE(amf_name.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_name.value.unpack(bref));
        break;
      }
      case 96: {
        served_guami_list_present = true;
        served_guami_list.id      = id;
        HANDLE_CODE(served_guami_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(served_guami_list.value.unpack(bref));
        break;
      }
      case 86: {
        relative_amf_capacity_present = true;
        relative_amf_capacity.id      = id;
        HANDLE_CODE(relative_amf_capacity.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(relative_amf_capacity.value.unpack(bref));
        break;
      }
      case 80: {
        plmn_support_list_present = true;
        plmn_support_list.id      = id;
        HANDLE_CODE(plmn_support_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(plmn_support_list.value.unpack(bref));
        break;
      }
      case 6: {
        amf_tnl_assoc_to_add_list_present = true;
        amf_tnl_assoc_to_add_list.id      = id;
        HANDLE_CODE(amf_tnl_assoc_to_add_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_tnl_assoc_to_add_list.value.unpack(bref));
        break;
      }
      case 7: {
        amf_tnl_assoc_to_rem_list_present = true;
        amf_tnl_assoc_to_rem_list.id      = id;
        HANDLE_CODE(amf_tnl_assoc_to_rem_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_tnl_assoc_to_rem_list.value.unpack(bref));
        break;
      }
      case 8: {
        amf_tnl_assoc_to_upd_list_present = true;
        amf_tnl_assoc_to_upd_list.id      = id;
        HANDLE_CODE(amf_tnl_assoc_to_upd_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_tnl_assoc_to_upd_list.value.unpack(bref));
        break;
      }
      case 274: {
        extended_amf_name_present = true;
        extended_amf_name.id      = id;
        HANDLE_CODE(extended_amf_name.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_amf_name.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void amf_cfg_upd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (amf_name_present) {
    j.write_fieldname("");
    amf_name.to_json(j);
  }
  if (served_guami_list_present) {
    j.write_fieldname("");
    served_guami_list.to_json(j);
  }
  if (relative_amf_capacity_present) {
    j.write_fieldname("");
    relative_amf_capacity.to_json(j);
  }
  if (plmn_support_list_present) {
    j.write_fieldname("");
    plmn_support_list.to_json(j);
  }
  if (amf_tnl_assoc_to_add_list_present) {
    j.write_fieldname("");
    amf_tnl_assoc_to_add_list.to_json(j);
  }
  if (amf_tnl_assoc_to_rem_list_present) {
    j.write_fieldname("");
    amf_tnl_assoc_to_rem_list.to_json(j);
  }
  if (amf_tnl_assoc_to_upd_list_present) {
    j.write_fieldname("");
    amf_tnl_assoc_to_upd_list.to_json(j);
  }
  if (extended_amf_name_present) {
    j.write_fieldname("");
    extended_amf_name.to_json(j);
  }
  j.end_obj();
}

// AMFConfigurationUpdateAcknowledgeIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t amf_cfg_upd_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {5, 4, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool amf_cfg_upd_ack_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {5, 4, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e amf_cfg_upd_ack_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 5:
      return crit_e::ignore;
    case 4:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
amf_cfg_upd_ack_ies_o::value_c amf_cfg_upd_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 5:
      ret.set(value_c::types::amf_tnl_assoc_setup_list);
      break;
    case 4:
      ret.set(value_c::types::amf_tnl_assoc_failed_to_setup_list);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e amf_cfg_upd_ack_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 5:
      return presence_e::optional;
    case 4:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void amf_cfg_upd_ack_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      c.destroy<amf_tnl_assoc_setup_list_l>();
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      c.destroy<tnl_assoc_list_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void amf_cfg_upd_ack_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      c.init<amf_tnl_assoc_setup_list_l>();
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      c.init<tnl_assoc_list_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ack_ies_o::value_c");
  }
}
amf_cfg_upd_ack_ies_o::value_c::value_c(const amf_cfg_upd_ack_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      c.init(other.c.get<amf_tnl_assoc_setup_list_l>());
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      c.init(other.c.get<tnl_assoc_list_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ack_ies_o::value_c");
  }
}
amf_cfg_upd_ack_ies_o::value_c& amf_cfg_upd_ack_ies_o::value_c::operator=(const amf_cfg_upd_ack_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      c.set(other.c.get<amf_tnl_assoc_setup_list_l>());
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      c.set(other.c.get<tnl_assoc_list_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ack_ies_o::value_c");
  }

  return *this;
}
amf_tnl_assoc_setup_list_l& amf_cfg_upd_ack_ies_o::value_c::amf_tnl_assoc_setup_list()
{
  assert_choice_type(types::amf_tnl_assoc_setup_list, type_, "Value");
  return c.get<amf_tnl_assoc_setup_list_l>();
}
tnl_assoc_list_l& amf_cfg_upd_ack_ies_o::value_c::amf_tnl_assoc_failed_to_setup_list()
{
  assert_choice_type(types::amf_tnl_assoc_failed_to_setup_list, type_, "Value");
  return c.get<tnl_assoc_list_l>();
}
crit_diagnostics_s& amf_cfg_upd_ack_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const amf_tnl_assoc_setup_list_l& amf_cfg_upd_ack_ies_o::value_c::amf_tnl_assoc_setup_list() const
{
  assert_choice_type(types::amf_tnl_assoc_setup_list, type_, "Value");
  return c.get<amf_tnl_assoc_setup_list_l>();
}
const tnl_assoc_list_l& amf_cfg_upd_ack_ies_o::value_c::amf_tnl_assoc_failed_to_setup_list() const
{
  assert_choice_type(types::amf_tnl_assoc_failed_to_setup_list, type_, "Value");
  return c.get<tnl_assoc_list_l>();
}
const crit_diagnostics_s& amf_cfg_upd_ack_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void amf_cfg_upd_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      j.start_array("AMF-TNLAssociationSetupList");
      for (const auto& e1 : c.get<amf_tnl_assoc_setup_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      j.start_array("TNLAssociationList");
      for (const auto& e1 : c.get<tnl_assoc_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ack_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE amf_cfg_upd_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<amf_tnl_assoc_setup_list_l>(), 1, 32, true));
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tnl_assoc_list_l>(), 1, 32, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ack_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cfg_upd_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<amf_tnl_assoc_setup_list_l>(), bref, 1, 32, true));
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tnl_assoc_list_l>(), bref, 1, 32, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ack_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

amf_cfg_upd_ack_ies_container::amf_cfg_upd_ack_ies_container() :
  amf_tnl_assoc_setup_list(5, crit_e::ignore),
  amf_tnl_assoc_failed_to_setup_list(4, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE amf_cfg_upd_ack_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += amf_tnl_assoc_setup_list_present ? 1 : 0;
  nof_ies += amf_tnl_assoc_failed_to_setup_list_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (amf_tnl_assoc_setup_list_present) {
    HANDLE_CODE(amf_tnl_assoc_setup_list.pack(bref));
  }
  if (amf_tnl_assoc_failed_to_setup_list_present) {
    HANDLE_CODE(amf_tnl_assoc_failed_to_setup_list.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cfg_upd_ack_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 5: {
        amf_tnl_assoc_setup_list_present = true;
        amf_tnl_assoc_setup_list.id      = id;
        HANDLE_CODE(amf_tnl_assoc_setup_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_tnl_assoc_setup_list.value.unpack(bref));
        break;
      }
      case 4: {
        amf_tnl_assoc_failed_to_setup_list_present = true;
        amf_tnl_assoc_failed_to_setup_list.id      = id;
        HANDLE_CODE(amf_tnl_assoc_failed_to_setup_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_tnl_assoc_failed_to_setup_list.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void amf_cfg_upd_ack_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (amf_tnl_assoc_setup_list_present) {
    j.write_fieldname("");
    amf_tnl_assoc_setup_list.to_json(j);
  }
  if (amf_tnl_assoc_failed_to_setup_list_present) {
    j.write_fieldname("");
    amf_tnl_assoc_failed_to_setup_list.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// AMFConfigurationUpdateFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t amf_cfg_upd_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {15, 107, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool amf_cfg_upd_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {15, 107, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e amf_cfg_upd_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 15:
      return crit_e::ignore;
    case 107:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
amf_cfg_upd_fail_ies_o::value_c amf_cfg_upd_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 107:
      ret.set(value_c::types::time_to_wait);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e amf_cfg_upd_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 15:
      return presence_e::mandatory;
    case 107:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void amf_cfg_upd_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void amf_cfg_upd_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cause:
      c.init<cause_c>();
      break;
    case types::time_to_wait:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_fail_ies_o::value_c");
  }
}
amf_cfg_upd_fail_ies_o::value_c::value_c(const amf_cfg_upd_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::time_to_wait:
      c.init(other.c.get<time_to_wait_e>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_fail_ies_o::value_c");
  }
}
amf_cfg_upd_fail_ies_o::value_c&
amf_cfg_upd_fail_ies_o::value_c::operator=(const amf_cfg_upd_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::time_to_wait:
      c.set(other.c.get<time_to_wait_e>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_fail_ies_o::value_c");
  }

  return *this;
}
cause_c& amf_cfg_upd_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
time_to_wait_e& amf_cfg_upd_fail_ies_o::value_c::time_to_wait()
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
crit_diagnostics_s& amf_cfg_upd_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const cause_c& amf_cfg_upd_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const time_to_wait_e& amf_cfg_upd_fail_ies_o::value_c::time_to_wait() const
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
const crit_diagnostics_s& amf_cfg_upd_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void amf_cfg_upd_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::time_to_wait:
      j.write_str("TimeToWait", c.get<time_to_wait_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE amf_cfg_upd_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cfg_upd_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

amf_cfg_upd_fail_ies_container::amf_cfg_upd_fail_ies_container() :
  cause(15, crit_e::ignore), time_to_wait(107, crit_e::ignore), crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE amf_cfg_upd_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += time_to_wait_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(cause.pack(bref));
  if (time_to_wait_present) {
    HANDLE_CODE(time_to_wait.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cfg_upd_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 107: {
        time_to_wait_present = true;
        time_to_wait.id      = id;
        HANDLE_CODE(time_to_wait.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_to_wait.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void amf_cfg_upd_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  cause.to_json(j);
  if (time_to_wait_present) {
    j.write_fieldname("");
    time_to_wait.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// AMFStatusIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t amf_status_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {120};
  return map_enum_number(names, 1, idx, "id");
}
bool amf_status_ind_ies_o::is_id_valid(const uint32_t& id)
{
  return 120 == id;
}
crit_e amf_status_ind_ies_o::get_crit(const uint32_t& id)
{
  if (id == 120) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
amf_status_ind_ies_o::value_c amf_status_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 120) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e amf_status_ind_ies_o::get_presence(const uint32_t& id)
{
  if (id == 120) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void amf_status_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("UnavailableGUAMIList");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE amf_status_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 256, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_status_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 256, true));
  return SRSASN_SUCCESS;
}

// BroadcastSessionModificationFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_mod_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 348, 15, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool broadcast_session_mod_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 348, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_mod_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 348:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_mod_fail_ies_o::value_c broadcast_session_mod_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 348:
      ret.set(value_c::types::mbs_session_mod_fail_transfer);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_mod_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 348:
      return presence_e::optional;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_mod_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_session_mod_fail_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void broadcast_session_mod_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_session_mod_fail_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_fail_ies_o::value_c");
  }
}
broadcast_session_mod_fail_ies_o::value_c::value_c(const broadcast_session_mod_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_mod_fail_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_fail_ies_o::value_c");
  }
}
broadcast_session_mod_fail_ies_o::value_c&
broadcast_session_mod_fail_ies_o::value_c::operator=(const broadcast_session_mod_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_mod_fail_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_fail_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_mod_fail_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>& broadcast_session_mod_fail_ies_o::value_c::mbs_session_mod_fail_transfer()
{
  assert_choice_type(types::mbs_session_mod_fail_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
cause_c& broadcast_session_mod_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& broadcast_session_mod_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& broadcast_session_mod_fail_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>& broadcast_session_mod_fail_ies_o::value_c::mbs_session_mod_fail_transfer() const
{
  assert_choice_type(types::mbs_session_mod_fail_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const cause_c& broadcast_session_mod_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& broadcast_session_mod_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void broadcast_session_mod_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_session_mod_fail_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_mod_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_session_mod_fail_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_mod_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_session_mod_fail_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

broadcast_session_mod_fail_ies_container::broadcast_session_mod_fail_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_session_mod_fail_transfer(348, crit_e::reject),
  cause(15, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE broadcast_session_mod_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_session_mod_fail_transfer_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_session_mod_fail_transfer_present) {
    HANDLE_CODE(mbs_session_mod_fail_transfer.pack(bref));
  }
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_mod_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 348: {
        mbs_session_mod_fail_transfer_present = true;
        mbs_session_mod_fail_transfer.id      = id;
        HANDLE_CODE(mbs_session_mod_fail_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_mod_fail_transfer.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_mod_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_session_mod_fail_transfer_present) {
    j.write_fieldname("");
    mbs_session_mod_fail_transfer.to_json(j);
  }
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// BroadcastSessionModificationRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_mod_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 298, 349};
  return map_enum_number(names, 3, idx, "id");
}
bool broadcast_session_mod_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 298, 349};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_mod_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 298:
      return crit_e::reject;
    case 349:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_mod_request_ies_o::value_c broadcast_session_mod_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 298:
      ret.set(value_c::types::mbs_service_area);
      break;
    case 349:
      ret.set(value_c::types::mbs_session_mod_request_transfer);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_mod_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 298:
      return presence_e::optional;
    case 349:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_mod_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_service_area:
      c.destroy<mbs_service_area_c>();
      break;
    case types::mbs_session_mod_request_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void broadcast_session_mod_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_service_area:
      c.init<mbs_service_area_c>();
      break;
    case types::mbs_session_mod_request_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_request_ies_o::value_c");
  }
}
broadcast_session_mod_request_ies_o::value_c::value_c(const broadcast_session_mod_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_service_area:
      c.init(other.c.get<mbs_service_area_c>());
      break;
    case types::mbs_session_mod_request_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_request_ies_o::value_c");
  }
}
broadcast_session_mod_request_ies_o::value_c&
broadcast_session_mod_request_ies_o::value_c::operator=(const broadcast_session_mod_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_service_area:
      c.set(other.c.get<mbs_service_area_c>());
      break;
    case types::mbs_session_mod_request_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_request_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_mod_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
mbs_service_area_c& broadcast_session_mod_request_ies_o::value_c::mbs_service_area()
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
unbounded_octstring<true>& broadcast_session_mod_request_ies_o::value_c::mbs_session_mod_request_transfer()
{
  assert_choice_type(types::mbs_session_mod_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_id_s& broadcast_session_mod_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const mbs_service_area_c& broadcast_session_mod_request_ies_o::value_c::mbs_service_area() const
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
const unbounded_octstring<true>& broadcast_session_mod_request_ies_o::value_c::mbs_session_mod_request_transfer() const
{
  assert_choice_type(types::mbs_session_mod_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void broadcast_session_mod_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_service_area:
      j.write_fieldname("MBS-ServiceArea");
      c.get<mbs_service_area_c>().to_json(j);
      break;
    case types::mbs_session_mod_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_mod_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().pack(bref));
      break;
    case types::mbs_session_mod_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_mod_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().unpack(bref));
      break;
    case types::mbs_session_mod_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

broadcast_session_mod_request_ies_container::broadcast_session_mod_request_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_service_area(298, crit_e::reject),
  mbs_session_mod_request_transfer(349, crit_e::reject)
{
}
SRSASN_CODE broadcast_session_mod_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_service_area_present ? 1 : 0;
  nof_ies += mbs_session_mod_request_transfer_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_service_area_present) {
    HANDLE_CODE(mbs_service_area.pack(bref));
  }
  if (mbs_session_mod_request_transfer_present) {
    HANDLE_CODE(mbs_session_mod_request_transfer.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_mod_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 298: {
        mbs_service_area_present = true;
        mbs_service_area.id      = id;
        HANDLE_CODE(mbs_service_area.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_service_area.value.unpack(bref));
        break;
      }
      case 349: {
        mbs_session_mod_request_transfer_present = true;
        mbs_session_mod_request_transfer.id      = id;
        HANDLE_CODE(mbs_session_mod_request_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_mod_request_transfer.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_mod_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_service_area_present) {
    j.write_fieldname("");
    mbs_service_area.to_json(j);
  }
  if (mbs_session_mod_request_transfer_present) {
    j.write_fieldname("");
    mbs_session_mod_request_transfer.to_json(j);
  }
  j.end_obj();
}

// BroadcastSessionModificationResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_mod_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 350, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool broadcast_session_mod_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 350, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_mod_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 350:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_mod_resp_ies_o::value_c broadcast_session_mod_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 350:
      ret.set(value_c::types::mbs_session_mod_resp_transfer);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_mod_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 350:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_mod_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_session_mod_resp_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void broadcast_session_mod_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_session_mod_resp_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_resp_ies_o::value_c");
  }
}
broadcast_session_mod_resp_ies_o::value_c::value_c(const broadcast_session_mod_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_mod_resp_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_resp_ies_o::value_c");
  }
}
broadcast_session_mod_resp_ies_o::value_c&
broadcast_session_mod_resp_ies_o::value_c::operator=(const broadcast_session_mod_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_mod_resp_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_resp_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_mod_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>& broadcast_session_mod_resp_ies_o::value_c::mbs_session_mod_resp_transfer()
{
  assert_choice_type(types::mbs_session_mod_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& broadcast_session_mod_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& broadcast_session_mod_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>& broadcast_session_mod_resp_ies_o::value_c::mbs_session_mod_resp_transfer() const
{
  assert_choice_type(types::mbs_session_mod_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& broadcast_session_mod_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void broadcast_session_mod_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_session_mod_resp_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_mod_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_session_mod_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_mod_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_session_mod_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

broadcast_session_mod_resp_ies_container::broadcast_session_mod_resp_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_session_mod_resp_transfer(350, crit_e::reject),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE broadcast_session_mod_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_session_mod_resp_transfer_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_session_mod_resp_transfer_present) {
    HANDLE_CODE(mbs_session_mod_resp_transfer.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_mod_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 350: {
        mbs_session_mod_resp_transfer_present = true;
        mbs_session_mod_resp_transfer.id      = id;
        HANDLE_CODE(mbs_session_mod_resp_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_mod_resp_transfer.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_mod_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_session_mod_resp_transfer_present) {
    j.write_fieldname("");
    mbs_session_mod_resp_transfer.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// BroadcastSessionReleaseRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_release_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 15};
  return map_enum_number(names, 2, idx, "id");
}
bool broadcast_session_release_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_release_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_release_request_ies_o::value_c broadcast_session_release_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_release_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_release_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void broadcast_session_release_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_request_ies_o::value_c");
  }
}
broadcast_session_release_request_ies_o::value_c::value_c(const broadcast_session_release_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_request_ies_o::value_c");
  }
}
broadcast_session_release_request_ies_o::value_c& broadcast_session_release_request_ies_o::value_c::operator=(
    const broadcast_session_release_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_request_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_release_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
cause_c& broadcast_session_release_request_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const mbs_session_id_s& broadcast_session_release_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const cause_c& broadcast_session_release_request_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void broadcast_session_release_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_release_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_release_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

broadcast_session_release_request_ies_container::broadcast_session_release_request_ies_container() :
  mbs_session_id(299, crit_e::reject), cause(15, crit_e::ignore)
{
}
SRSASN_CODE broadcast_session_release_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_release_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_release_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.end_obj();
}

// BroadcastSessionReleaseRequiredIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_release_required_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 15};
  return map_enum_number(names, 2, idx, "id");
}
bool broadcast_session_release_required_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_release_required_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_release_required_ies_o::value_c
broadcast_session_release_required_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_release_required_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_release_required_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void broadcast_session_release_required_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_required_ies_o::value_c");
  }
}
broadcast_session_release_required_ies_o::value_c::value_c(
    const broadcast_session_release_required_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_required_ies_o::value_c");
  }
}
broadcast_session_release_required_ies_o::value_c& broadcast_session_release_required_ies_o::value_c::operator=(
    const broadcast_session_release_required_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_required_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_release_required_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
cause_c& broadcast_session_release_required_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const mbs_session_id_s& broadcast_session_release_required_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const cause_c& broadcast_session_release_required_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void broadcast_session_release_required_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_required_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_release_required_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_required_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_release_required_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_required_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

broadcast_session_release_required_ies_container::broadcast_session_release_required_ies_container() :
  mbs_session_id(299, crit_e::reject), cause(15, crit_e::ignore)
{
}
SRSASN_CODE broadcast_session_release_required_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_release_required_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_release_required_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.end_obj();
}

// BroadcastSessionReleaseResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_release_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 358, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool broadcast_session_release_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 358, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_release_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 358:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_release_resp_ies_o::value_c broadcast_session_release_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 358:
      ret.set(value_c::types::mbs_session_release_resp_transfer);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_release_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 358:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_release_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_session_release_resp_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void broadcast_session_release_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_session_release_resp_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_resp_ies_o::value_c");
  }
}
broadcast_session_release_resp_ies_o::value_c::value_c(const broadcast_session_release_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_release_resp_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_resp_ies_o::value_c");
  }
}
broadcast_session_release_resp_ies_o::value_c&
broadcast_session_release_resp_ies_o::value_c::operator=(const broadcast_session_release_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_release_resp_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_resp_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_release_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>& broadcast_session_release_resp_ies_o::value_c::mbs_session_release_resp_transfer()
{
  assert_choice_type(types::mbs_session_release_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& broadcast_session_release_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& broadcast_session_release_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>&
broadcast_session_release_resp_ies_o::value_c::mbs_session_release_resp_transfer() const
{
  assert_choice_type(types::mbs_session_release_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& broadcast_session_release_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void broadcast_session_release_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_session_release_resp_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_release_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_session_release_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_release_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_session_release_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

broadcast_session_release_resp_ies_container::broadcast_session_release_resp_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_session_release_resp_transfer(358, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE broadcast_session_release_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_session_release_resp_transfer_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_session_release_resp_transfer_present) {
    HANDLE_CODE(mbs_session_release_resp_transfer.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_release_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 358: {
        mbs_session_release_resp_transfer_present = true;
        mbs_session_release_resp_transfer.id      = id;
        HANDLE_CODE(mbs_session_release_resp_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_release_resp_transfer.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_release_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_session_release_resp_transfer_present) {
    j.write_fieldname("");
    mbs_session_release_resp_transfer.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// BroadcastSessionSetupFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_setup_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 314, 15, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool broadcast_session_setup_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 314, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_setup_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 314:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_setup_fail_ies_o::value_c broadcast_session_setup_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 314:
      ret.set(value_c::types::mbs_session_setup_fail_transfer);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_setup_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 314:
      return presence_e::optional;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_setup_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_session_setup_fail_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void broadcast_session_setup_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_session_setup_fail_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_fail_ies_o::value_c");
  }
}
broadcast_session_setup_fail_ies_o::value_c::value_c(const broadcast_session_setup_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_setup_fail_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_fail_ies_o::value_c");
  }
}
broadcast_session_setup_fail_ies_o::value_c&
broadcast_session_setup_fail_ies_o::value_c::operator=(const broadcast_session_setup_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_setup_fail_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_fail_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_setup_fail_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>& broadcast_session_setup_fail_ies_o::value_c::mbs_session_setup_fail_transfer()
{
  assert_choice_type(types::mbs_session_setup_fail_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
cause_c& broadcast_session_setup_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& broadcast_session_setup_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& broadcast_session_setup_fail_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>& broadcast_session_setup_fail_ies_o::value_c::mbs_session_setup_fail_transfer() const
{
  assert_choice_type(types::mbs_session_setup_fail_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const cause_c& broadcast_session_setup_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& broadcast_session_setup_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void broadcast_session_setup_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_session_setup_fail_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_setup_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_session_setup_fail_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_setup_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_session_setup_fail_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

broadcast_session_setup_fail_ies_container::broadcast_session_setup_fail_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_session_setup_fail_transfer(314, crit_e::reject),
  cause(15, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE broadcast_session_setup_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_session_setup_fail_transfer_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_session_setup_fail_transfer_present) {
    HANDLE_CODE(mbs_session_setup_fail_transfer.pack(bref));
  }
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_setup_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 314: {
        mbs_session_setup_fail_transfer_present = true;
        mbs_session_setup_fail_transfer.id      = id;
        HANDLE_CODE(mbs_session_setup_fail_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_setup_fail_transfer.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_setup_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_session_setup_fail_transfer_present) {
    j.write_fieldname("");
    mbs_session_setup_fail_transfer.to_json(j);
  }
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// BroadcastSessionSetupRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_setup_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 148, 298, 315};
  return map_enum_number(names, 4, idx, "id");
}
bool broadcast_session_setup_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 148, 298, 315};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_setup_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 148:
      return crit_e::reject;
    case 298:
      return crit_e::reject;
    case 315:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_setup_request_ies_o::value_c broadcast_session_setup_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 148:
      ret.set(value_c::types::s_nssai);
      break;
    case 298:
      ret.set(value_c::types::mbs_service_area);
      break;
    case 315:
      ret.set(value_c::types::mbs_session_setup_request_transfer);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_setup_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 148:
      return presence_e::mandatory;
    case 298:
      return presence_e::mandatory;
    case 315:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_setup_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::s_nssai:
      c.destroy<s_nssai_s>();
      break;
    case types::mbs_service_area:
      c.destroy<mbs_service_area_c>();
      break;
    case types::mbs_session_setup_request_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void broadcast_session_setup_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::s_nssai:
      c.init<s_nssai_s>();
      break;
    case types::mbs_service_area:
      c.init<mbs_service_area_c>();
      break;
    case types::mbs_session_setup_request_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_request_ies_o::value_c");
  }
}
broadcast_session_setup_request_ies_o::value_c::value_c(const broadcast_session_setup_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::s_nssai:
      c.init(other.c.get<s_nssai_s>());
      break;
    case types::mbs_service_area:
      c.init(other.c.get<mbs_service_area_c>());
      break;
    case types::mbs_session_setup_request_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_request_ies_o::value_c");
  }
}
broadcast_session_setup_request_ies_o::value_c&
broadcast_session_setup_request_ies_o::value_c::operator=(const broadcast_session_setup_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::s_nssai:
      c.set(other.c.get<s_nssai_s>());
      break;
    case types::mbs_service_area:
      c.set(other.c.get<mbs_service_area_c>());
      break;
    case types::mbs_session_setup_request_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_request_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_setup_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
s_nssai_s& broadcast_session_setup_request_ies_o::value_c::s_nssai()
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
mbs_service_area_c& broadcast_session_setup_request_ies_o::value_c::mbs_service_area()
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
unbounded_octstring<true>& broadcast_session_setup_request_ies_o::value_c::mbs_session_setup_request_transfer()
{
  assert_choice_type(types::mbs_session_setup_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_id_s& broadcast_session_setup_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const s_nssai_s& broadcast_session_setup_request_ies_o::value_c::s_nssai() const
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
const mbs_service_area_c& broadcast_session_setup_request_ies_o::value_c::mbs_service_area() const
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
const unbounded_octstring<true>&
broadcast_session_setup_request_ies_o::value_c::mbs_session_setup_request_transfer() const
{
  assert_choice_type(types::mbs_session_setup_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void broadcast_session_setup_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::s_nssai:
      j.write_fieldname("S-NSSAI");
      c.get<s_nssai_s>().to_json(j);
      break;
    case types::mbs_service_area:
      j.write_fieldname("MBS-ServiceArea");
      c.get<mbs_service_area_c>().to_json(j);
      break;
    case types::mbs_session_setup_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_setup_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().pack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().pack(bref));
      break;
    case types::mbs_session_setup_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_setup_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().unpack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().unpack(bref));
      break;
    case types::mbs_session_setup_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

broadcast_session_setup_request_ies_container::broadcast_session_setup_request_ies_container() :
  mbs_session_id(299, crit_e::reject),
  s_nssai(148, crit_e::reject),
  mbs_service_area(298, crit_e::reject),
  mbs_session_setup_request_transfer(315, crit_e::reject)
{
}
SRSASN_CODE broadcast_session_setup_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  HANDLE_CODE(s_nssai.pack(bref));
  HANDLE_CODE(mbs_service_area.pack(bref));
  HANDLE_CODE(mbs_session_setup_request_transfer.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_setup_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 148: {
        nof_mandatory_ies--;
        s_nssai.id = id;
        HANDLE_CODE(s_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(s_nssai.value.unpack(bref));
        break;
      }
      case 298: {
        nof_mandatory_ies--;
        mbs_service_area.id = id;
        HANDLE_CODE(mbs_service_area.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_service_area.value.unpack(bref));
        break;
      }
      case 315: {
        nof_mandatory_ies--;
        mbs_session_setup_request_transfer.id = id;
        HANDLE_CODE(mbs_session_setup_request_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_setup_request_transfer.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_setup_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  j.write_fieldname("");
  s_nssai.to_json(j);
  j.write_fieldname("");
  mbs_service_area.to_json(j);
  j.write_fieldname("");
  mbs_session_setup_request_transfer.to_json(j);
  j.end_obj();
}

// BroadcastSessionSetupResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_setup_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 316, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool broadcast_session_setup_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 316, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_setup_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 316:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_setup_resp_ies_o::value_c broadcast_session_setup_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 316:
      ret.set(value_c::types::mbs_session_setup_resp_transfer);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_setup_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 316:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_setup_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_session_setup_resp_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void broadcast_session_setup_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_session_setup_resp_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_resp_ies_o::value_c");
  }
}
broadcast_session_setup_resp_ies_o::value_c::value_c(const broadcast_session_setup_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_setup_resp_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_resp_ies_o::value_c");
  }
}
broadcast_session_setup_resp_ies_o::value_c&
broadcast_session_setup_resp_ies_o::value_c::operator=(const broadcast_session_setup_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_setup_resp_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_resp_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_setup_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>& broadcast_session_setup_resp_ies_o::value_c::mbs_session_setup_resp_transfer()
{
  assert_choice_type(types::mbs_session_setup_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& broadcast_session_setup_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& broadcast_session_setup_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>& broadcast_session_setup_resp_ies_o::value_c::mbs_session_setup_resp_transfer() const
{
  assert_choice_type(types::mbs_session_setup_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& broadcast_session_setup_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void broadcast_session_setup_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_session_setup_resp_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_setup_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_session_setup_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_setup_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_session_setup_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

broadcast_session_setup_resp_ies_container::broadcast_session_setup_resp_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_session_setup_resp_transfer(316, crit_e::reject),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE broadcast_session_setup_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_session_setup_resp_transfer_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_session_setup_resp_transfer_present) {
    HANDLE_CODE(mbs_session_setup_resp_transfer.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_setup_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 316: {
        mbs_session_setup_resp_transfer_present = true;
        mbs_session_setup_resp_transfer.id      = id;
        HANDLE_CODE(mbs_session_setup_resp_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_setup_resp_transfer.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_setup_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_session_setup_resp_transfer_present) {
    j.write_fieldname("");
    mbs_session_setup_resp_transfer.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// CellTrafficTraceIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t cell_traffic_trace_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 44, 43, 109, 256, 257};
  return map_enum_number(names, 7, idx, "id");
}
bool cell_traffic_trace_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 44, 43, 109, 256, 257};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e cell_traffic_trace_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 44:
      return crit_e::ignore;
    case 43:
      return crit_e::ignore;
    case 109:
      return crit_e::ignore;
    case 256:
      return crit_e::ignore;
    case 257:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
cell_traffic_trace_ies_o::value_c cell_traffic_trace_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 44:
      ret.set(value_c::types::ngran_trace_id);
      break;
    case 43:
      ret.set(value_c::types::ngran_cgi);
      break;
    case 109:
      ret.set(value_c::types::trace_collection_entity_ip_address);
      break;
    case 256:
      ret.set(value_c::types::privacy_ind);
      break;
    case 257:
      ret.set(value_c::types::trace_collection_entity_uri);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e cell_traffic_trace_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 44:
      return presence_e::mandatory;
    case 43:
      return presence_e::mandatory;
    case 109:
      return presence_e::mandatory;
    case 256:
      return presence_e::optional;
    case 257:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void cell_traffic_trace_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ngran_trace_id:
      c.destroy<fixed_octstring<8, true>>();
      break;
    case types::ngran_cgi:
      c.destroy<ngran_cgi_c>();
      break;
    case types::trace_collection_entity_ip_address:
      c.destroy<bounded_bitstring<1, 160, true, true>>();
      break;
    case types::trace_collection_entity_uri:
      c.destroy<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
      break;
    default:
      break;
  }
}
void cell_traffic_trace_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ngran_trace_id:
      c.init<fixed_octstring<8, true>>();
      break;
    case types::ngran_cgi:
      c.init<ngran_cgi_c>();
      break;
    case types::trace_collection_entity_ip_address:
      c.init<bounded_bitstring<1, 160, true, true>>();
      break;
    case types::privacy_ind:
      break;
    case types::trace_collection_entity_uri:
      c.init<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
  }
}
cell_traffic_trace_ies_o::value_c::value_c(const cell_traffic_trace_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      c.init(other.c.get<fixed_octstring<8, true>>());
      break;
    case types::ngran_cgi:
      c.init(other.c.get<ngran_cgi_c>());
      break;
    case types::trace_collection_entity_ip_address:
      c.init(other.c.get<bounded_bitstring<1, 160, true, true>>());
      break;
    case types::privacy_ind:
      c.init(other.c.get<privacy_ind_e>());
      break;
    case types::trace_collection_entity_uri:
      c.init(other.c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
  }
}
cell_traffic_trace_ies_o::value_c&
cell_traffic_trace_ies_o::value_c::operator=(const cell_traffic_trace_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      c.set(other.c.get<fixed_octstring<8, true>>());
      break;
    case types::ngran_cgi:
      c.set(other.c.get<ngran_cgi_c>());
      break;
    case types::trace_collection_entity_ip_address:
      c.set(other.c.get<bounded_bitstring<1, 160, true, true>>());
      break;
    case types::privacy_ind:
      c.set(other.c.get<privacy_ind_e>());
      break;
    case types::trace_collection_entity_uri:
      c.set(other.c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
  }

  return *this;
}
uint64_t& cell_traffic_trace_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& cell_traffic_trace_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
fixed_octstring<8, true>& cell_traffic_trace_ies_o::value_c::ngran_trace_id()
{
  assert_choice_type(types::ngran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true>>();
}
ngran_cgi_c& cell_traffic_trace_ies_o::value_c::ngran_cgi()
{
  assert_choice_type(types::ngran_cgi, type_, "Value");
  return c.get<ngran_cgi_c>();
}
bounded_bitstring<1, 160, true, true>& cell_traffic_trace_ies_o::value_c::trace_collection_entity_ip_address()
{
  assert_choice_type(types::trace_collection_entity_ip_address, type_, "Value");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
privacy_ind_e& cell_traffic_trace_ies_o::value_c::privacy_ind()
{
  assert_choice_type(types::privacy_ind, type_, "Value");
  return c.get<privacy_ind_e>();
}
visible_string<0, MAX_ASN_STRING_LENGTH, false, true>& cell_traffic_trace_ies_o::value_c::trace_collection_entity_uri()
{
  assert_choice_type(types::trace_collection_entity_uri, type_, "Value");
  return c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
}
const uint64_t& cell_traffic_trace_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& cell_traffic_trace_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const fixed_octstring<8, true>& cell_traffic_trace_ies_o::value_c::ngran_trace_id() const
{
  assert_choice_type(types::ngran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true>>();
}
const ngran_cgi_c& cell_traffic_trace_ies_o::value_c::ngran_cgi() const
{
  assert_choice_type(types::ngran_cgi, type_, "Value");
  return c.get<ngran_cgi_c>();
}
const bounded_bitstring<1, 160, true, true>&
cell_traffic_trace_ies_o::value_c::trace_collection_entity_ip_address() const
{
  assert_choice_type(types::trace_collection_entity_ip_address, type_, "Value");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
const privacy_ind_e& cell_traffic_trace_ies_o::value_c::privacy_ind() const
{
  assert_choice_type(types::privacy_ind, type_, "Value");
  return c.get<privacy_ind_e>();
}
const visible_string<0, MAX_ASN_STRING_LENGTH, false, true>&
cell_traffic_trace_ies_o::value_c::trace_collection_entity_uri() const
{
  assert_choice_type(types::trace_collection_entity_uri, type_, "Value");
  return c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
}
void cell_traffic_trace_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<8, true>>().to_string());
      break;
    case types::ngran_cgi:
      j.write_fieldname("NGRAN-CGI");
      c.get<ngran_cgi_c>().to_json(j);
      break;
    case types::trace_collection_entity_ip_address:
      j.write_str("BIT STRING", c.get<bounded_bitstring<1, 160, true, true>>().to_string());
      break;
    case types::privacy_ind:
      j.write_str("PrivacyIndicator", c.get<privacy_ind_e>().to_string());
      break;
    case types::trace_collection_entity_uri:
      j.write_str("VisibleString", c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE cell_traffic_trace_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ngran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().pack(bref)));
      break;
    case types::ngran_cgi:
      HANDLE_CODE(c.get<ngran_cgi_c>().pack(bref));
      break;
    case types::trace_collection_entity_ip_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().pack(bref)));
      break;
    case types::privacy_ind:
      HANDLE_CODE(c.get<privacy_ind_e>().pack(bref));
      break;
    case types::trace_collection_entity_uri:
      HANDLE_CODE((c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_traffic_trace_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ngran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().unpack(bref)));
      break;
    case types::ngran_cgi:
      HANDLE_CODE(c.get<ngran_cgi_c>().unpack(bref));
      break;
    case types::trace_collection_entity_ip_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().unpack(bref)));
      break;
    case types::privacy_ind:
      HANDLE_CODE(c.get<privacy_ind_e>().unpack(bref));
      break;
    case types::trace_collection_entity_uri:
      HANDLE_CODE((c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

cell_traffic_trace_ies_container::cell_traffic_trace_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  ngran_trace_id(44, crit_e::ignore),
  ngran_cgi(43, crit_e::ignore),
  trace_collection_entity_ip_address(109, crit_e::ignore),
  privacy_ind(256, crit_e::ignore),
  trace_collection_entity_uri(257, crit_e::ignore)
{
}
SRSASN_CODE cell_traffic_trace_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 5;
  nof_ies += privacy_ind_present ? 1 : 0;
  nof_ies += trace_collection_entity_uri_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(ngran_trace_id.pack(bref));
  HANDLE_CODE(ngran_cgi.pack(bref));
  HANDLE_CODE(trace_collection_entity_ip_address.pack(bref));
  if (privacy_ind_present) {
    HANDLE_CODE(privacy_ind.pack(bref));
  }
  if (trace_collection_entity_uri_present) {
    HANDLE_CODE(trace_collection_entity_uri.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_traffic_trace_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 5;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 44: {
        nof_mandatory_ies--;
        ngran_trace_id.id = id;
        HANDLE_CODE(ngran_trace_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ngran_trace_id.value.unpack(bref));
        break;
      }
      case 43: {
        nof_mandatory_ies--;
        ngran_cgi.id = id;
        HANDLE_CODE(ngran_cgi.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ngran_cgi.value.unpack(bref));
        break;
      }
      case 109: {
        nof_mandatory_ies--;
        trace_collection_entity_ip_address.id = id;
        HANDLE_CODE(trace_collection_entity_ip_address.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trace_collection_entity_ip_address.value.unpack(bref));
        break;
      }
      case 256: {
        privacy_ind_present = true;
        privacy_ind.id      = id;
        HANDLE_CODE(privacy_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(privacy_ind.value.unpack(bref));
        break;
      }
      case 257: {
        trace_collection_entity_uri_present = true;
        trace_collection_entity_uri.id      = id;
        HANDLE_CODE(trace_collection_entity_uri.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trace_collection_entity_uri.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void cell_traffic_trace_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ngran_trace_id.to_json(j);
  j.write_fieldname("");
  ngran_cgi.to_json(j);
  j.write_fieldname("");
  trace_collection_entity_ip_address.to_json(j);
  if (privacy_ind_present) {
    j.write_fieldname("");
    privacy_ind.to_json(j);
  }
  if (trace_collection_entity_uri_present) {
    j.write_fieldname("");
    trace_collection_entity_uri.to_json(j);
  }
  j.end_obj();
}

// ConnectionEstablishmentIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t conn_establishment_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 117, 226, 148, 0, 209, 212, 210, 205, 222, 264, 34};
  return map_enum_number(names, 13, idx, "id");
}
bool conn_establishment_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 117, 226, 148, 0, 209, 212, 210, 205, 222, 264, 34};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e conn_establishment_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 117:
      return crit_e::ignore;
    case 226:
      return crit_e::ignore;
    case 148:
      return crit_e::ignore;
    case 0:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 212:
      return crit_e::ignore;
    case 210:
      return crit_e::ignore;
    case 205:
      return crit_e::ignore;
    case 222:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    case 34:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
conn_establishment_ind_ies_o::value_c conn_establishment_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 226:
      ret.set(value_c::types::end_ind);
      break;
    case 148:
      ret.set(value_c::types::s_nssai);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 209:
      ret.set(value_c::types::ue_diff_info);
      break;
    case 212:
      ret.set(value_c::types::dl_cp_security_info);
      break;
    case 210:
      ret.set(value_c::types::nb_iot_ue_prio);
      break;
    case 205:
      ret.set(value_c::types::enhanced_coverage_restrict);
      break;
    case 222:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 34:
      ret.set(value_c::types::masked_imeisv);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e conn_establishment_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 117:
      return presence_e::optional;
    case 226:
      return presence_e::optional;
    case 148:
      return presence_e::optional;
    case 0:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 212:
      return presence_e::optional;
    case 210:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 34:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void conn_establishment_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::s_nssai:
      c.destroy<s_nssai_s>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    case types::ue_diff_info:
      c.destroy<ue_diff_info_s>();
      break;
    case types::dl_cp_security_info:
      c.destroy<dl_cp_security_info_s>();
      break;
    case types::ue_radio_cap_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::masked_imeisv:
      c.destroy<fixed_bitstring<64, false, true>>();
      break;
    default:
      break;
  }
}
void conn_establishment_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true>>();
      break;
    case types::end_ind:
      break;
    case types::s_nssai:
      c.init<s_nssai_s>();
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::ue_diff_info:
      c.init<ue_diff_info_s>();
      break;
    case types::dl_cp_security_info:
      c.init<dl_cp_security_info_s>();
      break;
    case types::nb_iot_ue_prio:
      break;
    case types::enhanced_coverage_restrict:
      break;
    case types::ce_mode_brestricted:
      break;
    case types::ue_radio_cap_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::masked_imeisv:
      c.init<fixed_bitstring<64, false, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
  }
}
conn_establishment_ind_ies_o::value_c::value_c(const conn_establishment_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::end_ind:
      c.init(other.c.get<end_ind_e>());
      break;
    case types::s_nssai:
      c.init(other.c.get<s_nssai_s>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::ue_diff_info:
      c.init(other.c.get<ue_diff_info_s>());
      break;
    case types::dl_cp_security_info:
      c.init(other.c.get<dl_cp_security_info_s>());
      break;
    case types::nb_iot_ue_prio:
      c.init(other.c.get<uint16_t>());
      break;
    case types::enhanced_coverage_restrict:
      c.init(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::ce_mode_brestricted:
      c.init(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_radio_cap_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::masked_imeisv:
      c.init(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
  }
}
conn_establishment_ind_ies_o::value_c&
conn_establishment_ind_ies_o::value_c::operator=(const conn_establishment_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::end_ind:
      c.set(other.c.get<end_ind_e>());
      break;
    case types::s_nssai:
      c.set(other.c.get<s_nssai_s>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::ue_diff_info:
      c.set(other.c.get<ue_diff_info_s>());
      break;
    case types::dl_cp_security_info:
      c.set(other.c.get<dl_cp_security_info_s>());
      break;
    case types::nb_iot_ue_prio:
      c.set(other.c.get<uint16_t>());
      break;
    case types::enhanced_coverage_restrict:
      c.set(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::ce_mode_brestricted:
      c.set(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_radio_cap_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::masked_imeisv:
      c.set(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& conn_establishment_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& conn_establishment_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& conn_establishment_ind_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
end_ind_e& conn_establishment_ind_ies_o::value_c::end_ind()
{
  assert_choice_type(types::end_ind, type_, "Value");
  return c.get<end_ind_e>();
}
s_nssai_s& conn_establishment_ind_ies_o::value_c::s_nssai()
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
allowed_nssai_l& conn_establishment_ind_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
ue_diff_info_s& conn_establishment_ind_ies_o::value_c::ue_diff_info()
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
dl_cp_security_info_s& conn_establishment_ind_ies_o::value_c::dl_cp_security_info()
{
  assert_choice_type(types::dl_cp_security_info, type_, "Value");
  return c.get<dl_cp_security_info_s>();
}
uint16_t& conn_establishment_ind_ies_o::value_c::nb_iot_ue_prio()
{
  assert_choice_type(types::nb_iot_ue_prio, type_, "Value");
  return c.get<uint16_t>();
}
enhanced_coverage_restrict_e& conn_establishment_ind_ies_o::value_c::enhanced_coverage_restrict()
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
ce_mode_brestricted_e& conn_establishment_ind_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
unbounded_octstring<true>& conn_establishment_ind_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
fixed_bitstring<64, false, true>& conn_establishment_ind_ies_o::value_c::masked_imeisv()
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
const uint64_t& conn_establishment_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& conn_establishment_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& conn_establishment_ind_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const end_ind_e& conn_establishment_ind_ies_o::value_c::end_ind() const
{
  assert_choice_type(types::end_ind, type_, "Value");
  return c.get<end_ind_e>();
}
const s_nssai_s& conn_establishment_ind_ies_o::value_c::s_nssai() const
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
const allowed_nssai_l& conn_establishment_ind_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const ue_diff_info_s& conn_establishment_ind_ies_o::value_c::ue_diff_info() const
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
const dl_cp_security_info_s& conn_establishment_ind_ies_o::value_c::dl_cp_security_info() const
{
  assert_choice_type(types::dl_cp_security_info, type_, "Value");
  return c.get<dl_cp_security_info_s>();
}
const uint16_t& conn_establishment_ind_ies_o::value_c::nb_iot_ue_prio() const
{
  assert_choice_type(types::nb_iot_ue_prio, type_, "Value");
  return c.get<uint16_t>();
}
const enhanced_coverage_restrict_e& conn_establishment_ind_ies_o::value_c::enhanced_coverage_restrict() const
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
const ce_mode_brestricted_e& conn_establishment_ind_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const unbounded_octstring<true>& conn_establishment_ind_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const fixed_bitstring<64, false, true>& conn_establishment_ind_ies_o::value_c::masked_imeisv() const
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
void conn_establishment_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::end_ind:
      j.write_str("EndIndication", c.get<end_ind_e>().to_string());
      break;
    case types::s_nssai:
      j.write_fieldname("S-NSSAI");
      c.get<s_nssai_s>().to_json(j);
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ue_diff_info:
      j.write_fieldname("UE-DifferentiationInfo");
      c.get<ue_diff_info_s>().to_json(j);
      break;
    case types::dl_cp_security_info:
      j.write_fieldname("DL-CP-SecurityInformation");
      c.get<dl_cp_security_info_s>().to_json(j);
      break;
    case types::nb_iot_ue_prio:
      j.write_int("INTEGER (0..255,...)", c.get<uint16_t>());
      break;
    case types::enhanced_coverage_restrict:
      j.write_str("Enhanced-CoverageRestriction", "restricted");
      break;
    case types::ce_mode_brestricted:
      j.write_str("CEmodeBrestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::masked_imeisv:
      j.write_str("BIT STRING", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE conn_establishment_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::end_ind:
      HANDLE_CODE(c.get<end_ind_e>().pack(bref));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().pack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().pack(bref));
      break;
    case types::dl_cp_security_info:
      HANDLE_CODE(c.get<dl_cp_security_info_s>().pack(bref));
      break;
    case types::nb_iot_ue_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, true, true));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE conn_establishment_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::end_ind:
      HANDLE_CODE(c.get<end_ind_e>().unpack(bref));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().unpack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().unpack(bref));
      break;
    case types::dl_cp_security_info:
      HANDLE_CODE(c.get<dl_cp_security_info_s>().unpack(bref));
      break;
    case types::nb_iot_ue_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, true, true));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

conn_establishment_ind_ies_container::conn_establishment_ind_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  ue_radio_cap(117, crit_e::ignore),
  end_ind(226, crit_e::ignore),
  s_nssai(148, crit_e::ignore),
  allowed_nssai(0, crit_e::ignore),
  ue_diff_info(209, crit_e::ignore),
  dl_cp_security_info(212, crit_e::ignore),
  nb_iot_ue_prio(210, crit_e::ignore),
  enhanced_coverage_restrict(205, crit_e::ignore),
  ce_mode_brestricted(222, crit_e::ignore),
  ue_radio_cap_id(264, crit_e::reject),
  masked_imeisv(34, crit_e::ignore)
{
}
SRSASN_CODE conn_establishment_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  nof_ies += end_ind_present ? 1 : 0;
  nof_ies += s_nssai_present ? 1 : 0;
  nof_ies += allowed_nssai_present ? 1 : 0;
  nof_ies += ue_diff_info_present ? 1 : 0;
  nof_ies += dl_cp_security_info_present ? 1 : 0;
  nof_ies += nb_iot_ue_prio_present ? 1 : 0;
  nof_ies += enhanced_coverage_restrict_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += masked_imeisv_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (ue_radio_cap_present) {
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (end_ind_present) {
    HANDLE_CODE(end_ind.pack(bref));
  }
  if (s_nssai_present) {
    HANDLE_CODE(s_nssai.pack(bref));
  }
  if (allowed_nssai_present) {
    HANDLE_CODE(allowed_nssai.pack(bref));
  }
  if (ue_diff_info_present) {
    HANDLE_CODE(ue_diff_info.pack(bref));
  }
  if (dl_cp_security_info_present) {
    HANDLE_CODE(dl_cp_security_info.pack(bref));
  }
  if (nb_iot_ue_prio_present) {
    HANDLE_CODE(nb_iot_ue_prio.pack(bref));
  }
  if (enhanced_coverage_restrict_present) {
    HANDLE_CODE(enhanced_coverage_restrict.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (masked_imeisv_present) {
    HANDLE_CODE(masked_imeisv.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE conn_establishment_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 117: {
        ue_radio_cap_present = true;
        ue_radio_cap.id      = id;
        HANDLE_CODE(ue_radio_cap.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.value.unpack(bref));
        break;
      }
      case 226: {
        end_ind_present = true;
        end_ind.id      = id;
        HANDLE_CODE(end_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(end_ind.value.unpack(bref));
        break;
      }
      case 148: {
        s_nssai_present = true;
        s_nssai.id      = id;
        HANDLE_CODE(s_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(s_nssai.value.unpack(bref));
        break;
      }
      case 0: {
        allowed_nssai_present = true;
        allowed_nssai.id      = id;
        HANDLE_CODE(allowed_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(allowed_nssai.value.unpack(bref));
        break;
      }
      case 209: {
        ue_diff_info_present = true;
        ue_diff_info.id      = id;
        HANDLE_CODE(ue_diff_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_diff_info.value.unpack(bref));
        break;
      }
      case 212: {
        dl_cp_security_info_present = true;
        dl_cp_security_info.id      = id;
        HANDLE_CODE(dl_cp_security_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(dl_cp_security_info.value.unpack(bref));
        break;
      }
      case 210: {
        nb_iot_ue_prio_present = true;
        nb_iot_ue_prio.id      = id;
        HANDLE_CODE(nb_iot_ue_prio.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nb_iot_ue_prio.value.unpack(bref));
        break;
      }
      case 205: {
        enhanced_coverage_restrict_present = true;
        enhanced_coverage_restrict.id      = id;
        HANDLE_CODE(enhanced_coverage_restrict.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(enhanced_coverage_restrict.value.unpack(bref));
        break;
      }
      case 222: {
        ce_mode_brestricted_present = true;
        ce_mode_brestricted.id      = id;
        HANDLE_CODE(ce_mode_brestricted.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_brestricted.value.unpack(bref));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        ue_radio_cap_id.id      = id;
        HANDLE_CODE(ue_radio_cap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.value.unpack(bref));
        break;
      }
      case 34: {
        masked_imeisv_present = true;
        masked_imeisv.id      = id;
        HANDLE_CODE(masked_imeisv.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(masked_imeisv.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void conn_establishment_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (ue_radio_cap_present) {
    j.write_fieldname("");
    ue_radio_cap.to_json(j);
  }
  if (end_ind_present) {
    j.write_fieldname("");
    end_ind.to_json(j);
  }
  if (s_nssai_present) {
    j.write_fieldname("");
    s_nssai.to_json(j);
  }
  if (allowed_nssai_present) {
    j.write_fieldname("");
    allowed_nssai.to_json(j);
  }
  if (ue_diff_info_present) {
    j.write_fieldname("");
    ue_diff_info.to_json(j);
  }
  if (dl_cp_security_info_present) {
    j.write_fieldname("");
    dl_cp_security_info.to_json(j);
  }
  if (nb_iot_ue_prio_present) {
    j.write_fieldname("");
    nb_iot_ue_prio.to_json(j);
  }
  if (enhanced_coverage_restrict_present) {
    j.write_fieldname("");
    enhanced_coverage_restrict.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_fieldname("");
    ce_mode_brestricted.to_json(j);
  }
  if (ue_radio_cap_id_present) {
    j.write_fieldname("");
    ue_radio_cap_id.to_json(j);
  }
  if (masked_imeisv_present) {
    j.write_fieldname("");
    masked_imeisv.to_json(j);
  }
  j.end_obj();
}

// DeactivateTraceIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t deactiv_trace_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 44};
  return map_enum_number(names, 3, idx, "id");
}
bool deactiv_trace_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 44};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e deactiv_trace_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 44:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
deactiv_trace_ies_o::value_c deactiv_trace_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 44:
      ret.set(value_c::types::ngran_trace_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e deactiv_trace_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 44:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void deactiv_trace_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ngran_trace_id:
      c.destroy<fixed_octstring<8, true>>();
      break;
    default:
      break;
  }
}
void deactiv_trace_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ngran_trace_id:
      c.init<fixed_octstring<8, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
  }
}
deactiv_trace_ies_o::value_c::value_c(const deactiv_trace_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      c.init(other.c.get<fixed_octstring<8, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
  }
}
deactiv_trace_ies_o::value_c& deactiv_trace_ies_o::value_c::operator=(const deactiv_trace_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      c.set(other.c.get<fixed_octstring<8, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
  }

  return *this;
}
uint64_t& deactiv_trace_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& deactiv_trace_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
fixed_octstring<8, true>& deactiv_trace_ies_o::value_c::ngran_trace_id()
{
  assert_choice_type(types::ngran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true>>();
}
const uint64_t& deactiv_trace_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& deactiv_trace_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const fixed_octstring<8, true>& deactiv_trace_ies_o::value_c::ngran_trace_id() const
{
  assert_choice_type(types::ngran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true>>();
}
void deactiv_trace_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<8, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE deactiv_trace_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ngran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE deactiv_trace_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ngran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

deactiv_trace_ies_container::deactiv_trace_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject), ran_ue_ngap_id(85, crit_e::reject), ngran_trace_id(44, crit_e::ignore)
{
}
SRSASN_CODE deactiv_trace_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(ngran_trace_id.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE deactiv_trace_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 44: {
        nof_mandatory_ies--;
        ngran_trace_id.id = id;
        HANDLE_CODE(ngran_trace_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ngran_trace_id.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void deactiv_trace_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ngran_trace_id.to_json(j);
  j.end_obj();
}

// DistributionReleaseRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t distribution_release_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 300, 15};
  return map_enum_number(names, 4, idx, "id");
}
bool distribution_release_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 300, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e distribution_release_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 300:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
distribution_release_request_ies_o::value_c distribution_release_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 300:
      ret.set(value_c::types::mbs_distribution_release_request_transfer);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e distribution_release_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 300:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void distribution_release_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_distribution_release_request_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void distribution_release_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_area_session_id:
      break;
    case types::mbs_distribution_release_request_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_request_ies_o::value_c");
  }
}
distribution_release_request_ies_o::value_c::value_c(const distribution_release_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::mbs_distribution_release_request_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_request_ies_o::value_c");
  }
}
distribution_release_request_ies_o::value_c&
distribution_release_request_ies_o::value_c::operator=(const distribution_release_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::mbs_distribution_release_request_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_request_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& distribution_release_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& distribution_release_request_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& distribution_release_request_ies_o::value_c::mbs_distribution_release_request_transfer()
{
  assert_choice_type(types::mbs_distribution_release_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
cause_c& distribution_release_request_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const mbs_session_id_s& distribution_release_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& distribution_release_request_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>&
distribution_release_request_ies_o::value_c::mbs_distribution_release_request_transfer() const
{
  assert_choice_type(types::mbs_distribution_release_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const cause_c& distribution_release_request_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void distribution_release_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::mbs_distribution_release_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE distribution_release_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_release_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_release_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_release_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

distribution_release_request_ies_container::distribution_release_request_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_area_session_id(295, crit_e::reject),
  mbs_distribution_release_request_transfer(300, crit_e::reject),
  cause(15, crit_e::ignore)
{
}
SRSASN_CODE distribution_release_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(mbs_area_session_id.pack(bref));
  }
  HANDLE_CODE(mbs_distribution_release_request_transfer.pack(bref));
  HANDLE_CODE(cause.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_release_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        mbs_area_session_id.id      = id;
        HANDLE_CODE(mbs_area_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_area_session_id.value.unpack(bref));
        break;
      }
      case 300: {
        nof_mandatory_ies--;
        mbs_distribution_release_request_transfer.id = id;
        HANDLE_CODE(mbs_distribution_release_request_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_distribution_release_request_transfer.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void distribution_release_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_fieldname("");
    mbs_area_session_id.to_json(j);
  }
  j.write_fieldname("");
  mbs_distribution_release_request_transfer.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.end_obj();
}

// DistributionReleaseResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t distribution_release_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool distribution_release_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e distribution_release_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
distribution_release_resp_ies_o::value_c distribution_release_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e distribution_release_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void distribution_release_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void distribution_release_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_area_session_id:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_resp_ies_o::value_c");
  }
}
distribution_release_resp_ies_o::value_c::value_c(const distribution_release_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_resp_ies_o::value_c");
  }
}
distribution_release_resp_ies_o::value_c&
distribution_release_resp_ies_o::value_c::operator=(const distribution_release_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_resp_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& distribution_release_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& distribution_release_resp_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
crit_diagnostics_s& distribution_release_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& distribution_release_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& distribution_release_resp_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const crit_diagnostics_s& distribution_release_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void distribution_release_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE distribution_release_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_release_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

distribution_release_resp_ies_container::distribution_release_resp_ies_container() :
  mbs_session_id(299, crit_e::reject), mbs_area_session_id(295, crit_e::reject), crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE distribution_release_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(mbs_area_session_id.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_release_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        mbs_area_session_id.id      = id;
        HANDLE_CODE(mbs_area_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_area_session_id.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void distribution_release_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_fieldname("");
    mbs_area_session_id.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// DistributionSetupFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t distribution_setup_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 303, 15, 19};
  return map_enum_number(names, 5, idx, "id");
}
bool distribution_setup_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 303, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e distribution_setup_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 303:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
distribution_setup_fail_ies_o::value_c distribution_setup_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 303:
      ret.set(value_c::types::mbs_distribution_setup_unsuccessful_transfer);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e distribution_setup_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 303:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void distribution_setup_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void distribution_setup_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_area_session_id:
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_fail_ies_o::value_c");
  }
}
distribution_setup_fail_ies_o::value_c::value_c(const distribution_setup_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_fail_ies_o::value_c");
  }
}
distribution_setup_fail_ies_o::value_c&
distribution_setup_fail_ies_o::value_c::operator=(const distribution_setup_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_fail_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& distribution_setup_fail_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& distribution_setup_fail_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& distribution_setup_fail_ies_o::value_c::mbs_distribution_setup_unsuccessful_transfer()
{
  assert_choice_type(types::mbs_distribution_setup_unsuccessful_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
cause_c& distribution_setup_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& distribution_setup_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& distribution_setup_fail_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& distribution_setup_fail_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>&
distribution_setup_fail_ies_o::value_c::mbs_distribution_setup_unsuccessful_transfer() const
{
  assert_choice_type(types::mbs_distribution_setup_unsuccessful_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const cause_c& distribution_setup_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& distribution_setup_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void distribution_setup_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE distribution_setup_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_setup_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

distribution_setup_fail_ies_container::distribution_setup_fail_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_area_session_id(295, crit_e::reject),
  mbs_distribution_setup_unsuccessful_transfer(303, crit_e::ignore),
  cause(15, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE distribution_setup_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(mbs_area_session_id.pack(bref));
  }
  HANDLE_CODE(mbs_distribution_setup_unsuccessful_transfer.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_setup_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        mbs_area_session_id.id      = id;
        HANDLE_CODE(mbs_area_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_area_session_id.value.unpack(bref));
        break;
      }
      case 303: {
        nof_mandatory_ies--;
        mbs_distribution_setup_unsuccessful_transfer.id = id;
        HANDLE_CODE(mbs_distribution_setup_unsuccessful_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_distribution_setup_unsuccessful_transfer.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void distribution_setup_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_fieldname("");
    mbs_area_session_id.to_json(j);
  }
  j.write_fieldname("");
  mbs_distribution_setup_unsuccessful_transfer.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// DistributionSetupRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t distribution_setup_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 301};
  return map_enum_number(names, 3, idx, "id");
}
bool distribution_setup_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 301};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e distribution_setup_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 301:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
distribution_setup_request_ies_o::value_c distribution_setup_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 301:
      ret.set(value_c::types::mbs_distribution_setup_request_transfer);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e distribution_setup_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 301:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void distribution_setup_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_distribution_setup_request_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void distribution_setup_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_area_session_id:
      break;
    case types::mbs_distribution_setup_request_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_request_ies_o::value_c");
  }
}
distribution_setup_request_ies_o::value_c::value_c(const distribution_setup_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_request_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_request_ies_o::value_c");
  }
}
distribution_setup_request_ies_o::value_c&
distribution_setup_request_ies_o::value_c::operator=(const distribution_setup_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_request_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_request_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& distribution_setup_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& distribution_setup_request_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& distribution_setup_request_ies_o::value_c::mbs_distribution_setup_request_transfer()
{
  assert_choice_type(types::mbs_distribution_setup_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_id_s& distribution_setup_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& distribution_setup_request_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>&
distribution_setup_request_ies_o::value_c::mbs_distribution_setup_request_transfer() const
{
  assert_choice_type(types::mbs_distribution_setup_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void distribution_setup_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE distribution_setup_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_setup_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_setup_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_setup_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

distribution_setup_request_ies_container::distribution_setup_request_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_area_session_id(295, crit_e::reject),
  mbs_distribution_setup_request_transfer(301, crit_e::reject)
{
}
SRSASN_CODE distribution_setup_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(mbs_area_session_id.pack(bref));
  }
  HANDLE_CODE(mbs_distribution_setup_request_transfer.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_setup_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        mbs_area_session_id.id      = id;
        HANDLE_CODE(mbs_area_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_area_session_id.value.unpack(bref));
        break;
      }
      case 301: {
        nof_mandatory_ies--;
        mbs_distribution_setup_request_transfer.id = id;
        HANDLE_CODE(mbs_distribution_setup_request_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_distribution_setup_request_transfer.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void distribution_setup_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_fieldname("");
    mbs_area_session_id.to_json(j);
  }
  j.write_fieldname("");
  mbs_distribution_setup_request_transfer.to_json(j);
  j.end_obj();
}

// DistributionSetupResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t distribution_setup_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 302, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool distribution_setup_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 302, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e distribution_setup_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 302:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
distribution_setup_resp_ies_o::value_c distribution_setup_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 302:
      ret.set(value_c::types::mbs_distribution_setup_resp_transfer);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e distribution_setup_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 302:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void distribution_setup_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_distribution_setup_resp_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void distribution_setup_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_area_session_id:
      break;
    case types::mbs_distribution_setup_resp_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_resp_ies_o::value_c");
  }
}
distribution_setup_resp_ies_o::value_c::value_c(const distribution_setup_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_resp_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_resp_ies_o::value_c");
  }
}
distribution_setup_resp_ies_o::value_c&
distribution_setup_resp_ies_o::value_c::operator=(const distribution_setup_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_resp_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_resp_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& distribution_setup_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& distribution_setup_resp_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& distribution_setup_resp_ies_o::value_c::mbs_distribution_setup_resp_transfer()
{
  assert_choice_type(types::mbs_distribution_setup_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& distribution_setup_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& distribution_setup_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& distribution_setup_resp_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>& distribution_setup_resp_ies_o::value_c::mbs_distribution_setup_resp_transfer() const
{
  assert_choice_type(types::mbs_distribution_setup_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& distribution_setup_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void distribution_setup_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_resp_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE distribution_setup_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_setup_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_setup_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_setup_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

distribution_setup_resp_ies_container::distribution_setup_resp_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_area_session_id(295, crit_e::reject),
  mbs_distribution_setup_resp_transfer(302, crit_e::reject),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE distribution_setup_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(mbs_area_session_id.pack(bref));
  }
  HANDLE_CODE(mbs_distribution_setup_resp_transfer.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_setup_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        mbs_area_session_id.id      = id;
        HANDLE_CODE(mbs_area_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_area_session_id.value.unpack(bref));
        break;
      }
      case 302: {
        nof_mandatory_ies--;
        mbs_distribution_setup_resp_transfer.id = id;
        HANDLE_CODE(mbs_distribution_setup_resp_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_distribution_setup_resp_transfer.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void distribution_setup_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_fieldname("");
    mbs_area_session_id.to_json(j);
  }
  j.write_fieldname("");
  mbs_distribution_setup_resp_transfer.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// DownlinkNASTransport-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_nas_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10,  85,  48,  83,  38,  36,  31,  110, 0,   177,
                                   205, 206, 209, 222, 117, 228, 226, 264, 334, 34};
  return map_enum_number(names, 20, idx, "id");
}
bool dl_nas_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10,  85,  48,  83,  38,  36,  31,  110, 0,   177,
                                   205, 206, 209, 222, 117, 228, 226, 264, 334, 34};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_nas_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 48:
      return crit_e::reject;
    case 83:
      return crit_e::ignore;
    case 38:
      return crit_e::reject;
    case 36:
      return crit_e::ignore;
    case 31:
      return crit_e::ignore;
    case 110:
      return crit_e::ignore;
    case 0:
      return crit_e::reject;
    case 177:
      return crit_e::ignore;
    case 205:
      return crit_e::ignore;
    case 206:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 222:
      return crit_e::ignore;
    case 117:
      return crit_e::ignore;
    case 228:
      return crit_e::ignore;
    case 226:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    case 334:
      return crit_e::ignore;
    case 34:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dl_nas_transport_ies_o::value_c dl_nas_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 48:
      ret.set(value_c::types::old_amf);
      break;
    case 83:
      ret.set(value_c::types::ran_paging_prio);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 36:
      ret.set(value_c::types::mob_restrict_list);
      break;
    case 31:
      ret.set(value_c::types::idx_to_rfsp);
      break;
    case 110:
      ret.set(value_c::types::ue_aggr_max_bit_rate);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 177:
      ret.set(value_c::types::srvcc_operation_possible);
      break;
    case 205:
      ret.set(value_c::types::enhanced_coverage_restrict);
      break;
    case 206:
      ret.set(value_c::types::extended_connected_time);
      break;
    case 209:
      ret.set(value_c::types::ue_diff_info);
      break;
    case 222:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 228:
      ret.set(value_c::types::ue_cap_info_request);
      break;
    case 226:
      ret.set(value_c::types::end_ind);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 334:
      ret.set(value_c::types::target_nssai_info);
      break;
    case 34:
      ret.set(value_c::types::masked_imeisv);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_nas_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 48:
      return presence_e::optional;
    case 83:
      return presence_e::optional;
    case 38:
      return presence_e::mandatory;
    case 36:
      return presence_e::optional;
    case 31:
      return presence_e::optional;
    case 110:
      return presence_e::optional;
    case 0:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 206:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    case 117:
      return presence_e::optional;
    case 228:
      return presence_e::optional;
    case 226:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 334:
      return presence_e::optional;
    case 34:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_nas_transport_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::old_amf:
      c.destroy<printable_string<1, 150, true, true>>();
      break;
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::mob_restrict_list:
      c.destroy<mob_restrict_list_s>();
      break;
    case types::ue_aggr_max_bit_rate:
      c.destroy<ue_aggr_max_bit_rate_s>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    case types::ue_diff_info:
      c.destroy<ue_diff_info_s>();
      break;
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::ue_radio_cap_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::target_nssai_info:
      c.destroy<target_nssai_info_s>();
      break;
    case types::masked_imeisv:
      c.destroy<fixed_bitstring<64, false, true>>();
      break;
    default:
      break;
  }
}
void dl_nas_transport_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::old_amf:
      c.init<printable_string<1, 150, true, true>>();
      break;
    case types::ran_paging_prio:
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::mob_restrict_list:
      c.init<mob_restrict_list_s>();
      break;
    case types::idx_to_rfsp:
      break;
    case types::ue_aggr_max_bit_rate:
      c.init<ue_aggr_max_bit_rate_s>();
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::srvcc_operation_possible:
      break;
    case types::enhanced_coverage_restrict:
      break;
    case types::extended_connected_time:
      break;
    case types::ue_diff_info:
      c.init<ue_diff_info_s>();
      break;
    case types::ce_mode_brestricted:
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true>>();
      break;
    case types::ue_cap_info_request:
      break;
    case types::end_ind:
      break;
    case types::ue_radio_cap_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::target_nssai_info:
      c.init<target_nssai_info_s>();
      break;
    case types::masked_imeisv:
      c.init<fixed_bitstring<64, false, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
  }
}
dl_nas_transport_ies_o::value_c::value_c(const dl_nas_transport_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::old_amf:
      c.init(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::ran_paging_prio:
      c.init(other.c.get<uint16_t>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::mob_restrict_list:
      c.init(other.c.get<mob_restrict_list_s>());
      break;
    case types::idx_to_rfsp:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.init(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::srvcc_operation_possible:
      c.init(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.init(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::extended_connected_time:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      c.init(other.c.get<ue_diff_info_s>());
      break;
    case types::ce_mode_brestricted:
      c.init(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_cap_info_request:
      c.init(other.c.get<ue_cap_info_request_e>());
      break;
    case types::end_ind:
      c.init(other.c.get<end_ind_e>());
      break;
    case types::ue_radio_cap_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::target_nssai_info:
      c.init(other.c.get<target_nssai_info_s>());
      break;
    case types::masked_imeisv:
      c.init(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
  }
}
dl_nas_transport_ies_o::value_c&
dl_nas_transport_ies_o::value_c::operator=(const dl_nas_transport_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::old_amf:
      c.set(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::ran_paging_prio:
      c.set(other.c.get<uint16_t>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::mob_restrict_list:
      c.set(other.c.get<mob_restrict_list_s>());
      break;
    case types::idx_to_rfsp:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.set(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::srvcc_operation_possible:
      c.set(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.set(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::extended_connected_time:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      c.set(other.c.get<ue_diff_info_s>());
      break;
    case types::ce_mode_brestricted:
      c.set(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_cap_info_request:
      c.set(other.c.get<ue_cap_info_request_e>());
      break;
    case types::end_ind:
      c.set(other.c.get<end_ind_e>());
      break;
    case types::ue_radio_cap_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::target_nssai_info:
      c.set(other.c.get<target_nssai_info_s>());
      break;
    case types::masked_imeisv:
      c.set(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
  }

  return *this;
}
uint64_t& dl_nas_transport_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& dl_nas_transport_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
printable_string<1, 150, true, true>& dl_nas_transport_ies_o::value_c::old_amf()
{
  assert_choice_type(types::old_amf, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
uint16_t& dl_nas_transport_ies_o::value_c::ran_paging_prio()
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
mob_restrict_list_s& dl_nas_transport_ies_o::value_c::mob_restrict_list()
{
  assert_choice_type(types::mob_restrict_list, type_, "Value");
  return c.get<mob_restrict_list_s>();
}
uint16_t& dl_nas_transport_ies_o::value_c::idx_to_rfsp()
{
  assert_choice_type(types::idx_to_rfsp, type_, "Value");
  return c.get<uint16_t>();
}
ue_aggr_max_bit_rate_s& dl_nas_transport_ies_o::value_c::ue_aggr_max_bit_rate()
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
allowed_nssai_l& dl_nas_transport_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
srvcc_operation_possible_e& dl_nas_transport_ies_o::value_c::srvcc_operation_possible()
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
enhanced_coverage_restrict_e& dl_nas_transport_ies_o::value_c::enhanced_coverage_restrict()
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
uint16_t& dl_nas_transport_ies_o::value_c::extended_connected_time()
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
ue_diff_info_s& dl_nas_transport_ies_o::value_c::ue_diff_info()
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
ce_mode_brestricted_e& dl_nas_transport_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
ue_cap_info_request_e& dl_nas_transport_ies_o::value_c::ue_cap_info_request()
{
  assert_choice_type(types::ue_cap_info_request, type_, "Value");
  return c.get<ue_cap_info_request_e>();
}
end_ind_e& dl_nas_transport_ies_o::value_c::end_ind()
{
  assert_choice_type(types::end_ind, type_, "Value");
  return c.get<end_ind_e>();
}
unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
target_nssai_info_s& dl_nas_transport_ies_o::value_c::target_nssai_info()
{
  assert_choice_type(types::target_nssai_info, type_, "Value");
  return c.get<target_nssai_info_s>();
}
fixed_bitstring<64, false, true>& dl_nas_transport_ies_o::value_c::masked_imeisv()
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
const uint64_t& dl_nas_transport_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& dl_nas_transport_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const printable_string<1, 150, true, true>& dl_nas_transport_ies_o::value_c::old_amf() const
{
  assert_choice_type(types::old_amf, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
const uint16_t& dl_nas_transport_ies_o::value_c::ran_paging_prio() const
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
const unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mob_restrict_list_s& dl_nas_transport_ies_o::value_c::mob_restrict_list() const
{
  assert_choice_type(types::mob_restrict_list, type_, "Value");
  return c.get<mob_restrict_list_s>();
}
const uint16_t& dl_nas_transport_ies_o::value_c::idx_to_rfsp() const
{
  assert_choice_type(types::idx_to_rfsp, type_, "Value");
  return c.get<uint16_t>();
}
const ue_aggr_max_bit_rate_s& dl_nas_transport_ies_o::value_c::ue_aggr_max_bit_rate() const
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
const allowed_nssai_l& dl_nas_transport_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const srvcc_operation_possible_e& dl_nas_transport_ies_o::value_c::srvcc_operation_possible() const
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
const enhanced_coverage_restrict_e& dl_nas_transport_ies_o::value_c::enhanced_coverage_restrict() const
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
const uint16_t& dl_nas_transport_ies_o::value_c::extended_connected_time() const
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
const ue_diff_info_s& dl_nas_transport_ies_o::value_c::ue_diff_info() const
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
const ce_mode_brestricted_e& dl_nas_transport_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const ue_cap_info_request_e& dl_nas_transport_ies_o::value_c::ue_cap_info_request() const
{
  assert_choice_type(types::ue_cap_info_request, type_, "Value");
  return c.get<ue_cap_info_request_e>();
}
const end_ind_e& dl_nas_transport_ies_o::value_c::end_ind() const
{
  assert_choice_type(types::end_ind, type_, "Value");
  return c.get<end_ind_e>();
}
const unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const target_nssai_info_s& dl_nas_transport_ies_o::value_c::target_nssai_info() const
{
  assert_choice_type(types::target_nssai_info, type_, "Value");
  return c.get<target_nssai_info_s>();
}
const fixed_bitstring<64, false, true>& dl_nas_transport_ies_o::value_c::masked_imeisv() const
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
void dl_nas_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::old_amf:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true>>().to_string());
      break;
    case types::ran_paging_prio:
      j.write_int("INTEGER (1..256)", c.get<uint16_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::mob_restrict_list:
      j.write_fieldname("MobilityRestrictionList");
      c.get<mob_restrict_list_s>().to_json(j);
      break;
    case types::idx_to_rfsp:
      j.write_int("INTEGER (1..256,...)", c.get<uint16_t>());
      break;
    case types::ue_aggr_max_bit_rate:
      j.write_fieldname("UEAggregateMaximumBitRate");
      c.get<ue_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::srvcc_operation_possible:
      j.write_str("SRVCCOperationPossible", c.get<srvcc_operation_possible_e>().to_string());
      break;
    case types::enhanced_coverage_restrict:
      j.write_str("Enhanced-CoverageRestriction", "restricted");
      break;
    case types::extended_connected_time:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      j.write_fieldname("UE-DifferentiationInfo");
      c.get<ue_diff_info_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CEmodeBrestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::ue_cap_info_request:
      j.write_str("UECapabilityInfoRequest", "requested");
      break;
    case types::end_ind:
      j.write_str("EndIndication", c.get<end_ind_e>().to_string());
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::target_nssai_info:
      j.write_fieldname("TargetNSSAIInformation");
      c.get<target_nssai_info_s>().to_json(j);
      break;
    case types::masked_imeisv:
      j.write_str("BIT STRING", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_nas_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::old_amf:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().pack(bref)));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::mob_restrict_list:
      HANDLE_CODE(c.get<mob_restrict_list_s>().pack(bref));
      break;
    case types::idx_to_rfsp:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().pack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().pack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::ue_cap_info_request:
      HANDLE_CODE(c.get<ue_cap_info_request_e>().pack(bref));
      break;
    case types::end_ind:
      HANDLE_CODE(c.get<end_ind_e>().pack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::target_nssai_info:
      HANDLE_CODE(c.get<target_nssai_info_s>().pack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_nas_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::old_amf:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().unpack(bref)));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::mob_restrict_list:
      HANDLE_CODE(c.get<mob_restrict_list_s>().unpack(bref));
      break;
    case types::idx_to_rfsp:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().unpack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().unpack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::ue_cap_info_request:
      HANDLE_CODE(c.get<ue_cap_info_request_e>().unpack(bref));
      break;
    case types::end_ind:
      HANDLE_CODE(c.get<end_ind_e>().unpack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::target_nssai_info:
      HANDLE_CODE(c.get<target_nssai_info_s>().unpack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

dl_nas_transport_ies_container::dl_nas_transport_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  old_amf(48, crit_e::reject),
  ran_paging_prio(83, crit_e::ignore),
  nas_pdu(38, crit_e::reject),
  mob_restrict_list(36, crit_e::ignore),
  idx_to_rfsp(31, crit_e::ignore),
  ue_aggr_max_bit_rate(110, crit_e::ignore),
  allowed_nssai(0, crit_e::reject),
  srvcc_operation_possible(177, crit_e::ignore),
  enhanced_coverage_restrict(205, crit_e::ignore),
  extended_connected_time(206, crit_e::ignore),
  ue_diff_info(209, crit_e::ignore),
  ce_mode_brestricted(222, crit_e::ignore),
  ue_radio_cap(117, crit_e::ignore),
  ue_cap_info_request(228, crit_e::ignore),
  end_ind(226, crit_e::ignore),
  ue_radio_cap_id(264, crit_e::reject),
  target_nssai_info(334, crit_e::ignore),
  masked_imeisv(34, crit_e::ignore)
{
}
SRSASN_CODE dl_nas_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += old_amf_present ? 1 : 0;
  nof_ies += ran_paging_prio_present ? 1 : 0;
  nof_ies += mob_restrict_list_present ? 1 : 0;
  nof_ies += idx_to_rfsp_present ? 1 : 0;
  nof_ies += ue_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += allowed_nssai_present ? 1 : 0;
  nof_ies += srvcc_operation_possible_present ? 1 : 0;
  nof_ies += enhanced_coverage_restrict_present ? 1 : 0;
  nof_ies += extended_connected_time_present ? 1 : 0;
  nof_ies += ue_diff_info_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  nof_ies += ue_cap_info_request_present ? 1 : 0;
  nof_ies += end_ind_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += target_nssai_info_present ? 1 : 0;
  nof_ies += masked_imeisv_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (old_amf_present) {
    HANDLE_CODE(old_amf.pack(bref));
  }
  if (ran_paging_prio_present) {
    HANDLE_CODE(ran_paging_prio.pack(bref));
  }
  HANDLE_CODE(nas_pdu.pack(bref));
  if (mob_restrict_list_present) {
    HANDLE_CODE(mob_restrict_list.pack(bref));
  }
  if (idx_to_rfsp_present) {
    HANDLE_CODE(idx_to_rfsp.pack(bref));
  }
  if (ue_aggr_max_bit_rate_present) {
    HANDLE_CODE(ue_aggr_max_bit_rate.pack(bref));
  }
  if (allowed_nssai_present) {
    HANDLE_CODE(allowed_nssai.pack(bref));
  }
  if (srvcc_operation_possible_present) {
    HANDLE_CODE(srvcc_operation_possible.pack(bref));
  }
  if (enhanced_coverage_restrict_present) {
    HANDLE_CODE(enhanced_coverage_restrict.pack(bref));
  }
  if (extended_connected_time_present) {
    HANDLE_CODE(extended_connected_time.pack(bref));
  }
  if (ue_diff_info_present) {
    HANDLE_CODE(ue_diff_info.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (ue_radio_cap_present) {
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (ue_cap_info_request_present) {
    HANDLE_CODE(ue_cap_info_request.pack(bref));
  }
  if (end_ind_present) {
    HANDLE_CODE(end_ind.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (target_nssai_info_present) {
    HANDLE_CODE(target_nssai_info.pack(bref));
  }
  if (masked_imeisv_present) {
    HANDLE_CODE(masked_imeisv.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_nas_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 48: {
        old_amf_present = true;
        old_amf.id      = id;
        HANDLE_CODE(old_amf.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(old_amf.value.unpack(bref));
        break;
      }
      case 83: {
        ran_paging_prio_present = true;
        ran_paging_prio.id      = id;
        HANDLE_CODE(ran_paging_prio.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_paging_prio.value.unpack(bref));
        break;
      }
      case 38: {
        nof_mandatory_ies--;
        nas_pdu.id = id;
        HANDLE_CODE(nas_pdu.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.value.unpack(bref));
        break;
      }
      case 36: {
        mob_restrict_list_present = true;
        mob_restrict_list.id      = id;
        HANDLE_CODE(mob_restrict_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mob_restrict_list.value.unpack(bref));
        break;
      }
      case 31: {
        idx_to_rfsp_present = true;
        idx_to_rfsp.id      = id;
        HANDLE_CODE(idx_to_rfsp.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(idx_to_rfsp.value.unpack(bref));
        break;
      }
      case 110: {
        ue_aggr_max_bit_rate_present = true;
        ue_aggr_max_bit_rate.id      = id;
        HANDLE_CODE(ue_aggr_max_bit_rate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_aggr_max_bit_rate.value.unpack(bref));
        break;
      }
      case 0: {
        allowed_nssai_present = true;
        allowed_nssai.id      = id;
        HANDLE_CODE(allowed_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(allowed_nssai.value.unpack(bref));
        break;
      }
      case 177: {
        srvcc_operation_possible_present = true;
        srvcc_operation_possible.id      = id;
        HANDLE_CODE(srvcc_operation_possible.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(srvcc_operation_possible.value.unpack(bref));
        break;
      }
      case 205: {
        enhanced_coverage_restrict_present = true;
        enhanced_coverage_restrict.id      = id;
        HANDLE_CODE(enhanced_coverage_restrict.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(enhanced_coverage_restrict.value.unpack(bref));
        break;
      }
      case 206: {
        extended_connected_time_present = true;
        extended_connected_time.id      = id;
        HANDLE_CODE(extended_connected_time.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_connected_time.value.unpack(bref));
        break;
      }
      case 209: {
        ue_diff_info_present = true;
        ue_diff_info.id      = id;
        HANDLE_CODE(ue_diff_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_diff_info.value.unpack(bref));
        break;
      }
      case 222: {
        ce_mode_brestricted_present = true;
        ce_mode_brestricted.id      = id;
        HANDLE_CODE(ce_mode_brestricted.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_brestricted.value.unpack(bref));
        break;
      }
      case 117: {
        ue_radio_cap_present = true;
        ue_radio_cap.id      = id;
        HANDLE_CODE(ue_radio_cap.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.value.unpack(bref));
        break;
      }
      case 228: {
        ue_cap_info_request_present = true;
        ue_cap_info_request.id      = id;
        HANDLE_CODE(ue_cap_info_request.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_cap_info_request.value.unpack(bref));
        break;
      }
      case 226: {
        end_ind_present = true;
        end_ind.id      = id;
        HANDLE_CODE(end_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(end_ind.value.unpack(bref));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        ue_radio_cap_id.id      = id;
        HANDLE_CODE(ue_radio_cap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.value.unpack(bref));
        break;
      }
      case 334: {
        target_nssai_info_present = true;
        target_nssai_info.id      = id;
        HANDLE_CODE(target_nssai_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(target_nssai_info.value.unpack(bref));
        break;
      }
      case 34: {
        masked_imeisv_present = true;
        masked_imeisv.id      = id;
        HANDLE_CODE(masked_imeisv.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(masked_imeisv.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void dl_nas_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (old_amf_present) {
    j.write_fieldname("");
    old_amf.to_json(j);
  }
  if (ran_paging_prio_present) {
    j.write_fieldname("");
    ran_paging_prio.to_json(j);
  }
  j.write_fieldname("");
  nas_pdu.to_json(j);
  if (mob_restrict_list_present) {
    j.write_fieldname("");
    mob_restrict_list.to_json(j);
  }
  if (idx_to_rfsp_present) {
    j.write_fieldname("");
    idx_to_rfsp.to_json(j);
  }
  if (ue_aggr_max_bit_rate_present) {
    j.write_fieldname("");
    ue_aggr_max_bit_rate.to_json(j);
  }
  if (allowed_nssai_present) {
    j.write_fieldname("");
    allowed_nssai.to_json(j);
  }
  if (srvcc_operation_possible_present) {
    j.write_fieldname("");
    srvcc_operation_possible.to_json(j);
  }
  if (enhanced_coverage_restrict_present) {
    j.write_fieldname("");
    enhanced_coverage_restrict.to_json(j);
  }
  if (extended_connected_time_present) {
    j.write_fieldname("");
    extended_connected_time.to_json(j);
  }
  if (ue_diff_info_present) {
    j.write_fieldname("");
    ue_diff_info.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_fieldname("");
    ce_mode_brestricted.to_json(j);
  }
  if (ue_radio_cap_present) {
    j.write_fieldname("");
    ue_radio_cap.to_json(j);
  }
  if (ue_cap_info_request_present) {
    j.write_fieldname("");
    ue_cap_info_request.to_json(j);
  }
  if (end_ind_present) {
    j.write_fieldname("");
    end_ind.to_json(j);
  }
  if (ue_radio_cap_id_present) {
    j.write_fieldname("");
    ue_radio_cap_id.to_json(j);
  }
  if (target_nssai_info_present) {
    j.write_fieldname("");
    target_nssai_info.to_json(j);
  }
  if (masked_imeisv_present) {
    j.write_fieldname("");
    masked_imeisv.to_json(j);
  }
  j.end_obj();
}

// DownlinkNonUEAssociatedNRPPaTransportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_non_ue_associated_nrppa_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {89, 46};
  return map_enum_number(names, 2, idx, "id");
}
bool dl_non_ue_associated_nrppa_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {89, 46};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_non_ue_associated_nrppa_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 89:
      return crit_e::reject;
    case 46:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dl_non_ue_associated_nrppa_transport_ies_o::value_c
dl_non_ue_associated_nrppa_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 89:
      ret.set(value_c::types::routing_id);
      break;
    case 46:
      ret.set(value_c::types::nrppa_pdu);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_non_ue_associated_nrppa_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 89:
      return presence_e::mandatory;
    case 46:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_non_ue_associated_nrppa_transport_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::routing_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::nrppa_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void dl_non_ue_associated_nrppa_transport_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::routing_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nrppa_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
dl_non_ue_associated_nrppa_transport_ies_o::value_c::value_c(
    const dl_non_ue_associated_nrppa_transport_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::routing_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nrppa_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
dl_non_ue_associated_nrppa_transport_ies_o::value_c& dl_non_ue_associated_nrppa_transport_ies_o::value_c::operator=(
    const dl_non_ue_associated_nrppa_transport_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::routing_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nrppa_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ue_associated_nrppa_transport_ies_o::value_c");
  }

  return *this;
}
unbounded_octstring<true>& dl_non_ue_associated_nrppa_transport_ies_o::value_c::routing_id()
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& dl_non_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu()
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& dl_non_ue_associated_nrppa_transport_ies_o::value_c::routing_id() const
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& dl_non_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu() const
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void dl_non_ue_associated_nrppa_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::routing_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::nrppa_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ue_associated_nrppa_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_non_ue_associated_nrppa_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_non_ue_associated_nrppa_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

dl_non_ue_associated_nrppa_transport_ies_container::dl_non_ue_associated_nrppa_transport_ies_container() :
  routing_id(89, crit_e::reject), nrppa_pdu(46, crit_e::reject)
{
}
SRSASN_CODE dl_non_ue_associated_nrppa_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(routing_id.pack(bref));
  HANDLE_CODE(nrppa_pdu.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_non_ue_associated_nrppa_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 89: {
        nof_mandatory_ies--;
        routing_id.id = id;
        HANDLE_CODE(routing_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(routing_id.value.unpack(bref));
        break;
      }
      case 46: {
        nof_mandatory_ies--;
        nrppa_pdu.id = id;
        HANDLE_CODE(nrppa_pdu.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nrppa_pdu.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void dl_non_ue_associated_nrppa_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  routing_id.to_json(j);
  j.write_fieldname("");
  nrppa_pdu.to_json(j);
  j.end_obj();
}

// DownlinkRANConfigurationTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_ran_cfg_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {98, 157, 250};
  return map_enum_number(names, 3, idx, "id");
}
bool dl_ran_cfg_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {98, 157, 250};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_ran_cfg_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 98:
      return crit_e::ignore;
    case 157:
      return crit_e::ignore;
    case 250:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dl_ran_cfg_transfer_ies_o::value_c dl_ran_cfg_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 98:
      ret.set(value_c::types::son_cfg_transfer_dl);
      break;
    case 157:
      ret.set(value_c::types::endc_son_cfg_transfer_dl);
      break;
    case 250:
      ret.set(value_c::types::intersys_son_cfg_transfer_dl);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_ran_cfg_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 98:
      return presence_e::optional;
    case 157:
      return presence_e::optional;
    case 250:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_ran_cfg_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::son_cfg_transfer_dl:
      c.destroy<son_cfg_transfer_s>();
      break;
    case types::endc_son_cfg_transfer_dl:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::intersys_son_cfg_transfer_dl:
      c.destroy<intersys_son_cfg_transfer_s>();
      break;
    default:
      break;
  }
}
void dl_ran_cfg_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::son_cfg_transfer_dl:
      c.init<son_cfg_transfer_s>();
      break;
    case types::endc_son_cfg_transfer_dl:
      c.init<unbounded_octstring<true>>();
      break;
    case types::intersys_son_cfg_transfer_dl:
      c.init<intersys_son_cfg_transfer_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_cfg_transfer_ies_o::value_c");
  }
}
dl_ran_cfg_transfer_ies_o::value_c::value_c(const dl_ran_cfg_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::son_cfg_transfer_dl:
      c.init(other.c.get<son_cfg_transfer_s>());
      break;
    case types::endc_son_cfg_transfer_dl:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::intersys_son_cfg_transfer_dl:
      c.init(other.c.get<intersys_son_cfg_transfer_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_cfg_transfer_ies_o::value_c");
  }
}
dl_ran_cfg_transfer_ies_o::value_c&
dl_ran_cfg_transfer_ies_o::value_c::operator=(const dl_ran_cfg_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::son_cfg_transfer_dl:
      c.set(other.c.get<son_cfg_transfer_s>());
      break;
    case types::endc_son_cfg_transfer_dl:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::intersys_son_cfg_transfer_dl:
      c.set(other.c.get<intersys_son_cfg_transfer_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_cfg_transfer_ies_o::value_c");
  }

  return *this;
}
son_cfg_transfer_s& dl_ran_cfg_transfer_ies_o::value_c::son_cfg_transfer_dl()
{
  assert_choice_type(types::son_cfg_transfer_dl, type_, "Value");
  return c.get<son_cfg_transfer_s>();
}
unbounded_octstring<true>& dl_ran_cfg_transfer_ies_o::value_c::endc_son_cfg_transfer_dl()
{
  assert_choice_type(types::endc_son_cfg_transfer_dl, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
intersys_son_cfg_transfer_s& dl_ran_cfg_transfer_ies_o::value_c::intersys_son_cfg_transfer_dl()
{
  assert_choice_type(types::intersys_son_cfg_transfer_dl, type_, "Value");
  return c.get<intersys_son_cfg_transfer_s>();
}
const son_cfg_transfer_s& dl_ran_cfg_transfer_ies_o::value_c::son_cfg_transfer_dl() const
{
  assert_choice_type(types::son_cfg_transfer_dl, type_, "Value");
  return c.get<son_cfg_transfer_s>();
}
const unbounded_octstring<true>& dl_ran_cfg_transfer_ies_o::value_c::endc_son_cfg_transfer_dl() const
{
  assert_choice_type(types::endc_son_cfg_transfer_dl, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const intersys_son_cfg_transfer_s& dl_ran_cfg_transfer_ies_o::value_c::intersys_son_cfg_transfer_dl() const
{
  assert_choice_type(types::intersys_son_cfg_transfer_dl, type_, "Value");
  return c.get<intersys_son_cfg_transfer_s>();
}
void dl_ran_cfg_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::son_cfg_transfer_dl:
      j.write_fieldname("SONConfigurationTransfer");
      c.get<son_cfg_transfer_s>().to_json(j);
      break;
    case types::endc_son_cfg_transfer_dl:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::intersys_son_cfg_transfer_dl:
      j.write_fieldname("IntersystemSONConfigurationTransfer");
      c.get<intersys_son_cfg_transfer_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_cfg_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_ran_cfg_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::son_cfg_transfer_dl:
      HANDLE_CODE(c.get<son_cfg_transfer_s>().pack(bref));
      break;
    case types::endc_son_cfg_transfer_dl:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::intersys_son_cfg_transfer_dl:
      HANDLE_CODE(c.get<intersys_son_cfg_transfer_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_cfg_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ran_cfg_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::son_cfg_transfer_dl:
      HANDLE_CODE(c.get<son_cfg_transfer_s>().unpack(bref));
      break;
    case types::endc_son_cfg_transfer_dl:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::intersys_son_cfg_transfer_dl:
      HANDLE_CODE(c.get<intersys_son_cfg_transfer_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_cfg_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

dl_ran_cfg_transfer_ies_container::dl_ran_cfg_transfer_ies_container() :
  son_cfg_transfer_dl(98, crit_e::ignore),
  endc_son_cfg_transfer_dl(157, crit_e::ignore),
  intersys_son_cfg_transfer_dl(250, crit_e::ignore)
{
}
SRSASN_CODE dl_ran_cfg_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += son_cfg_transfer_dl_present ? 1 : 0;
  nof_ies += endc_son_cfg_transfer_dl_present ? 1 : 0;
  nof_ies += intersys_son_cfg_transfer_dl_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (son_cfg_transfer_dl_present) {
    HANDLE_CODE(son_cfg_transfer_dl.pack(bref));
  }
  if (endc_son_cfg_transfer_dl_present) {
    HANDLE_CODE(endc_son_cfg_transfer_dl.pack(bref));
  }
  if (intersys_son_cfg_transfer_dl_present) {
    HANDLE_CODE(intersys_son_cfg_transfer_dl.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ran_cfg_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 98: {
        son_cfg_transfer_dl_present = true;
        son_cfg_transfer_dl.id      = id;
        HANDLE_CODE(son_cfg_transfer_dl.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(son_cfg_transfer_dl.value.unpack(bref));
        break;
      }
      case 157: {
        endc_son_cfg_transfer_dl_present = true;
        endc_son_cfg_transfer_dl.id      = id;
        HANDLE_CODE(endc_son_cfg_transfer_dl.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(endc_son_cfg_transfer_dl.value.unpack(bref));
        break;
      }
      case 250: {
        intersys_son_cfg_transfer_dl_present = true;
        intersys_son_cfg_transfer_dl.id      = id;
        HANDLE_CODE(intersys_son_cfg_transfer_dl.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(intersys_son_cfg_transfer_dl.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void dl_ran_cfg_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (son_cfg_transfer_dl_present) {
    j.write_fieldname("");
    son_cfg_transfer_dl.to_json(j);
  }
  if (endc_son_cfg_transfer_dl_present) {
    j.write_fieldname("");
    endc_son_cfg_transfer_dl.to_json(j);
  }
  if (intersys_son_cfg_transfer_dl_present) {
    j.write_fieldname("");
    intersys_son_cfg_transfer_dl.to_json(j);
  }
  j.end_obj();
}

// DownlinkRANEarlyStatusTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_ran_early_status_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 268};
  return map_enum_number(names, 3, idx, "id");
}
bool dl_ran_early_status_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 268};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_ran_early_status_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 268:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dl_ran_early_status_transfer_ies_o::value_c dl_ran_early_status_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 268:
      ret.set(value_c::types::early_status_transfer_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_ran_early_status_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 268:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_ran_early_status_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::early_status_transfer_transparent_container:
      c.destroy<early_status_transfer_transparent_container_s>();
      break;
    default:
      break;
  }
}
void dl_ran_early_status_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::early_status_transfer_transparent_container:
      c.init<early_status_transfer_transparent_container_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_early_status_transfer_ies_o::value_c");
  }
}
dl_ran_early_status_transfer_ies_o::value_c::value_c(const dl_ran_early_status_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::early_status_transfer_transparent_container:
      c.init(other.c.get<early_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_early_status_transfer_ies_o::value_c");
  }
}
dl_ran_early_status_transfer_ies_o::value_c&
dl_ran_early_status_transfer_ies_o::value_c::operator=(const dl_ran_early_status_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::early_status_transfer_transparent_container:
      c.set(other.c.get<early_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_early_status_transfer_ies_o::value_c");
  }

  return *this;
}
uint64_t& dl_ran_early_status_transfer_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& dl_ran_early_status_transfer_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
early_status_transfer_transparent_container_s&
dl_ran_early_status_transfer_ies_o::value_c::early_status_transfer_transparent_container()
{
  assert_choice_type(types::early_status_transfer_transparent_container, type_, "Value");
  return c.get<early_status_transfer_transparent_container_s>();
}
const uint64_t& dl_ran_early_status_transfer_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& dl_ran_early_status_transfer_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const early_status_transfer_transparent_container_s&
dl_ran_early_status_transfer_ies_o::value_c::early_status_transfer_transparent_container() const
{
  assert_choice_type(types::early_status_transfer_transparent_container, type_, "Value");
  return c.get<early_status_transfer_transparent_container_s>();
}
void dl_ran_early_status_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::early_status_transfer_transparent_container:
      j.write_fieldname("EarlyStatusTransfer-TransparentContainer");
      c.get<early_status_transfer_transparent_container_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_early_status_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_ran_early_status_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::early_status_transfer_transparent_container:
      HANDLE_CODE(c.get<early_status_transfer_transparent_container_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_early_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ran_early_status_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::early_status_transfer_transparent_container:
      HANDLE_CODE(c.get<early_status_transfer_transparent_container_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_early_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

dl_ran_early_status_transfer_ies_container::dl_ran_early_status_transfer_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  early_status_transfer_transparent_container(268, crit_e::reject)
{
}
SRSASN_CODE dl_ran_early_status_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(early_status_transfer_transparent_container.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ran_early_status_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 268: {
        nof_mandatory_ies--;
        early_status_transfer_transparent_container.id = id;
        HANDLE_CODE(early_status_transfer_transparent_container.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(early_status_transfer_transparent_container.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void dl_ran_early_status_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  early_status_transfer_transparent_container.to_json(j);
  j.end_obj();
}

// DownlinkRANStatusTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_ran_status_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 84};
  return map_enum_number(names, 3, idx, "id");
}
bool dl_ran_status_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 84};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_ran_status_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 84:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dl_ran_status_transfer_ies_o::value_c dl_ran_status_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 84:
      ret.set(value_c::types::ran_status_transfer_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_ran_status_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 84:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_ran_status_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ran_status_transfer_transparent_container:
      c.destroy<ran_status_transfer_transparent_container_s>();
      break;
    default:
      break;
  }
}
void dl_ran_status_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ran_status_transfer_transparent_container:
      c.init<ran_status_transfer_transparent_container_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_status_transfer_ies_o::value_c");
  }
}
dl_ran_status_transfer_ies_o::value_c::value_c(const dl_ran_status_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_status_transfer_transparent_container:
      c.init(other.c.get<ran_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_status_transfer_ies_o::value_c");
  }
}
dl_ran_status_transfer_ies_o::value_c&
dl_ran_status_transfer_ies_o::value_c::operator=(const dl_ran_status_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_status_transfer_transparent_container:
      c.set(other.c.get<ran_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_status_transfer_ies_o::value_c");
  }

  return *this;
}
uint64_t& dl_ran_status_transfer_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& dl_ran_status_transfer_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
ran_status_transfer_transparent_container_s&
dl_ran_status_transfer_ies_o::value_c::ran_status_transfer_transparent_container()
{
  assert_choice_type(types::ran_status_transfer_transparent_container, type_, "Value");
  return c.get<ran_status_transfer_transparent_container_s>();
}
const uint64_t& dl_ran_status_transfer_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& dl_ran_status_transfer_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const ran_status_transfer_transparent_container_s&
dl_ran_status_transfer_ies_o::value_c::ran_status_transfer_transparent_container() const
{
  assert_choice_type(types::ran_status_transfer_transparent_container, type_, "Value");
  return c.get<ran_status_transfer_transparent_container_s>();
}
void dl_ran_status_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ran_status_transfer_transparent_container:
      j.write_fieldname("RANStatusTransfer-TransparentContainer");
      c.get<ran_status_transfer_transparent_container_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_status_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_ran_status_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_status_transfer_transparent_container:
      HANDLE_CODE(c.get<ran_status_transfer_transparent_container_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ran_status_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_status_transfer_transparent_container:
      HANDLE_CODE(c.get<ran_status_transfer_transparent_container_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

dl_ran_status_transfer_ies_container::dl_ran_status_transfer_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  ran_status_transfer_transparent_container(84, crit_e::reject)
{
}
SRSASN_CODE dl_ran_status_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_status_transfer_transparent_container.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ran_status_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 84: {
        nof_mandatory_ies--;
        ran_status_transfer_transparent_container.id = id;
        HANDLE_CODE(ran_status_transfer_transparent_container.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_status_transfer_transparent_container.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void dl_ran_status_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_status_transfer_transparent_container.to_json(j);
  j.end_obj();
}

// DownlinkRIMInformationTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_rim_info_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {175};
  return map_enum_number(names, 1, idx, "id");
}
bool dl_rim_info_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  return 175 == id;
}
crit_e dl_rim_info_transfer_ies_o::get_crit(const uint32_t& id)
{
  if (id == 175) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
dl_rim_info_transfer_ies_o::value_c dl_rim_info_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 175) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_rim_info_transfer_ies_o::get_presence(const uint32_t& id)
{
  if (id == 175) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void dl_rim_info_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("RIMInformationTransfer");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE dl_rim_info_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_rim_info_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// DownlinkUEAssociatedNRPPaTransportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_ue_associated_nrppa_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 89, 46};
  return map_enum_number(names, 4, idx, "id");
}
bool dl_ue_associated_nrppa_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 89, 46};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_ue_associated_nrppa_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 89:
      return crit_e::reject;
    case 46:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dl_ue_associated_nrppa_transport_ies_o::value_c dl_ue_associated_nrppa_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 89:
      ret.set(value_c::types::routing_id);
      break;
    case 46:
      ret.set(value_c::types::nrppa_pdu);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_ue_associated_nrppa_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 89:
      return presence_e::mandatory;
    case 46:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_ue_associated_nrppa_transport_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::routing_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::nrppa_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void dl_ue_associated_nrppa_transport_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::routing_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nrppa_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
dl_ue_associated_nrppa_transport_ies_o::value_c::value_c(const dl_ue_associated_nrppa_transport_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::routing_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nrppa_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
dl_ue_associated_nrppa_transport_ies_o::value_c&
dl_ue_associated_nrppa_transport_ies_o::value_c::operator=(const dl_ue_associated_nrppa_transport_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::routing_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nrppa_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ue_associated_nrppa_transport_ies_o::value_c");
  }

  return *this;
}
uint64_t& dl_ue_associated_nrppa_transport_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& dl_ue_associated_nrppa_transport_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& dl_ue_associated_nrppa_transport_ies_o::value_c::routing_id()
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& dl_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu()
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& dl_ue_associated_nrppa_transport_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& dl_ue_associated_nrppa_transport_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& dl_ue_associated_nrppa_transport_ies_o::value_c::routing_id() const
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& dl_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu() const
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void dl_ue_associated_nrppa_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::routing_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::nrppa_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "dl_ue_associated_nrppa_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_ue_associated_nrppa_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ue_associated_nrppa_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

dl_ue_associated_nrppa_transport_ies_container::dl_ue_associated_nrppa_transport_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  routing_id(89, crit_e::reject),
  nrppa_pdu(46, crit_e::reject)
{
}
SRSASN_CODE dl_ue_associated_nrppa_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(routing_id.pack(bref));
  HANDLE_CODE(nrppa_pdu.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ue_associated_nrppa_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 89: {
        nof_mandatory_ies--;
        routing_id.id = id;
        HANDLE_CODE(routing_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(routing_id.value.unpack(bref));
        break;
      }
      case 46: {
        nof_mandatory_ies--;
        nrppa_pdu.id = id;
        HANDLE_CODE(nrppa_pdu.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nrppa_pdu.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void dl_ue_associated_nrppa_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  routing_id.to_json(j);
  j.write_fieldname("");
  nrppa_pdu.to_json(j);
  j.end_obj();
}

// ErrorIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t error_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15, 19, 26};
  return map_enum_number(names, 5, idx, "id");
}
bool error_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15, 19, 26};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e error_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    case 26:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
error_ind_ies_o::value_c error_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 26:
      ret.set(value_c::types::five_g_s_tmsi);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e error_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::optional;
    case 85:
      return presence_e::optional;
    case 15:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    case 26:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void error_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::five_g_s_tmsi:
      c.destroy<five_g_s_tmsi_s>();
      break;
    default:
      break;
  }
}
void error_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::five_g_s_tmsi:
      c.init<five_g_s_tmsi_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
  }
}
error_ind_ies_o::value_c::value_c(const error_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::five_g_s_tmsi:
      c.init(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
  }
}
error_ind_ies_o::value_c& error_ind_ies_o::value_c::operator=(const error_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::five_g_s_tmsi:
      c.set(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& error_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& error_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& error_ind_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& error_ind_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
five_g_s_tmsi_s& error_ind_ies_o::value_c::five_g_s_tmsi()
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
const uint64_t& error_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& error_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& error_ind_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& error_ind_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const five_g_s_tmsi_s& error_ind_ies_o::value_c::five_g_s_tmsi() const
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
void error_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::five_g_s_tmsi:
      j.write_fieldname("FiveG-S-TMSI");
      c.get<five_g_s_tmsi_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE error_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE error_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

error_ind_ies_container::error_ind_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  cause(15, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore),
  five_g_s_tmsi(26, crit_e::ignore)
{
}
SRSASN_CODE error_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += amf_ue_ngap_id_present ? 1 : 0;
  nof_ies += ran_ue_ngap_id_present ? 1 : 0;
  nof_ies += cause_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += five_g_s_tmsi_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (amf_ue_ngap_id_present) {
    HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  }
  if (ran_ue_ngap_id_present) {
    HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  }
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (five_g_s_tmsi_present) {
    HANDLE_CODE(five_g_s_tmsi.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE error_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        amf_ue_ngap_id_present = true;
        amf_ue_ngap_id.id      = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        ran_ue_ngap_id_present = true;
        ran_ue_ngap_id.id      = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 15: {
        cause_present = true;
        cause.id      = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      case 26: {
        five_g_s_tmsi_present = true;
        five_g_s_tmsi.id      = id;
        HANDLE_CODE(five_g_s_tmsi.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_s_tmsi.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void error_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (amf_ue_ngap_id_present) {
    j.write_fieldname("");
    amf_ue_ngap_id.to_json(j);
  }
  if (ran_ue_ngap_id_present) {
    j.write_fieldname("");
    ran_ue_ngap_id.to_json(j);
  }
  if (cause_present) {
    j.write_fieldname("");
    cause.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (five_g_s_tmsi_present) {
    j.write_fieldname("");
    five_g_s_tmsi.to_json(j);
  }
  j.end_obj();
}

// HandoverCancelIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_cancel_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15};
  return map_enum_number(names, 3, idx, "id");
}
bool ho_cancel_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_cancel_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_cancel_ies_o::value_c ho_cancel_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_cancel_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_cancel_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void ho_cancel_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
  }
}
ho_cancel_ies_o::value_c::value_c(const ho_cancel_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
  }
}
ho_cancel_ies_o::value_c& ho_cancel_ies_o::value_c::operator=(const ho_cancel_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_cancel_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_cancel_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ho_cancel_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const uint64_t& ho_cancel_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_cancel_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ho_cancel_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void ho_cancel_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_cancel_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cancel_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

ho_cancel_ies_container::ho_cancel_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject), ran_ue_ngap_id(85, crit_e::reject), cause(15, crit_e::ignore)
{
}
SRSASN_CODE ho_cancel_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cancel_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_cancel_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.end_obj();
}

// HandoverCancelAcknowledgeIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_cancel_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool ho_cancel_ack_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_cancel_ack_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_cancel_ack_ies_o::value_c ho_cancel_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_cancel_ack_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_cancel_ack_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ho_cancel_ack_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
  }
}
ho_cancel_ack_ies_o::value_c::value_c(const ho_cancel_ack_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
  }
}
ho_cancel_ack_ies_o::value_c& ho_cancel_ack_ies_o::value_c::operator=(const ho_cancel_ack_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_cancel_ack_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_cancel_ack_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
crit_diagnostics_s& ho_cancel_ack_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ho_cancel_ack_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_cancel_ack_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const crit_diagnostics_s& ho_cancel_ack_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ho_cancel_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_cancel_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cancel_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

ho_cancel_ack_ies_container::ho_cancel_ack_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore), ran_ue_ngap_id(85, crit_e::ignore), crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ho_cancel_ack_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cancel_ack_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_cancel_ack_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// HandoverCommandIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_cmd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 29, 39, 59, 78, 106, 19};
  return map_enum_number(names, 8, idx, "id");
}
bool ho_cmd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 29, 39, 59, 78, 106, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_cmd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 29:
      return crit_e::reject;
    case 39:
      return crit_e::reject;
    case 59:
      return crit_e::ignore;
    case 78:
      return crit_e::ignore;
    case 106:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_cmd_ies_o::value_c ho_cmd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 29:
      ret.set(value_c::types::handov_type);
      break;
    case 39:
      ret.set(value_c::types::nas_security_params_from_ngran);
      break;
    case 59:
      ret.set(value_c::types::pdu_session_res_ho_list);
      break;
    case 78:
      ret.set(value_c::types::pdu_session_res_to_release_list_ho_cmd);
      break;
    case 106:
      ret.set(value_c::types::target_to_source_transparent_container);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_cmd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 29:
      return presence_e::mandatory;
    case 39:
      return presence_e::conditional;
    case 59:
      return presence_e::optional;
    case 78:
      return presence_e::optional;
    case 106:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_cmd_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::nas_security_params_from_ngran:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::pdu_session_res_ho_list:
      c.destroy<pdu_session_res_ho_list_l>();
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      c.destroy<pdu_session_res_to_release_list_ho_cmd_l>();
      break;
    case types::target_to_source_transparent_container:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ho_cmd_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::handov_type:
      break;
    case types::nas_security_params_from_ngran:
      c.init<unbounded_octstring<true>>();
      break;
    case types::pdu_session_res_ho_list:
      c.init<pdu_session_res_ho_list_l>();
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      c.init<pdu_session_res_to_release_list_ho_cmd_l>();
      break;
    case types::target_to_source_transparent_container:
      c.init<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
  }
}
ho_cmd_ies_o::value_c::value_c(const ho_cmd_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::handov_type:
      c.init(other.c.get<handov_type_e>());
      break;
    case types::nas_security_params_from_ngran:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdu_session_res_ho_list:
      c.init(other.c.get<pdu_session_res_ho_list_l>());
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      c.init(other.c.get<pdu_session_res_to_release_list_ho_cmd_l>());
      break;
    case types::target_to_source_transparent_container:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
  }
}
ho_cmd_ies_o::value_c& ho_cmd_ies_o::value_c::operator=(const ho_cmd_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::handov_type:
      c.set(other.c.get<handov_type_e>());
      break;
    case types::nas_security_params_from_ngran:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdu_session_res_ho_list:
      c.set(other.c.get<pdu_session_res_ho_list_l>());
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      c.set(other.c.get<pdu_session_res_to_release_list_ho_cmd_l>());
      break;
    case types::target_to_source_transparent_container:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_cmd_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_cmd_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
handov_type_e& ho_cmd_ies_o::value_c::handov_type()
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
unbounded_octstring<true>& ho_cmd_ies_o::value_c::nas_security_params_from_ngran()
{
  assert_choice_type(types::nas_security_params_from_ngran, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
pdu_session_res_ho_list_l& ho_cmd_ies_o::value_c::pdu_session_res_ho_list()
{
  assert_choice_type(types::pdu_session_res_ho_list, type_, "Value");
  return c.get<pdu_session_res_ho_list_l>();
}
pdu_session_res_to_release_list_ho_cmd_l& ho_cmd_ies_o::value_c::pdu_session_res_to_release_list_ho_cmd()
{
  assert_choice_type(types::pdu_session_res_to_release_list_ho_cmd, type_, "Value");
  return c.get<pdu_session_res_to_release_list_ho_cmd_l>();
}
unbounded_octstring<true>& ho_cmd_ies_o::value_c::target_to_source_transparent_container()
{
  assert_choice_type(types::target_to_source_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& ho_cmd_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ho_cmd_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_cmd_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const handov_type_e& ho_cmd_ies_o::value_c::handov_type() const
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
const unbounded_octstring<true>& ho_cmd_ies_o::value_c::nas_security_params_from_ngran() const
{
  assert_choice_type(types::nas_security_params_from_ngran, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const pdu_session_res_ho_list_l& ho_cmd_ies_o::value_c::pdu_session_res_ho_list() const
{
  assert_choice_type(types::pdu_session_res_ho_list, type_, "Value");
  return c.get<pdu_session_res_ho_list_l>();
}
const pdu_session_res_to_release_list_ho_cmd_l& ho_cmd_ies_o::value_c::pdu_session_res_to_release_list_ho_cmd() const
{
  assert_choice_type(types::pdu_session_res_to_release_list_ho_cmd, type_, "Value");
  return c.get<pdu_session_res_to_release_list_ho_cmd_l>();
}
const unbounded_octstring<true>& ho_cmd_ies_o::value_c::target_to_source_transparent_container() const
{
  assert_choice_type(types::target_to_source_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& ho_cmd_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ho_cmd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::handov_type:
      j.write_str("HandoverType", c.get<handov_type_e>().to_string());
      break;
    case types::nas_security_params_from_ngran:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::pdu_session_res_ho_list:
      j.start_array("PDUSessionResourceHandoverList");
      for (const auto& e1 : c.get<pdu_session_res_ho_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      j.start_array("PDUSessionResourceToReleaseListHOCmd");
      for (const auto& e1 : c.get<pdu_session_res_to_release_list_ho_cmd_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::target_to_source_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_cmd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().pack(bref));
      break;
    case types::nas_security_params_from_ngran:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::pdu_session_res_ho_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_ho_list_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_to_release_list_ho_cmd_l>(), 1, 256, true));
      break;
    case types::target_to_source_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cmd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().unpack(bref));
      break;
    case types::nas_security_params_from_ngran:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::pdu_session_res_ho_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_ho_list_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_to_release_list_ho_cmd_l>(), bref, 1, 256, true));
      break;
    case types::target_to_source_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

ho_cmd_ies_container::ho_cmd_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  handov_type(29, crit_e::reject),
  nas_security_params_from_ngran(39, crit_e::reject),
  pdu_session_res_ho_list(59, crit_e::ignore),
  pdu_session_res_to_release_list_ho_cmd(78, crit_e::ignore),
  target_to_source_transparent_container(106, crit_e::reject),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ho_cmd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += nas_security_params_from_ngran_present ? 1 : 0;
  nof_ies += pdu_session_res_ho_list_present ? 1 : 0;
  nof_ies += pdu_session_res_to_release_list_ho_cmd_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(handov_type.pack(bref));
  if (nas_security_params_from_ngran_present) {
    HANDLE_CODE(nas_security_params_from_ngran.pack(bref));
  }
  if (pdu_session_res_ho_list_present) {
    HANDLE_CODE(pdu_session_res_ho_list.pack(bref));
  }
  if (pdu_session_res_to_release_list_ho_cmd_present) {
    HANDLE_CODE(pdu_session_res_to_release_list_ho_cmd.pack(bref));
  }
  HANDLE_CODE(target_to_source_transparent_container.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cmd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 29: {
        nof_mandatory_ies--;
        handov_type.id = id;
        HANDLE_CODE(handov_type.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(handov_type.value.unpack(bref));
        break;
      }
      case 39: {
        nas_security_params_from_ngran_present = true;
        nas_security_params_from_ngran.id      = id;
        HANDLE_CODE(nas_security_params_from_ngran.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_security_params_from_ngran.value.unpack(bref));
        break;
      }
      case 59: {
        pdu_session_res_ho_list_present = true;
        pdu_session_res_ho_list.id      = id;
        HANDLE_CODE(pdu_session_res_ho_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_ho_list.value.unpack(bref));
        break;
      }
      case 78: {
        pdu_session_res_to_release_list_ho_cmd_present = true;
        pdu_session_res_to_release_list_ho_cmd.id      = id;
        HANDLE_CODE(pdu_session_res_to_release_list_ho_cmd.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_to_release_list_ho_cmd.value.unpack(bref));
        break;
      }
      case 106: {
        nof_mandatory_ies--;
        target_to_source_transparent_container.id = id;
        HANDLE_CODE(target_to_source_transparent_container.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(target_to_source_transparent_container.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_cmd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  handov_type.to_json(j);
  if (nas_security_params_from_ngran_present) {
    j.write_fieldname("");
    nas_security_params_from_ngran.to_json(j);
  }
  if (pdu_session_res_ho_list_present) {
    j.write_fieldname("");
    pdu_session_res_ho_list.to_json(j);
  }
  if (pdu_session_res_to_release_list_ho_cmd_present) {
    j.write_fieldname("");
    pdu_session_res_to_release_list_ho_cmd.to_json(j);
  }
  j.write_fieldname("");
  target_to_source_transparent_container.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// HandoverFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 15, 19, 262};
  return map_enum_number(names, 4, idx, "id");
}
bool ho_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 15, 19, 262};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    case 262:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_fail_ies_o::value_c ho_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 262:
      ret.set(value_c::types::targetto_source_fail_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    case 262:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::targetto_source_fail_transparent_container:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void ho_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::targetto_source_fail_transparent_container:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
  }
}
ho_fail_ies_o::value_c::value_c(const ho_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::targetto_source_fail_transparent_container:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
  }
}
ho_fail_ies_o::value_c& ho_fail_ies_o::value_c::operator=(const ho_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::targetto_source_fail_transparent_container:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ho_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& ho_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
unbounded_octstring<true>& ho_fail_ies_o::value_c::targetto_source_fail_transparent_container()
{
  assert_choice_type(types::targetto_source_fail_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ho_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ho_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& ho_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const unbounded_octstring<true>& ho_fail_ies_o::value_c::targetto_source_fail_transparent_container() const
{
  assert_choice_type(types::targetto_source_fail_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ho_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::targetto_source_fail_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::targetto_source_fail_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::targetto_source_fail_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

ho_fail_ies_container::ho_fail_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  cause(15, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore),
  targetto_source_fail_transparent_container(262, crit_e::ignore)
{
}
SRSASN_CODE ho_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += targetto_source_fail_transparent_container_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (targetto_source_fail_transparent_container_present) {
    HANDLE_CODE(targetto_source_fail_transparent_container.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      case 262: {
        targetto_source_fail_transparent_container_present = true;
        targetto_source_fail_transparent_container.id      = id;
        HANDLE_CODE(targetto_source_fail_transparent_container.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(targetto_source_fail_transparent_container.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (targetto_source_fail_transparent_container_present) {
    j.write_fieldname("");
    targetto_source_fail_transparent_container.to_json(j);
  }
  j.end_obj();
}

// HandoverNotifyIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_notify_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 121, 269};
  return map_enum_number(names, 4, idx, "id");
}
bool ho_notify_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 121, 269};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_notify_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 121:
      return crit_e::ignore;
    case 269:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_notify_ies_o::value_c ho_notify_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 269:
      ret.set(value_c::types::notify_source_ngran_node);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_notify_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 121:
      return presence_e::mandatory;
    case 269:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_notify_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    default:
      break;
  }
}
void ho_notify_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::notify_source_ngran_node:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
  }
}
ho_notify_ies_o::value_c::value_c(const ho_notify_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::notify_source_ngran_node:
      c.init(other.c.get<notify_source_ngran_node_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
  }
}
ho_notify_ies_o::value_c& ho_notify_ies_o::value_c::operator=(const ho_notify_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::notify_source_ngran_node:
      c.set(other.c.get<notify_source_ngran_node_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_notify_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_notify_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
user_location_info_c& ho_notify_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
notify_source_ngran_node_e& ho_notify_ies_o::value_c::notify_source_ngran_node()
{
  assert_choice_type(types::notify_source_ngran_node, type_, "Value");
  return c.get<notify_source_ngran_node_e>();
}
const uint64_t& ho_notify_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_notify_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const user_location_info_c& ho_notify_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const notify_source_ngran_node_e& ho_notify_ies_o::value_c::notify_source_ngran_node() const
{
  assert_choice_type(types::notify_source_ngran_node, type_, "Value");
  return c.get<notify_source_ngran_node_e>();
}
void ho_notify_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::notify_source_ngran_node:
      j.write_str("NotifySourceNGRANNode", "notifySource");
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_notify_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::notify_source_ngran_node:
      HANDLE_CODE(c.get<notify_source_ngran_node_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_notify_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::notify_source_ngran_node:
      HANDLE_CODE(c.get<notify_source_ngran_node_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

ho_notify_ies_container::ho_notify_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  user_location_info(121, crit_e::ignore),
  notify_source_ngran_node(269, crit_e::ignore)
{
}
SRSASN_CODE ho_notify_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += notify_source_ngran_node_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(user_location_info.pack(bref));
  if (notify_source_ngran_node_present) {
    HANDLE_CODE(notify_source_ngran_node.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_notify_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 121: {
        nof_mandatory_ies--;
        user_location_info.id = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      case 269: {
        notify_source_ngran_node_present = true;
        notify_source_ngran_node.id      = id;
        HANDLE_CODE(notify_source_ngran_node.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(notify_source_ngran_node.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_notify_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  user_location_info.to_json(j);
  if (notify_source_ngran_node_present) {
    j.write_fieldname("");
    notify_source_ngran_node.to_json(j);
  }
  j.end_obj();
}

// HandoverPreparationFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_prep_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15, 19, 262};
  return map_enum_number(names, 5, idx, "id");
}
bool ho_prep_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15, 19, 262};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_prep_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    case 262:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_prep_fail_ies_o::value_c ho_prep_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 262:
      ret.set(value_c::types::targetto_source_fail_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_prep_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    case 262:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_prep_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::targetto_source_fail_transparent_container:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void ho_prep_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::targetto_source_fail_transparent_container:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
  }
}
ho_prep_fail_ies_o::value_c::value_c(const ho_prep_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::targetto_source_fail_transparent_container:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
  }
}
ho_prep_fail_ies_o::value_c& ho_prep_fail_ies_o::value_c::operator=(const ho_prep_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::targetto_source_fail_transparent_container:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_prep_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_prep_fail_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ho_prep_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& ho_prep_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
unbounded_octstring<true>& ho_prep_fail_ies_o::value_c::targetto_source_fail_transparent_container()
{
  assert_choice_type(types::targetto_source_fail_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ho_prep_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_prep_fail_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ho_prep_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& ho_prep_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const unbounded_octstring<true>& ho_prep_fail_ies_o::value_c::targetto_source_fail_transparent_container() const
{
  assert_choice_type(types::targetto_source_fail_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ho_prep_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::targetto_source_fail_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_prep_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::targetto_source_fail_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_prep_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::targetto_source_fail_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

ho_prep_fail_ies_container::ho_prep_fail_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  cause(15, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore),
  targetto_source_fail_transparent_container(262, crit_e::ignore)
{
}
SRSASN_CODE ho_prep_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += targetto_source_fail_transparent_container_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (targetto_source_fail_transparent_container_present) {
    HANDLE_CODE(targetto_source_fail_transparent_container.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_prep_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      case 262: {
        targetto_source_fail_transparent_container_present = true;
        targetto_source_fail_transparent_container.id      = id;
        HANDLE_CODE(targetto_source_fail_transparent_container.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(targetto_source_fail_transparent_container.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_prep_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (targetto_source_fail_transparent_container_present) {
    j.write_fieldname("");
    targetto_source_fail_transparent_container.to_json(j);
  }
  j.end_obj();
}

// HandoverRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10,  29,  15,  110, 18,  119, 93,  41,  37,  73,  0,   108, 34,
                                   101, 36,  33,  91,  28,  146, 165, 177, 199, 205, 209, 216, 215,
                                   218, 217, 219, 222, 234, 254, 264, 206, 326, 335, 345, 346, 347};
  return map_enum_number(names, 39, idx, "id");
}
bool ho_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10,  29,  15,  110, 18,  119, 93,  41,  37,  73,  0,   108, 34,
                                   101, 36,  33,  91,  28,  146, 165, 177, 199, 205, 209, 216, 215,
                                   218, 217, 219, 222, 234, 254, 264, 206, 326, 335, 345, 346, 347};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 29:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    case 110:
      return crit_e::reject;
    case 18:
      return crit_e::ignore;
    case 119:
      return crit_e::reject;
    case 93:
      return crit_e::reject;
    case 41:
      return crit_e::reject;
    case 37:
      return crit_e::reject;
    case 73:
      return crit_e::reject;
    case 0:
      return crit_e::reject;
    case 108:
      return crit_e::ignore;
    case 34:
      return crit_e::ignore;
    case 101:
      return crit_e::reject;
    case 36:
      return crit_e::ignore;
    case 33:
      return crit_e::ignore;
    case 91:
      return crit_e::ignore;
    case 28:
      return crit_e::reject;
    case 146:
      return crit_e::ignore;
    case 165:
      return crit_e::ignore;
    case 177:
      return crit_e::ignore;
    case 199:
      return crit_e::reject;
    case 205:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 216:
      return crit_e::ignore;
    case 215:
      return crit_e::ignore;
    case 218:
      return crit_e::ignore;
    case 217:
      return crit_e::ignore;
    case 219:
      return crit_e::ignore;
    case 222:
      return crit_e::ignore;
    case 234:
      return crit_e::ignore;
    case 254:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    case 206:
      return crit_e::ignore;
    case 326:
      return crit_e::ignore;
    case 335:
      return crit_e::ignore;
    case 345:
      return crit_e::ignore;
    case 346:
      return crit_e::ignore;
    case 347:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_request_ies_o::value_c ho_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 29:
      ret.set(value_c::types::handov_type);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 110:
      ret.set(value_c::types::ue_aggr_max_bit_rate);
      break;
    case 18:
      ret.set(value_c::types::core_network_assist_info_for_inactive);
      break;
    case 119:
      ret.set(value_c::types::ue_security_cap);
      break;
    case 93:
      ret.set(value_c::types::security_context);
      break;
    case 41:
      ret.set(value_c::types::new_security_context_ind);
      break;
    case 37:
      ret.set(value_c::types::nasc);
      break;
    case 73:
      ret.set(value_c::types::pdu_session_res_setup_list_ho_req);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 108:
      ret.set(value_c::types::trace_activation);
      break;
    case 34:
      ret.set(value_c::types::masked_imeisv);
      break;
    case 101:
      ret.set(value_c::types::source_to_target_transparent_container);
      break;
    case 36:
      ret.set(value_c::types::mob_restrict_list);
      break;
    case 33:
      ret.set(value_c::types::location_report_request_type);
      break;
    case 91:
      ret.set(value_c::types::rrc_inactive_transition_report_request);
      break;
    case 28:
      ret.set(value_c::types::guami);
      break;
    case 146:
      ret.set(value_c::types::redirection_voice_fallback);
      break;
    case 165:
      ret.set(value_c::types::cn_assisted_ran_tuning);
      break;
    case 177:
      ret.set(value_c::types::srvcc_operation_possible);
      break;
    case 199:
      ret.set(value_c::types::iab_authorized);
      break;
    case 205:
      ret.set(value_c::types::enhanced_coverage_restrict);
      break;
    case 209:
      ret.set(value_c::types::ue_diff_info);
      break;
    case 216:
      ret.set(value_c::types::nr_v2x_services_authorized);
      break;
    case 215:
      ret.set(value_c::types::ltev2x_services_authorized);
      break;
    case 218:
      ret.set(value_c::types::nr_ue_sidelink_aggr_max_bitrate);
      break;
    case 217:
      ret.set(value_c::types::lte_ue_sidelink_aggr_max_bitrate);
      break;
    case 219:
      ret.set(value_c::types::pc5_qos_params);
      break;
    case 222:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 234:
      ret.set(value_c::types::ue_up_c_iot_support);
      break;
    case 254:
      ret.set(value_c::types::management_based_mdt_plmn_list);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 206:
      ret.set(value_c::types::extended_connected_time);
      break;
    case 326:
      ret.set(value_c::types::time_sync_assist_info);
      break;
    case 335:
      ret.set(value_c::types::ue_slice_max_bit_rate_list);
      break;
    case 345:
      ret.set(value_c::types::five_g_pro_se_authorized);
      break;
    case 346:
      ret.set(value_c::types::five_g_pro_se_ue_pc5_aggr_max_bit_rate);
      break;
    case 347:
      ret.set(value_c::types::five_g_pro_se_pc5_qos_params);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 29:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 110:
      return presence_e::mandatory;
    case 18:
      return presence_e::optional;
    case 119:
      return presence_e::mandatory;
    case 93:
      return presence_e::mandatory;
    case 41:
      return presence_e::optional;
    case 37:
      return presence_e::optional;
    case 73:
      return presence_e::mandatory;
    case 0:
      return presence_e::mandatory;
    case 108:
      return presence_e::optional;
    case 34:
      return presence_e::optional;
    case 101:
      return presence_e::mandatory;
    case 36:
      return presence_e::optional;
    case 33:
      return presence_e::optional;
    case 91:
      return presence_e::optional;
    case 28:
      return presence_e::mandatory;
    case 146:
      return presence_e::optional;
    case 165:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 199:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 216:
      return presence_e::optional;
    case 215:
      return presence_e::optional;
    case 218:
      return presence_e::optional;
    case 217:
      return presence_e::optional;
    case 219:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    case 234:
      return presence_e::optional;
    case 254:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 206:
      return presence_e::optional;
    case 326:
      return presence_e::optional;
    case 335:
      return presence_e::optional;
    case 345:
      return presence_e::optional;
    case 346:
      return presence_e::optional;
    case 347:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::ue_aggr_max_bit_rate:
      c.destroy<ue_aggr_max_bit_rate_s>();
      break;
    case types::core_network_assist_info_for_inactive:
      c.destroy<core_network_assist_info_for_inactive_s>();
      break;
    case types::ue_security_cap:
      c.destroy<ue_security_cap_s>();
      break;
    case types::security_context:
      c.destroy<security_context_s>();
      break;
    case types::nasc:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::pdu_session_res_setup_list_ho_req:
      c.destroy<pdu_session_res_setup_list_ho_req_l>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    case types::trace_activation:
      c.destroy<trace_activation_s>();
      break;
    case types::masked_imeisv:
      c.destroy<fixed_bitstring<64, false, true>>();
      break;
    case types::source_to_target_transparent_container:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::mob_restrict_list:
      c.destroy<mob_restrict_list_s>();
      break;
    case types::location_report_request_type:
      c.destroy<location_report_request_type_s>();
      break;
    case types::guami:
      c.destroy<guami_s>();
      break;
    case types::cn_assisted_ran_tuning:
      c.destroy<cn_assisted_ran_tuning_s>();
      break;
    case types::ue_diff_info:
      c.destroy<ue_diff_info_s>();
      break;
    case types::nr_v2x_services_authorized:
      c.destroy<nr_v2x_services_authorized_s>();
      break;
    case types::ltev2x_services_authorized:
      c.destroy<ltev2x_services_authorized_s>();
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.destroy<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.destroy<lte_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::pc5_qos_params:
      c.destroy<pc5_qos_params_s>();
      break;
    case types::management_based_mdt_plmn_list:
      c.destroy<mdt_plmn_list_l>();
      break;
    case types::ue_radio_cap_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::time_sync_assist_info:
      c.destroy<time_sync_assist_info_s>();
      break;
    case types::ue_slice_max_bit_rate_list:
      c.destroy<ue_slice_max_bit_rate_list_l>();
      break;
    case types::five_g_pro_se_authorized:
      c.destroy<five_g_pro_se_authorized_s>();
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.destroy<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.destroy<five_g_pro_se_pc5_qos_params_s>();
      break;
    default:
      break;
  }
}
void ho_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::handov_type:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::ue_aggr_max_bit_rate:
      c.init<ue_aggr_max_bit_rate_s>();
      break;
    case types::core_network_assist_info_for_inactive:
      c.init<core_network_assist_info_for_inactive_s>();
      break;
    case types::ue_security_cap:
      c.init<ue_security_cap_s>();
      break;
    case types::security_context:
      c.init<security_context_s>();
      break;
    case types::new_security_context_ind:
      break;
    case types::nasc:
      c.init<unbounded_octstring<true>>();
      break;
    case types::pdu_session_res_setup_list_ho_req:
      c.init<pdu_session_res_setup_list_ho_req_l>();
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::trace_activation:
      c.init<trace_activation_s>();
      break;
    case types::masked_imeisv:
      c.init<fixed_bitstring<64, false, true>>();
      break;
    case types::source_to_target_transparent_container:
      c.init<unbounded_octstring<true>>();
      break;
    case types::mob_restrict_list:
      c.init<mob_restrict_list_s>();
      break;
    case types::location_report_request_type:
      c.init<location_report_request_type_s>();
      break;
    case types::rrc_inactive_transition_report_request:
      break;
    case types::guami:
      c.init<guami_s>();
      break;
    case types::redirection_voice_fallback:
      break;
    case types::cn_assisted_ran_tuning:
      c.init<cn_assisted_ran_tuning_s>();
      break;
    case types::srvcc_operation_possible:
      break;
    case types::iab_authorized:
      break;
    case types::enhanced_coverage_restrict:
      break;
    case types::ue_diff_info:
      c.init<ue_diff_info_s>();
      break;
    case types::nr_v2x_services_authorized:
      c.init<nr_v2x_services_authorized_s>();
      break;
    case types::ltev2x_services_authorized:
      c.init<ltev2x_services_authorized_s>();
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.init<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.init<lte_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::pc5_qos_params:
      c.init<pc5_qos_params_s>();
      break;
    case types::ce_mode_brestricted:
      break;
    case types::ue_up_c_iot_support:
      break;
    case types::management_based_mdt_plmn_list:
      c.init<mdt_plmn_list_l>();
      break;
    case types::ue_radio_cap_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::extended_connected_time:
      break;
    case types::time_sync_assist_info:
      c.init<time_sync_assist_info_s>();
      break;
    case types::ue_slice_max_bit_rate_list:
      c.init<ue_slice_max_bit_rate_list_l>();
      break;
    case types::five_g_pro_se_authorized:
      c.init<five_g_pro_se_authorized_s>();
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.init<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.init<five_g_pro_se_pc5_qos_params_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
  }
}
ho_request_ies_o::value_c::value_c(const ho_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::handov_type:
      c.init(other.c.get<handov_type_e>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.init(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::core_network_assist_info_for_inactive:
      c.init(other.c.get<core_network_assist_info_for_inactive_s>());
      break;
    case types::ue_security_cap:
      c.init(other.c.get<ue_security_cap_s>());
      break;
    case types::security_context:
      c.init(other.c.get<security_context_s>());
      break;
    case types::new_security_context_ind:
      c.init(other.c.get<new_security_context_ind_e>());
      break;
    case types::nasc:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdu_session_res_setup_list_ho_req:
      c.init(other.c.get<pdu_session_res_setup_list_ho_req_l>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::trace_activation:
      c.init(other.c.get<trace_activation_s>());
      break;
    case types::masked_imeisv:
      c.init(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::source_to_target_transparent_container:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::mob_restrict_list:
      c.init(other.c.get<mob_restrict_list_s>());
      break;
    case types::location_report_request_type:
      c.init(other.c.get<location_report_request_type_s>());
      break;
    case types::rrc_inactive_transition_report_request:
      c.init(other.c.get<rrc_inactive_transition_report_request_e>());
      break;
    case types::guami:
      c.init(other.c.get<guami_s>());
      break;
    case types::redirection_voice_fallback:
      c.init(other.c.get<redirection_voice_fallback_e>());
      break;
    case types::cn_assisted_ran_tuning:
      c.init(other.c.get<cn_assisted_ran_tuning_s>());
      break;
    case types::srvcc_operation_possible:
      c.init(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::iab_authorized:
      c.init(other.c.get<iab_authorized_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.init(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::ue_diff_info:
      c.init(other.c.get<ue_diff_info_s>());
      break;
    case types::nr_v2x_services_authorized:
      c.init(other.c.get<nr_v2x_services_authorized_s>());
      break;
    case types::ltev2x_services_authorized:
      c.init(other.c.get<ltev2x_services_authorized_s>());
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.init(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.init(other.c.get<lte_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::pc5_qos_params:
      c.init(other.c.get<pc5_qos_params_s>());
      break;
    case types::ce_mode_brestricted:
      c.init(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_up_c_iot_support:
      c.init(other.c.get<ue_up_c_iot_support_e>());
      break;
    case types::management_based_mdt_plmn_list:
      c.init(other.c.get<mdt_plmn_list_l>());
      break;
    case types::ue_radio_cap_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::extended_connected_time:
      c.init(other.c.get<uint16_t>());
      break;
    case types::time_sync_assist_info:
      c.init(other.c.get<time_sync_assist_info_s>());
      break;
    case types::ue_slice_max_bit_rate_list:
      c.init(other.c.get<ue_slice_max_bit_rate_list_l>());
      break;
    case types::five_g_pro_se_authorized:
      c.init(other.c.get<five_g_pro_se_authorized_s>());
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.init(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.init(other.c.get<five_g_pro_se_pc5_qos_params_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
  }
}
ho_request_ies_o::value_c& ho_request_ies_o::value_c::operator=(const ho_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::handov_type:
      c.set(other.c.get<handov_type_e>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.set(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::core_network_assist_info_for_inactive:
      c.set(other.c.get<core_network_assist_info_for_inactive_s>());
      break;
    case types::ue_security_cap:
      c.set(other.c.get<ue_security_cap_s>());
      break;
    case types::security_context:
      c.set(other.c.get<security_context_s>());
      break;
    case types::new_security_context_ind:
      c.set(other.c.get<new_security_context_ind_e>());
      break;
    case types::nasc:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdu_session_res_setup_list_ho_req:
      c.set(other.c.get<pdu_session_res_setup_list_ho_req_l>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::trace_activation:
      c.set(other.c.get<trace_activation_s>());
      break;
    case types::masked_imeisv:
      c.set(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::source_to_target_transparent_container:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::mob_restrict_list:
      c.set(other.c.get<mob_restrict_list_s>());
      break;
    case types::location_report_request_type:
      c.set(other.c.get<location_report_request_type_s>());
      break;
    case types::rrc_inactive_transition_report_request:
      c.set(other.c.get<rrc_inactive_transition_report_request_e>());
      break;
    case types::guami:
      c.set(other.c.get<guami_s>());
      break;
    case types::redirection_voice_fallback:
      c.set(other.c.get<redirection_voice_fallback_e>());
      break;
    case types::cn_assisted_ran_tuning:
      c.set(other.c.get<cn_assisted_ran_tuning_s>());
      break;
    case types::srvcc_operation_possible:
      c.set(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::iab_authorized:
      c.set(other.c.get<iab_authorized_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.set(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::ue_diff_info:
      c.set(other.c.get<ue_diff_info_s>());
      break;
    case types::nr_v2x_services_authorized:
      c.set(other.c.get<nr_v2x_services_authorized_s>());
      break;
    case types::ltev2x_services_authorized:
      c.set(other.c.get<ltev2x_services_authorized_s>());
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.set(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.set(other.c.get<lte_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::pc5_qos_params:
      c.set(other.c.get<pc5_qos_params_s>());
      break;
    case types::ce_mode_brestricted:
      c.set(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_up_c_iot_support:
      c.set(other.c.get<ue_up_c_iot_support_e>());
      break;
    case types::management_based_mdt_plmn_list:
      c.set(other.c.get<mdt_plmn_list_l>());
      break;
    case types::ue_radio_cap_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::extended_connected_time:
      c.set(other.c.get<uint16_t>());
      break;
    case types::time_sync_assist_info:
      c.set(other.c.get<time_sync_assist_info_s>());
      break;
    case types::ue_slice_max_bit_rate_list:
      c.set(other.c.get<ue_slice_max_bit_rate_list_l>());
      break;
    case types::five_g_pro_se_authorized:
      c.set(other.c.get<five_g_pro_se_authorized_s>());
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.set(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.set(other.c.get<five_g_pro_se_pc5_qos_params_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
handov_type_e& ho_request_ies_o::value_c::handov_type()
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
cause_c& ho_request_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
ue_aggr_max_bit_rate_s& ho_request_ies_o::value_c::ue_aggr_max_bit_rate()
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
core_network_assist_info_for_inactive_s& ho_request_ies_o::value_c::core_network_assist_info_for_inactive()
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
ue_security_cap_s& ho_request_ies_o::value_c::ue_security_cap()
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
security_context_s& ho_request_ies_o::value_c::security_context()
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
new_security_context_ind_e& ho_request_ies_o::value_c::new_security_context_ind()
{
  assert_choice_type(types::new_security_context_ind, type_, "Value");
  return c.get<new_security_context_ind_e>();
}
unbounded_octstring<true>& ho_request_ies_o::value_c::nasc()
{
  assert_choice_type(types::nasc, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
pdu_session_res_setup_list_ho_req_l& ho_request_ies_o::value_c::pdu_session_res_setup_list_ho_req()
{
  assert_choice_type(types::pdu_session_res_setup_list_ho_req, type_, "Value");
  return c.get<pdu_session_res_setup_list_ho_req_l>();
}
allowed_nssai_l& ho_request_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
trace_activation_s& ho_request_ies_o::value_c::trace_activation()
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
fixed_bitstring<64, false, true>& ho_request_ies_o::value_c::masked_imeisv()
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
unbounded_octstring<true>& ho_request_ies_o::value_c::source_to_target_transparent_container()
{
  assert_choice_type(types::source_to_target_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
mob_restrict_list_s& ho_request_ies_o::value_c::mob_restrict_list()
{
  assert_choice_type(types::mob_restrict_list, type_, "Value");
  return c.get<mob_restrict_list_s>();
}
location_report_request_type_s& ho_request_ies_o::value_c::location_report_request_type()
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
rrc_inactive_transition_report_request_e& ho_request_ies_o::value_c::rrc_inactive_transition_report_request()
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
guami_s& ho_request_ies_o::value_c::guami()
{
  assert_choice_type(types::guami, type_, "Value");
  return c.get<guami_s>();
}
redirection_voice_fallback_e& ho_request_ies_o::value_c::redirection_voice_fallback()
{
  assert_choice_type(types::redirection_voice_fallback, type_, "Value");
  return c.get<redirection_voice_fallback_e>();
}
cn_assisted_ran_tuning_s& ho_request_ies_o::value_c::cn_assisted_ran_tuning()
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
srvcc_operation_possible_e& ho_request_ies_o::value_c::srvcc_operation_possible()
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
iab_authorized_e& ho_request_ies_o::value_c::iab_authorized()
{
  assert_choice_type(types::iab_authorized, type_, "Value");
  return c.get<iab_authorized_e>();
}
enhanced_coverage_restrict_e& ho_request_ies_o::value_c::enhanced_coverage_restrict()
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
ue_diff_info_s& ho_request_ies_o::value_c::ue_diff_info()
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
nr_v2x_services_authorized_s& ho_request_ies_o::value_c::nr_v2x_services_authorized()
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
ltev2x_services_authorized_s& ho_request_ies_o::value_c::ltev2x_services_authorized()
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& ho_request_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
lte_ue_sidelink_aggr_max_bitrate_s& ho_request_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
pc5_qos_params_s& ho_request_ies_o::value_c::pc5_qos_params()
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
ce_mode_brestricted_e& ho_request_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
ue_up_c_iot_support_e& ho_request_ies_o::value_c::ue_up_c_iot_support()
{
  assert_choice_type(types::ue_up_c_iot_support, type_, "Value");
  return c.get<ue_up_c_iot_support_e>();
}
mdt_plmn_list_l& ho_request_ies_o::value_c::management_based_mdt_plmn_list()
{
  assert_choice_type(types::management_based_mdt_plmn_list, type_, "Value");
  return c.get<mdt_plmn_list_l>();
}
unbounded_octstring<true>& ho_request_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
uint16_t& ho_request_ies_o::value_c::extended_connected_time()
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
time_sync_assist_info_s& ho_request_ies_o::value_c::time_sync_assist_info()
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
ue_slice_max_bit_rate_list_l& ho_request_ies_o::value_c::ue_slice_max_bit_rate_list()
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
five_g_pro_se_authorized_s& ho_request_ies_o::value_c::five_g_pro_se_authorized()
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& ho_request_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate()
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
five_g_pro_se_pc5_qos_params_s& ho_request_ies_o::value_c::five_g_pro_se_pc5_qos_params()
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
const uint64_t& ho_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const handov_type_e& ho_request_ies_o::value_c::handov_type() const
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
const cause_c& ho_request_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const ue_aggr_max_bit_rate_s& ho_request_ies_o::value_c::ue_aggr_max_bit_rate() const
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
const core_network_assist_info_for_inactive_s& ho_request_ies_o::value_c::core_network_assist_info_for_inactive() const
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
const ue_security_cap_s& ho_request_ies_o::value_c::ue_security_cap() const
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
const security_context_s& ho_request_ies_o::value_c::security_context() const
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
const new_security_context_ind_e& ho_request_ies_o::value_c::new_security_context_ind() const
{
  assert_choice_type(types::new_security_context_ind, type_, "Value");
  return c.get<new_security_context_ind_e>();
}
const unbounded_octstring<true>& ho_request_ies_o::value_c::nasc() const
{
  assert_choice_type(types::nasc, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const pdu_session_res_setup_list_ho_req_l& ho_request_ies_o::value_c::pdu_session_res_setup_list_ho_req() const
{
  assert_choice_type(types::pdu_session_res_setup_list_ho_req, type_, "Value");
  return c.get<pdu_session_res_setup_list_ho_req_l>();
}
const allowed_nssai_l& ho_request_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const trace_activation_s& ho_request_ies_o::value_c::trace_activation() const
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
const fixed_bitstring<64, false, true>& ho_request_ies_o::value_c::masked_imeisv() const
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
const unbounded_octstring<true>& ho_request_ies_o::value_c::source_to_target_transparent_container() const
{
  assert_choice_type(types::source_to_target_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mob_restrict_list_s& ho_request_ies_o::value_c::mob_restrict_list() const
{
  assert_choice_type(types::mob_restrict_list, type_, "Value");
  return c.get<mob_restrict_list_s>();
}
const location_report_request_type_s& ho_request_ies_o::value_c::location_report_request_type() const
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
const rrc_inactive_transition_report_request_e&
ho_request_ies_o::value_c::rrc_inactive_transition_report_request() const
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
const guami_s& ho_request_ies_o::value_c::guami() const
{
  assert_choice_type(types::guami, type_, "Value");
  return c.get<guami_s>();
}
const redirection_voice_fallback_e& ho_request_ies_o::value_c::redirection_voice_fallback() const
{
  assert_choice_type(types::redirection_voice_fallback, type_, "Value");
  return c.get<redirection_voice_fallback_e>();
}
const cn_assisted_ran_tuning_s& ho_request_ies_o::value_c::cn_assisted_ran_tuning() const
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
const srvcc_operation_possible_e& ho_request_ies_o::value_c::srvcc_operation_possible() const
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
const iab_authorized_e& ho_request_ies_o::value_c::iab_authorized() const
{
  assert_choice_type(types::iab_authorized, type_, "Value");
  return c.get<iab_authorized_e>();
}
const enhanced_coverage_restrict_e& ho_request_ies_o::value_c::enhanced_coverage_restrict() const
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
const ue_diff_info_s& ho_request_ies_o::value_c::ue_diff_info() const
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
const nr_v2x_services_authorized_s& ho_request_ies_o::value_c::nr_v2x_services_authorized() const
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
const ltev2x_services_authorized_s& ho_request_ies_o::value_c::ltev2x_services_authorized() const
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s& ho_request_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const lte_ue_sidelink_aggr_max_bitrate_s& ho_request_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
const pc5_qos_params_s& ho_request_ies_o::value_c::pc5_qos_params() const
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
const ce_mode_brestricted_e& ho_request_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const ue_up_c_iot_support_e& ho_request_ies_o::value_c::ue_up_c_iot_support() const
{
  assert_choice_type(types::ue_up_c_iot_support, type_, "Value");
  return c.get<ue_up_c_iot_support_e>();
}
const mdt_plmn_list_l& ho_request_ies_o::value_c::management_based_mdt_plmn_list() const
{
  assert_choice_type(types::management_based_mdt_plmn_list, type_, "Value");
  return c.get<mdt_plmn_list_l>();
}
const unbounded_octstring<true>& ho_request_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint16_t& ho_request_ies_o::value_c::extended_connected_time() const
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
const time_sync_assist_info_s& ho_request_ies_o::value_c::time_sync_assist_info() const
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
const ue_slice_max_bit_rate_list_l& ho_request_ies_o::value_c::ue_slice_max_bit_rate_list() const
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
const five_g_pro_se_authorized_s& ho_request_ies_o::value_c::five_g_pro_se_authorized() const
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s& ho_request_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate() const
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const five_g_pro_se_pc5_qos_params_s& ho_request_ies_o::value_c::five_g_pro_se_pc5_qos_params() const
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
void ho_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::handov_type:
      j.write_str("HandoverType", c.get<handov_type_e>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::ue_aggr_max_bit_rate:
      j.write_fieldname("UEAggregateMaximumBitRate");
      c.get<ue_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::core_network_assist_info_for_inactive:
      j.write_fieldname("CoreNetworkAssistanceInformationForInactive");
      c.get<core_network_assist_info_for_inactive_s>().to_json(j);
      break;
    case types::ue_security_cap:
      j.write_fieldname("UESecurityCapabilities");
      c.get<ue_security_cap_s>().to_json(j);
      break;
    case types::security_context:
      j.write_fieldname("SecurityContext");
      c.get<security_context_s>().to_json(j);
      break;
    case types::new_security_context_ind:
      j.write_str("NewSecurityContextInd", "true");
      break;
    case types::nasc:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::pdu_session_res_setup_list_ho_req:
      j.start_array("PDUSessionResourceSetupListHOReq");
      for (const auto& e1 : c.get<pdu_session_res_setup_list_ho_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::trace_activation:
      j.write_fieldname("TraceActivation");
      c.get<trace_activation_s>().to_json(j);
      break;
    case types::masked_imeisv:
      j.write_str("BIT STRING", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    case types::source_to_target_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::mob_restrict_list:
      j.write_fieldname("MobilityRestrictionList");
      c.get<mob_restrict_list_s>().to_json(j);
      break;
    case types::location_report_request_type:
      j.write_fieldname("LocationReportingRequestType");
      c.get<location_report_request_type_s>().to_json(j);
      break;
    case types::rrc_inactive_transition_report_request:
      j.write_str("RRCInactiveTransitionReportRequest", c.get<rrc_inactive_transition_report_request_e>().to_string());
      break;
    case types::guami:
      j.write_fieldname("GUAMI");
      c.get<guami_s>().to_json(j);
      break;
    case types::redirection_voice_fallback:
      j.write_str("RedirectionVoiceFallback", c.get<redirection_voice_fallback_e>().to_string());
      break;
    case types::cn_assisted_ran_tuning:
      j.write_fieldname("CNAssistedRANTuning");
      c.get<cn_assisted_ran_tuning_s>().to_json(j);
      break;
    case types::srvcc_operation_possible:
      j.write_str("SRVCCOperationPossible", c.get<srvcc_operation_possible_e>().to_string());
      break;
    case types::iab_authorized:
      j.write_str("IAB-Authorized", c.get<iab_authorized_e>().to_string());
      break;
    case types::enhanced_coverage_restrict:
      j.write_str("Enhanced-CoverageRestriction", "restricted");
      break;
    case types::ue_diff_info:
      j.write_fieldname("UE-DifferentiationInfo");
      c.get<ue_diff_info_s>().to_json(j);
      break;
    case types::nr_v2x_services_authorized:
      j.write_fieldname("NRV2XServicesAuthorized");
      c.get<nr_v2x_services_authorized_s>().to_json(j);
      break;
    case types::ltev2x_services_authorized:
      j.write_fieldname("LTEV2XServicesAuthorized");
      c.get<ltev2x_services_authorized_s>().to_json(j);
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("LTEUESidelinkAggregateMaximumBitrate");
      c.get<lte_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::pc5_qos_params:
      j.write_fieldname("PC5QoSParameters");
      c.get<pc5_qos_params_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CEmodeBrestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::ue_up_c_iot_support:
      j.write_str("UE-UP-CIoT-Support", "supported");
      break;
    case types::management_based_mdt_plmn_list:
      j.start_array("MDTPLMNList");
      for (const auto& e1 : c.get<mdt_plmn_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::extended_connected_time:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::time_sync_assist_info:
      j.write_fieldname("TimeSyncAssistanceInfo");
      c.get<time_sync_assist_info_s>().to_json(j);
      break;
    case types::ue_slice_max_bit_rate_list:
      j.start_array("UESliceMaximumBitRateList");
      for (const auto& e1 : c.get<ue_slice_max_bit_rate_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::five_g_pro_se_authorized:
      j.write_fieldname("FiveG-ProSeAuthorized");
      c.get<five_g_pro_se_authorized_s>().to_json(j);
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::five_g_pro_se_pc5_qos_params:
      j.write_fieldname("FiveG-ProSePC5QoSParameters");
      c.get<five_g_pro_se_pc5_qos_params_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().pack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().pack(bref));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().pack(bref));
      break;
    case types::new_security_context_ind:
      HANDLE_CODE(c.get<new_security_context_ind_e>().pack(bref));
      break;
    case types::nasc:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::pdu_session_res_setup_list_ho_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_setup_list_ho_req_l>(), 1, 256, true));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().pack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    case types::source_to_target_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::mob_restrict_list:
      HANDLE_CODE(c.get<mob_restrict_list_s>().pack(bref));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().pack(bref));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().pack(bref));
      break;
    case types::guami:
      HANDLE_CODE(c.get<guami_s>().pack(bref));
      break;
    case types::redirection_voice_fallback:
      HANDLE_CODE(c.get<redirection_voice_fallback_e>().pack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().pack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().pack(bref));
      break;
    case types::iab_authorized:
      HANDLE_CODE(c.get<iab_authorized_e>().pack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().pack(bref));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().pack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().pack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().pack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::ue_up_c_iot_support:
      HANDLE_CODE(c.get<ue_up_c_iot_support_e>().pack(bref));
      break;
    case types::management_based_mdt_plmn_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mdt_plmn_list_l>(), 1, 16, true));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().pack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_slice_max_bit_rate_list_l>(), 1, 8, true));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().pack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().unpack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().unpack(bref));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().unpack(bref));
      break;
    case types::new_security_context_ind:
      HANDLE_CODE(c.get<new_security_context_ind_e>().unpack(bref));
      break;
    case types::nasc:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::pdu_session_res_setup_list_ho_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_setup_list_ho_req_l>(), bref, 1, 256, true));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().unpack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    case types::source_to_target_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::mob_restrict_list:
      HANDLE_CODE(c.get<mob_restrict_list_s>().unpack(bref));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().unpack(bref));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().unpack(bref));
      break;
    case types::guami:
      HANDLE_CODE(c.get<guami_s>().unpack(bref));
      break;
    case types::redirection_voice_fallback:
      HANDLE_CODE(c.get<redirection_voice_fallback_e>().unpack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().unpack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().unpack(bref));
      break;
    case types::iab_authorized:
      HANDLE_CODE(c.get<iab_authorized_e>().unpack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().unpack(bref));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().unpack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().unpack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().unpack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::ue_up_c_iot_support:
      HANDLE_CODE(c.get<ue_up_c_iot_support_e>().unpack(bref));
      break;
    case types::management_based_mdt_plmn_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mdt_plmn_list_l>(), bref, 1, 16, true));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().unpack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_slice_max_bit_rate_list_l>(), bref, 1, 8, true));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().unpack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

ho_request_ies_container::ho_request_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  handov_type(29, crit_e::reject),
  cause(15, crit_e::ignore),
  ue_aggr_max_bit_rate(110, crit_e::reject),
  core_network_assist_info_for_inactive(18, crit_e::ignore),
  ue_security_cap(119, crit_e::reject),
  security_context(93, crit_e::reject),
  new_security_context_ind(41, crit_e::reject),
  nasc(37, crit_e::reject),
  pdu_session_res_setup_list_ho_req(73, crit_e::reject),
  allowed_nssai(0, crit_e::reject),
  trace_activation(108, crit_e::ignore),
  masked_imeisv(34, crit_e::ignore),
  source_to_target_transparent_container(101, crit_e::reject),
  mob_restrict_list(36, crit_e::ignore),
  location_report_request_type(33, crit_e::ignore),
  rrc_inactive_transition_report_request(91, crit_e::ignore),
  guami(28, crit_e::reject),
  redirection_voice_fallback(146, crit_e::ignore),
  cn_assisted_ran_tuning(165, crit_e::ignore),
  srvcc_operation_possible(177, crit_e::ignore),
  iab_authorized(199, crit_e::reject),
  enhanced_coverage_restrict(205, crit_e::ignore),
  ue_diff_info(209, crit_e::ignore),
  nr_v2x_services_authorized(216, crit_e::ignore),
  ltev2x_services_authorized(215, crit_e::ignore),
  nr_ue_sidelink_aggr_max_bitrate(218, crit_e::ignore),
  lte_ue_sidelink_aggr_max_bitrate(217, crit_e::ignore),
  pc5_qos_params(219, crit_e::ignore),
  ce_mode_brestricted(222, crit_e::ignore),
  ue_up_c_iot_support(234, crit_e::ignore),
  management_based_mdt_plmn_list(254, crit_e::ignore),
  ue_radio_cap_id(264, crit_e::reject),
  extended_connected_time(206, crit_e::ignore),
  time_sync_assist_info(326, crit_e::ignore),
  ue_slice_max_bit_rate_list(335, crit_e::ignore),
  five_g_pro_se_authorized(345, crit_e::ignore),
  five_g_pro_se_ue_pc5_aggr_max_bit_rate(346, crit_e::ignore),
  five_g_pro_se_pc5_qos_params(347, crit_e::ignore)
{
}
SRSASN_CODE ho_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 10;
  nof_ies += core_network_assist_info_for_inactive_present ? 1 : 0;
  nof_ies += new_security_context_ind_present ? 1 : 0;
  nof_ies += nasc_present ? 1 : 0;
  nof_ies += trace_activation_present ? 1 : 0;
  nof_ies += masked_imeisv_present ? 1 : 0;
  nof_ies += mob_restrict_list_present ? 1 : 0;
  nof_ies += location_report_request_type_present ? 1 : 0;
  nof_ies += rrc_inactive_transition_report_request_present ? 1 : 0;
  nof_ies += redirection_voice_fallback_present ? 1 : 0;
  nof_ies += cn_assisted_ran_tuning_present ? 1 : 0;
  nof_ies += srvcc_operation_possible_present ? 1 : 0;
  nof_ies += iab_authorized_present ? 1 : 0;
  nof_ies += enhanced_coverage_restrict_present ? 1 : 0;
  nof_ies += ue_diff_info_present ? 1 : 0;
  nof_ies += nr_v2x_services_authorized_present ? 1 : 0;
  nof_ies += ltev2x_services_authorized_present ? 1 : 0;
  nof_ies += nr_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += lte_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += pc5_qos_params_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += ue_up_c_iot_support_present ? 1 : 0;
  nof_ies += management_based_mdt_plmn_list_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += extended_connected_time_present ? 1 : 0;
  nof_ies += time_sync_assist_info_present ? 1 : 0;
  nof_ies += ue_slice_max_bit_rate_list_present ? 1 : 0;
  nof_ies += five_g_pro_se_authorized_present ? 1 : 0;
  nof_ies += five_g_pro_se_ue_pc5_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += five_g_pro_se_pc5_qos_params_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(handov_type.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  HANDLE_CODE(ue_aggr_max_bit_rate.pack(bref));
  if (core_network_assist_info_for_inactive_present) {
    HANDLE_CODE(core_network_assist_info_for_inactive.pack(bref));
  }
  HANDLE_CODE(ue_security_cap.pack(bref));
  HANDLE_CODE(security_context.pack(bref));
  if (new_security_context_ind_present) {
    HANDLE_CODE(new_security_context_ind.pack(bref));
  }
  if (nasc_present) {
    HANDLE_CODE(nasc.pack(bref));
  }
  HANDLE_CODE(pdu_session_res_setup_list_ho_req.pack(bref));
  HANDLE_CODE(allowed_nssai.pack(bref));
  if (trace_activation_present) {
    HANDLE_CODE(trace_activation.pack(bref));
  }
  if (masked_imeisv_present) {
    HANDLE_CODE(masked_imeisv.pack(bref));
  }
  HANDLE_CODE(source_to_target_transparent_container.pack(bref));
  if (mob_restrict_list_present) {
    HANDLE_CODE(mob_restrict_list.pack(bref));
  }
  if (location_report_request_type_present) {
    HANDLE_CODE(location_report_request_type.pack(bref));
  }
  if (rrc_inactive_transition_report_request_present) {
    HANDLE_CODE(rrc_inactive_transition_report_request.pack(bref));
  }
  HANDLE_CODE(guami.pack(bref));
  if (redirection_voice_fallback_present) {
    HANDLE_CODE(redirection_voice_fallback.pack(bref));
  }
  if (cn_assisted_ran_tuning_present) {
    HANDLE_CODE(cn_assisted_ran_tuning.pack(bref));
  }
  if (srvcc_operation_possible_present) {
    HANDLE_CODE(srvcc_operation_possible.pack(bref));
  }
  if (iab_authorized_present) {
    HANDLE_CODE(iab_authorized.pack(bref));
  }
  if (enhanced_coverage_restrict_present) {
    HANDLE_CODE(enhanced_coverage_restrict.pack(bref));
  }
  if (ue_diff_info_present) {
    HANDLE_CODE(ue_diff_info.pack(bref));
  }
  if (nr_v2x_services_authorized_present) {
    HANDLE_CODE(nr_v2x_services_authorized.pack(bref));
  }
  if (ltev2x_services_authorized_present) {
    HANDLE_CODE(ltev2x_services_authorized.pack(bref));
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (pc5_qos_params_present) {
    HANDLE_CODE(pc5_qos_params.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (ue_up_c_iot_support_present) {
    HANDLE_CODE(ue_up_c_iot_support.pack(bref));
  }
  if (management_based_mdt_plmn_list_present) {
    HANDLE_CODE(management_based_mdt_plmn_list.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (extended_connected_time_present) {
    HANDLE_CODE(extended_connected_time.pack(bref));
  }
  if (time_sync_assist_info_present) {
    HANDLE_CODE(time_sync_assist_info.pack(bref));
  }
  if (ue_slice_max_bit_rate_list_present) {
    HANDLE_CODE(ue_slice_max_bit_rate_list.pack(bref));
  }
  if (five_g_pro_se_authorized_present) {
    HANDLE_CODE(five_g_pro_se_authorized.pack(bref));
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.pack(bref));
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    HANDLE_CODE(five_g_pro_se_pc5_qos_params.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 10;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 29: {
        nof_mandatory_ies--;
        handov_type.id = id;
        HANDLE_CODE(handov_type.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(handov_type.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 110: {
        nof_mandatory_ies--;
        ue_aggr_max_bit_rate.id = id;
        HANDLE_CODE(ue_aggr_max_bit_rate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_aggr_max_bit_rate.value.unpack(bref));
        break;
      }
      case 18: {
        core_network_assist_info_for_inactive_present = true;
        core_network_assist_info_for_inactive.id      = id;
        HANDLE_CODE(core_network_assist_info_for_inactive.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(core_network_assist_info_for_inactive.value.unpack(bref));
        break;
      }
      case 119: {
        nof_mandatory_ies--;
        ue_security_cap.id = id;
        HANDLE_CODE(ue_security_cap.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_security_cap.value.unpack(bref));
        break;
      }
      case 93: {
        nof_mandatory_ies--;
        security_context.id = id;
        HANDLE_CODE(security_context.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_context.value.unpack(bref));
        break;
      }
      case 41: {
        new_security_context_ind_present = true;
        new_security_context_ind.id      = id;
        HANDLE_CODE(new_security_context_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(new_security_context_ind.value.unpack(bref));
        break;
      }
      case 37: {
        nasc_present = true;
        nasc.id      = id;
        HANDLE_CODE(nasc.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nasc.value.unpack(bref));
        break;
      }
      case 73: {
        nof_mandatory_ies--;
        pdu_session_res_setup_list_ho_req.id = id;
        HANDLE_CODE(pdu_session_res_setup_list_ho_req.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_setup_list_ho_req.value.unpack(bref));
        break;
      }
      case 0: {
        nof_mandatory_ies--;
        allowed_nssai.id = id;
        HANDLE_CODE(allowed_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(allowed_nssai.value.unpack(bref));
        break;
      }
      case 108: {
        trace_activation_present = true;
        trace_activation.id      = id;
        HANDLE_CODE(trace_activation.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trace_activation.value.unpack(bref));
        break;
      }
      case 34: {
        masked_imeisv_present = true;
        masked_imeisv.id      = id;
        HANDLE_CODE(masked_imeisv.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(masked_imeisv.value.unpack(bref));
        break;
      }
      case 101: {
        nof_mandatory_ies--;
        source_to_target_transparent_container.id = id;
        HANDLE_CODE(source_to_target_transparent_container.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_to_target_transparent_container.value.unpack(bref));
        break;
      }
      case 36: {
        mob_restrict_list_present = true;
        mob_restrict_list.id      = id;
        HANDLE_CODE(mob_restrict_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mob_restrict_list.value.unpack(bref));
        break;
      }
      case 33: {
        location_report_request_type_present = true;
        location_report_request_type.id      = id;
        HANDLE_CODE(location_report_request_type.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(location_report_request_type.value.unpack(bref));
        break;
      }
      case 91: {
        rrc_inactive_transition_report_request_present = true;
        rrc_inactive_transition_report_request.id      = id;
        HANDLE_CODE(rrc_inactive_transition_report_request.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_inactive_transition_report_request.value.unpack(bref));
        break;
      }
      case 28: {
        nof_mandatory_ies--;
        guami.id = id;
        HANDLE_CODE(guami.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(guami.value.unpack(bref));
        break;
      }
      case 146: {
        redirection_voice_fallback_present = true;
        redirection_voice_fallback.id      = id;
        HANDLE_CODE(redirection_voice_fallback.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redirection_voice_fallback.value.unpack(bref));
        break;
      }
      case 165: {
        cn_assisted_ran_tuning_present = true;
        cn_assisted_ran_tuning.id      = id;
        HANDLE_CODE(cn_assisted_ran_tuning.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_assisted_ran_tuning.value.unpack(bref));
        break;
      }
      case 177: {
        srvcc_operation_possible_present = true;
        srvcc_operation_possible.id      = id;
        HANDLE_CODE(srvcc_operation_possible.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(srvcc_operation_possible.value.unpack(bref));
        break;
      }
      case 199: {
        iab_authorized_present = true;
        iab_authorized.id      = id;
        HANDLE_CODE(iab_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(iab_authorized.value.unpack(bref));
        break;
      }
      case 205: {
        enhanced_coverage_restrict_present = true;
        enhanced_coverage_restrict.id      = id;
        HANDLE_CODE(enhanced_coverage_restrict.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(enhanced_coverage_restrict.value.unpack(bref));
        break;
      }
      case 209: {
        ue_diff_info_present = true;
        ue_diff_info.id      = id;
        HANDLE_CODE(ue_diff_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_diff_info.value.unpack(bref));
        break;
      }
      case 216: {
        nr_v2x_services_authorized_present = true;
        nr_v2x_services_authorized.id      = id;
        HANDLE_CODE(nr_v2x_services_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_v2x_services_authorized.value.unpack(bref));
        break;
      }
      case 215: {
        ltev2x_services_authorized_present = true;
        ltev2x_services_authorized.id      = id;
        HANDLE_CODE(ltev2x_services_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ltev2x_services_authorized.value.unpack(bref));
        break;
      }
      case 218: {
        nr_ue_sidelink_aggr_max_bitrate_present = true;
        nr_ue_sidelink_aggr_max_bitrate.id      = id;
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.value.unpack(bref));
        break;
      }
      case 217: {
        lte_ue_sidelink_aggr_max_bitrate_present = true;
        lte_ue_sidelink_aggr_max_bitrate.id      = id;
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.value.unpack(bref));
        break;
      }
      case 219: {
        pc5_qos_params_present = true;
        pc5_qos_params.id      = id;
        HANDLE_CODE(pc5_qos_params.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pc5_qos_params.value.unpack(bref));
        break;
      }
      case 222: {
        ce_mode_brestricted_present = true;
        ce_mode_brestricted.id      = id;
        HANDLE_CODE(ce_mode_brestricted.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_brestricted.value.unpack(bref));
        break;
      }
      case 234: {
        ue_up_c_iot_support_present = true;
        ue_up_c_iot_support.id      = id;
        HANDLE_CODE(ue_up_c_iot_support.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_up_c_iot_support.value.unpack(bref));
        break;
      }
      case 254: {
        management_based_mdt_plmn_list_present = true;
        management_based_mdt_plmn_list.id      = id;
        HANDLE_CODE(management_based_mdt_plmn_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(management_based_mdt_plmn_list.value.unpack(bref));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        ue_radio_cap_id.id      = id;
        HANDLE_CODE(ue_radio_cap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.value.unpack(bref));
        break;
      }
      case 206: {
        extended_connected_time_present = true;
        extended_connected_time.id      = id;
        HANDLE_CODE(extended_connected_time.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_connected_time.value.unpack(bref));
        break;
      }
      case 326: {
        time_sync_assist_info_present = true;
        time_sync_assist_info.id      = id;
        HANDLE_CODE(time_sync_assist_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_sync_assist_info.value.unpack(bref));
        break;
      }
      case 335: {
        ue_slice_max_bit_rate_list_present = true;
        ue_slice_max_bit_rate_list.id      = id;
        HANDLE_CODE(ue_slice_max_bit_rate_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_slice_max_bit_rate_list.value.unpack(bref));
        break;
      }
      case 345: {
        five_g_pro_se_authorized_present = true;
        five_g_pro_se_authorized.id      = id;
        HANDLE_CODE(five_g_pro_se_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_authorized.value.unpack(bref));
        break;
      }
      case 346: {
        five_g_pro_se_ue_pc5_aggr_max_bit_rate_present = true;
        five_g_pro_se_ue_pc5_aggr_max_bit_rate.id      = id;
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.value.unpack(bref));
        break;
      }
      case 347: {
        five_g_pro_se_pc5_qos_params_present = true;
        five_g_pro_se_pc5_qos_params.id      = id;
        HANDLE_CODE(five_g_pro_se_pc5_qos_params.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_pc5_qos_params.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  handov_type.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.write_fieldname("");
  ue_aggr_max_bit_rate.to_json(j);
  if (core_network_assist_info_for_inactive_present) {
    j.write_fieldname("");
    core_network_assist_info_for_inactive.to_json(j);
  }
  j.write_fieldname("");
  ue_security_cap.to_json(j);
  j.write_fieldname("");
  security_context.to_json(j);
  if (new_security_context_ind_present) {
    j.write_fieldname("");
    new_security_context_ind.to_json(j);
  }
  if (nasc_present) {
    j.write_fieldname("");
    nasc.to_json(j);
  }
  j.write_fieldname("");
  pdu_session_res_setup_list_ho_req.to_json(j);
  j.write_fieldname("");
  allowed_nssai.to_json(j);
  if (trace_activation_present) {
    j.write_fieldname("");
    trace_activation.to_json(j);
  }
  if (masked_imeisv_present) {
    j.write_fieldname("");
    masked_imeisv.to_json(j);
  }
  j.write_fieldname("");
  source_to_target_transparent_container.to_json(j);
  if (mob_restrict_list_present) {
    j.write_fieldname("");
    mob_restrict_list.to_json(j);
  }
  if (location_report_request_type_present) {
    j.write_fieldname("");
    location_report_request_type.to_json(j);
  }
  if (rrc_inactive_transition_report_request_present) {
    j.write_fieldname("");
    rrc_inactive_transition_report_request.to_json(j);
  }
  j.write_fieldname("");
  guami.to_json(j);
  if (redirection_voice_fallback_present) {
    j.write_fieldname("");
    redirection_voice_fallback.to_json(j);
  }
  if (cn_assisted_ran_tuning_present) {
    j.write_fieldname("");
    cn_assisted_ran_tuning.to_json(j);
  }
  if (srvcc_operation_possible_present) {
    j.write_fieldname("");
    srvcc_operation_possible.to_json(j);
  }
  if (iab_authorized_present) {
    j.write_fieldname("");
    iab_authorized.to_json(j);
  }
  if (enhanced_coverage_restrict_present) {
    j.write_fieldname("");
    enhanced_coverage_restrict.to_json(j);
  }
  if (ue_diff_info_present) {
    j.write_fieldname("");
    ue_diff_info.to_json(j);
  }
  if (nr_v2x_services_authorized_present) {
    j.write_fieldname("");
    nr_v2x_services_authorized.to_json(j);
  }
  if (ltev2x_services_authorized_present) {
    j.write_fieldname("");
    ltev2x_services_authorized.to_json(j);
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    j.write_fieldname("");
    nr_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    j.write_fieldname("");
    lte_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (pc5_qos_params_present) {
    j.write_fieldname("");
    pc5_qos_params.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_fieldname("");
    ce_mode_brestricted.to_json(j);
  }
  if (ue_up_c_iot_support_present) {
    j.write_fieldname("");
    ue_up_c_iot_support.to_json(j);
  }
  if (management_based_mdt_plmn_list_present) {
    j.write_fieldname("");
    management_based_mdt_plmn_list.to_json(j);
  }
  if (ue_radio_cap_id_present) {
    j.write_fieldname("");
    ue_radio_cap_id.to_json(j);
  }
  if (extended_connected_time_present) {
    j.write_fieldname("");
    extended_connected_time.to_json(j);
  }
  if (time_sync_assist_info_present) {
    j.write_fieldname("");
    time_sync_assist_info.to_json(j);
  }
  if (ue_slice_max_bit_rate_list_present) {
    j.write_fieldname("");
    ue_slice_max_bit_rate_list.to_json(j);
  }
  if (five_g_pro_se_authorized_present) {
    j.write_fieldname("");
    five_g_pro_se_authorized.to_json(j);
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    j.write_fieldname("");
    five_g_pro_se_ue_pc5_aggr_max_bit_rate.to_json(j);
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    j.write_fieldname("");
    five_g_pro_se_pc5_qos_params.to_json(j);
  }
  j.end_obj();
}

// HandoverRequestAcknowledgeIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_request_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 53, 56, 106, 19, 259, 333};
  return map_enum_number(names, 8, idx, "id");
}
bool ho_request_ack_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 53, 56, 106, 19, 259, 333};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_request_ack_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 53:
      return crit_e::ignore;
    case 56:
      return crit_e::ignore;
    case 106:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    case 259:
      return crit_e::reject;
    case 333:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_request_ack_ies_o::value_c ho_request_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 53:
      ret.set(value_c::types::pdu_session_res_admitted_list);
      break;
    case 56:
      ret.set(value_c::types::pdu_session_res_failed_to_setup_list_ho_ack);
      break;
    case 106:
      ret.set(value_c::types::target_to_source_transparent_container);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 259:
      ret.set(value_c::types::npn_access_info);
      break;
    case 333:
      ret.set(value_c::types::red_cap_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_request_ack_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 53:
      return presence_e::mandatory;
    case 56:
      return presence_e::optional;
    case 106:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    case 259:
      return presence_e::optional;
    case 333:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_request_ack_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_admitted_list:
      c.destroy<pdu_session_res_admitted_list_l>();
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      c.destroy<pdu_session_res_failed_to_setup_list_ho_ack_l>();
      break;
    case types::target_to_source_transparent_container:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::npn_access_info:
      c.destroy<npn_access_info_c>();
      break;
    default:
      break;
  }
}
void ho_request_ack_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_admitted_list:
      c.init<pdu_session_res_admitted_list_l>();
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      c.init<pdu_session_res_failed_to_setup_list_ho_ack_l>();
      break;
    case types::target_to_source_transparent_container:
      c.init<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::npn_access_info:
      c.init<npn_access_info_c>();
      break;
    case types::red_cap_ind:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
  }
}
ho_request_ack_ies_o::value_c::value_c(const ho_request_ack_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_admitted_list:
      c.init(other.c.get<pdu_session_res_admitted_list_l>());
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      c.init(other.c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>());
      break;
    case types::target_to_source_transparent_container:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::npn_access_info:
      c.init(other.c.get<npn_access_info_c>());
      break;
    case types::red_cap_ind:
      c.init(other.c.get<red_cap_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
  }
}
ho_request_ack_ies_o::value_c& ho_request_ack_ies_o::value_c::operator=(const ho_request_ack_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_admitted_list:
      c.set(other.c.get<pdu_session_res_admitted_list_l>());
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      c.set(other.c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>());
      break;
    case types::target_to_source_transparent_container:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::npn_access_info:
      c.set(other.c.get<npn_access_info_c>());
      break;
    case types::red_cap_ind:
      c.set(other.c.get<red_cap_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_request_ack_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_request_ack_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_admitted_list_l& ho_request_ack_ies_o::value_c::pdu_session_res_admitted_list()
{
  assert_choice_type(types::pdu_session_res_admitted_list, type_, "Value");
  return c.get<pdu_session_res_admitted_list_l>();
}
pdu_session_res_failed_to_setup_list_ho_ack_l&
ho_request_ack_ies_o::value_c::pdu_session_res_failed_to_setup_list_ho_ack()
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_ho_ack, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>();
}
unbounded_octstring<true>& ho_request_ack_ies_o::value_c::target_to_source_transparent_container()
{
  assert_choice_type(types::target_to_source_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& ho_request_ack_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
npn_access_info_c& ho_request_ack_ies_o::value_c::npn_access_info()
{
  assert_choice_type(types::npn_access_info, type_, "Value");
  return c.get<npn_access_info_c>();
}
red_cap_ind_e& ho_request_ack_ies_o::value_c::red_cap_ind()
{
  assert_choice_type(types::red_cap_ind, type_, "Value");
  return c.get<red_cap_ind_e>();
}
const uint64_t& ho_request_ack_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_request_ack_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_admitted_list_l& ho_request_ack_ies_o::value_c::pdu_session_res_admitted_list() const
{
  assert_choice_type(types::pdu_session_res_admitted_list, type_, "Value");
  return c.get<pdu_session_res_admitted_list_l>();
}
const pdu_session_res_failed_to_setup_list_ho_ack_l&
ho_request_ack_ies_o::value_c::pdu_session_res_failed_to_setup_list_ho_ack() const
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_ho_ack, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>();
}
const unbounded_octstring<true>& ho_request_ack_ies_o::value_c::target_to_source_transparent_container() const
{
  assert_choice_type(types::target_to_source_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& ho_request_ack_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const npn_access_info_c& ho_request_ack_ies_o::value_c::npn_access_info() const
{
  assert_choice_type(types::npn_access_info, type_, "Value");
  return c.get<npn_access_info_c>();
}
const red_cap_ind_e& ho_request_ack_ies_o::value_c::red_cap_ind() const
{
  assert_choice_type(types::red_cap_ind, type_, "Value");
  return c.get<red_cap_ind_e>();
}
void ho_request_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_admitted_list:
      j.start_array("PDUSessionResourceAdmittedList");
      for (const auto& e1 : c.get<pdu_session_res_admitted_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      j.start_array("PDUSessionResourceFailedToSetupListHOAck");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::target_to_source_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::npn_access_info:
      j.write_fieldname("NPN-AccessInformation");
      c.get<npn_access_info_c>().to_json(j);
      break;
    case types::red_cap_ind:
      j.write_str("RedCapIndication", "redcap");
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_request_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_admitted_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_admitted_list_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>(), 1, 256, true));
      break;
    case types::target_to_source_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::npn_access_info:
      HANDLE_CODE(c.get<npn_access_info_c>().pack(bref));
      break;
    case types::red_cap_ind:
      HANDLE_CODE(c.get<red_cap_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_admitted_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_admitted_list_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>(), bref, 1, 256, true));
      break;
    case types::target_to_source_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::npn_access_info:
      HANDLE_CODE(c.get<npn_access_info_c>().unpack(bref));
      break;
    case types::red_cap_ind:
      HANDLE_CODE(c.get<red_cap_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

ho_request_ack_ies_container::ho_request_ack_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  pdu_session_res_admitted_list(53, crit_e::ignore),
  pdu_session_res_failed_to_setup_list_ho_ack(56, crit_e::ignore),
  target_to_source_transparent_container(106, crit_e::reject),
  crit_diagnostics(19, crit_e::ignore),
  npn_access_info(259, crit_e::reject),
  red_cap_ind(333, crit_e::ignore)
{
}
SRSASN_CODE ho_request_ack_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += pdu_session_res_failed_to_setup_list_ho_ack_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += npn_access_info_present ? 1 : 0;
  nof_ies += red_cap_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(pdu_session_res_admitted_list.pack(bref));
  if (pdu_session_res_failed_to_setup_list_ho_ack_present) {
    HANDLE_CODE(pdu_session_res_failed_to_setup_list_ho_ack.pack(bref));
  }
  HANDLE_CODE(target_to_source_transparent_container.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (npn_access_info_present) {
    HANDLE_CODE(npn_access_info.pack(bref));
  }
  if (red_cap_ind_present) {
    HANDLE_CODE(red_cap_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ack_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 53: {
        nof_mandatory_ies--;
        pdu_session_res_admitted_list.id = id;
        HANDLE_CODE(pdu_session_res_admitted_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_admitted_list.value.unpack(bref));
        break;
      }
      case 56: {
        pdu_session_res_failed_to_setup_list_ho_ack_present = true;
        pdu_session_res_failed_to_setup_list_ho_ack.id      = id;
        HANDLE_CODE(pdu_session_res_failed_to_setup_list_ho_ack.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_failed_to_setup_list_ho_ack.value.unpack(bref));
        break;
      }
      case 106: {
        nof_mandatory_ies--;
        target_to_source_transparent_container.id = id;
        HANDLE_CODE(target_to_source_transparent_container.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(target_to_source_transparent_container.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      case 259: {
        npn_access_info_present = true;
        npn_access_info.id      = id;
        HANDLE_CODE(npn_access_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(npn_access_info.value.unpack(bref));
        break;
      }
      case 333: {
        red_cap_ind_present = true;
        red_cap_ind.id      = id;
        HANDLE_CODE(red_cap_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(red_cap_ind.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_request_ack_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  pdu_session_res_admitted_list.to_json(j);
  if (pdu_session_res_failed_to_setup_list_ho_ack_present) {
    j.write_fieldname("");
    pdu_session_res_failed_to_setup_list_ho_ack.to_json(j);
  }
  j.write_fieldname("");
  target_to_source_transparent_container.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (npn_access_info_present) {
    j.write_fieldname("");
    npn_access_info.to_json(j);
  }
  if (red_cap_ind_present) {
    j.write_fieldname("");
    red_cap_ind.to_json(j);
  }
  j.end_obj();
}

// HandoverRequiredIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_required_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 29, 15, 105, 22, 61, 101};
  return map_enum_number(names, 8, idx, "id");
}
bool ho_required_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 29, 15, 105, 22, 61, 101};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_required_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 29:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    case 105:
      return crit_e::reject;
    case 22:
      return crit_e::ignore;
    case 61:
      return crit_e::reject;
    case 101:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_required_ies_o::value_c ho_required_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 29:
      ret.set(value_c::types::handov_type);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 105:
      ret.set(value_c::types::target_id);
      break;
    case 22:
      ret.set(value_c::types::direct_forwarding_path_availability);
      break;
    case 61:
      ret.set(value_c::types::pdu_session_res_list_ho_rqd);
      break;
    case 101:
      ret.set(value_c::types::source_to_target_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_required_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 29:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 105:
      return presence_e::mandatory;
    case 22:
      return presence_e::optional;
    case 61:
      return presence_e::mandatory;
    case 101:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_required_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::target_id:
      c.destroy<target_id_c>();
      break;
    case types::pdu_session_res_list_ho_rqd:
      c.destroy<pdu_session_res_list_ho_rqd_l>();
      break;
    case types::source_to_target_transparent_container:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void ho_required_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::handov_type:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::target_id:
      c.init<target_id_c>();
      break;
    case types::direct_forwarding_path_availability:
      break;
    case types::pdu_session_res_list_ho_rqd:
      c.init<pdu_session_res_list_ho_rqd_l>();
      break;
    case types::source_to_target_transparent_container:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
  }
}
ho_required_ies_o::value_c::value_c(const ho_required_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::handov_type:
      c.init(other.c.get<handov_type_e>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::target_id:
      c.init(other.c.get<target_id_c>());
      break;
    case types::direct_forwarding_path_availability:
      c.init(other.c.get<direct_forwarding_path_availability_e>());
      break;
    case types::pdu_session_res_list_ho_rqd:
      c.init(other.c.get<pdu_session_res_list_ho_rqd_l>());
      break;
    case types::source_to_target_transparent_container:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
  }
}
ho_required_ies_o::value_c& ho_required_ies_o::value_c::operator=(const ho_required_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::handov_type:
      c.set(other.c.get<handov_type_e>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::target_id:
      c.set(other.c.get<target_id_c>());
      break;
    case types::direct_forwarding_path_availability:
      c.set(other.c.get<direct_forwarding_path_availability_e>());
      break;
    case types::pdu_session_res_list_ho_rqd:
      c.set(other.c.get<pdu_session_res_list_ho_rqd_l>());
      break;
    case types::source_to_target_transparent_container:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_required_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_required_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
handov_type_e& ho_required_ies_o::value_c::handov_type()
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
cause_c& ho_required_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
target_id_c& ho_required_ies_o::value_c::target_id()
{
  assert_choice_type(types::target_id, type_, "Value");
  return c.get<target_id_c>();
}
direct_forwarding_path_availability_e& ho_required_ies_o::value_c::direct_forwarding_path_availability()
{
  assert_choice_type(types::direct_forwarding_path_availability, type_, "Value");
  return c.get<direct_forwarding_path_availability_e>();
}
pdu_session_res_list_ho_rqd_l& ho_required_ies_o::value_c::pdu_session_res_list_ho_rqd()
{
  assert_choice_type(types::pdu_session_res_list_ho_rqd, type_, "Value");
  return c.get<pdu_session_res_list_ho_rqd_l>();
}
unbounded_octstring<true>& ho_required_ies_o::value_c::source_to_target_transparent_container()
{
  assert_choice_type(types::source_to_target_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ho_required_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_required_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const handov_type_e& ho_required_ies_o::value_c::handov_type() const
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
const cause_c& ho_required_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const target_id_c& ho_required_ies_o::value_c::target_id() const
{
  assert_choice_type(types::target_id, type_, "Value");
  return c.get<target_id_c>();
}
const direct_forwarding_path_availability_e& ho_required_ies_o::value_c::direct_forwarding_path_availability() const
{
  assert_choice_type(types::direct_forwarding_path_availability, type_, "Value");
  return c.get<direct_forwarding_path_availability_e>();
}
const pdu_session_res_list_ho_rqd_l& ho_required_ies_o::value_c::pdu_session_res_list_ho_rqd() const
{
  assert_choice_type(types::pdu_session_res_list_ho_rqd, type_, "Value");
  return c.get<pdu_session_res_list_ho_rqd_l>();
}
const unbounded_octstring<true>& ho_required_ies_o::value_c::source_to_target_transparent_container() const
{
  assert_choice_type(types::source_to_target_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ho_required_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::handov_type:
      j.write_str("HandoverType", c.get<handov_type_e>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::target_id:
      j.write_fieldname("TargetID");
      c.get<target_id_c>().to_json(j);
      break;
    case types::direct_forwarding_path_availability:
      j.write_str("DirectForwardingPathAvailability", "direct-path-available");
      break;
    case types::pdu_session_res_list_ho_rqd:
      j.start_array("PDUSessionResourceListHORqd");
      for (const auto& e1 : c.get<pdu_session_res_list_ho_rqd_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::source_to_target_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_required_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::target_id:
      HANDLE_CODE(c.get<target_id_c>().pack(bref));
      break;
    case types::direct_forwarding_path_availability:
      HANDLE_CODE(c.get<direct_forwarding_path_availability_e>().pack(bref));
      break;
    case types::pdu_session_res_list_ho_rqd:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_list_ho_rqd_l>(), 1, 256, true));
      break;
    case types::source_to_target_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_required_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::target_id:
      HANDLE_CODE(c.get<target_id_c>().unpack(bref));
      break;
    case types::direct_forwarding_path_availability:
      HANDLE_CODE(c.get<direct_forwarding_path_availability_e>().unpack(bref));
      break;
    case types::pdu_session_res_list_ho_rqd:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_list_ho_rqd_l>(), bref, 1, 256, true));
      break;
    case types::source_to_target_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

ho_required_ies_container::ho_required_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  handov_type(29, crit_e::reject),
  cause(15, crit_e::ignore),
  target_id(105, crit_e::reject),
  direct_forwarding_path_availability(22, crit_e::ignore),
  pdu_session_res_list_ho_rqd(61, crit_e::reject),
  source_to_target_transparent_container(101, crit_e::reject)
{
}
SRSASN_CODE ho_required_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 7;
  nof_ies += direct_forwarding_path_availability_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(handov_type.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  HANDLE_CODE(target_id.pack(bref));
  if (direct_forwarding_path_availability_present) {
    HANDLE_CODE(direct_forwarding_path_availability.pack(bref));
  }
  HANDLE_CODE(pdu_session_res_list_ho_rqd.pack(bref));
  HANDLE_CODE(source_to_target_transparent_container.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_required_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 7;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 29: {
        nof_mandatory_ies--;
        handov_type.id = id;
        HANDLE_CODE(handov_type.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(handov_type.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 105: {
        nof_mandatory_ies--;
        target_id.id = id;
        HANDLE_CODE(target_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(target_id.value.unpack(bref));
        break;
      }
      case 22: {
        direct_forwarding_path_availability_present = true;
        direct_forwarding_path_availability.id      = id;
        HANDLE_CODE(direct_forwarding_path_availability.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(direct_forwarding_path_availability.value.unpack(bref));
        break;
      }
      case 61: {
        nof_mandatory_ies--;
        pdu_session_res_list_ho_rqd.id = id;
        HANDLE_CODE(pdu_session_res_list_ho_rqd.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_list_ho_rqd.value.unpack(bref));
        break;
      }
      case 101: {
        nof_mandatory_ies--;
        source_to_target_transparent_container.id = id;
        HANDLE_CODE(source_to_target_transparent_container.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_to_target_transparent_container.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_required_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  handov_type.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.write_fieldname("");
  target_id.to_json(j);
  if (direct_forwarding_path_availability_present) {
    j.write_fieldname("");
    direct_forwarding_path_availability.to_json(j);
  }
  j.write_fieldname("");
  pdu_session_res_list_ho_rqd.to_json(j);
  j.write_fieldname("");
  source_to_target_transparent_container.to_json(j);
  j.end_obj();
}

// HandoverSuccessIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_success_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85};
  return map_enum_number(names, 2, idx, "id");
}
bool ho_success_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_success_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_success_ies_o::value_c ho_success_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_success_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_success_ies_o::value_c::destroy_() {}
void ho_success_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
ho_success_ies_o::value_c::value_c(const ho_success_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_success_ies_o::value_c");
  }
}
ho_success_ies_o::value_c& ho_success_ies_o::value_c::operator=(const ho_success_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_success_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_success_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_success_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_success_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_success_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
void ho_success_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    default:
      log_invalid_choice_id(type_, "ho_success_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_success_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "ho_success_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_success_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "ho_success_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

ho_success_ies_container::ho_success_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject), ran_ue_ngap_id(85, crit_e::reject)
{
}
SRSASN_CODE ho_success_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_success_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_success_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.end_obj();
}

// InitialContextSetupFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t init_context_setup_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 132, 15, 19};
  return map_enum_number(names, 5, idx, "id");
}
bool init_context_setup_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 132, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e init_context_setup_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 132:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
init_context_setup_fail_ies_o::value_c init_context_setup_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 132:
      ret.set(value_c::types::pdu_session_res_failed_to_setup_list_cxt_fail);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e init_context_setup_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 132:
      return presence_e::optional;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void init_context_setup_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      c.destroy<pdu_session_res_failed_to_setup_list_cxt_fail_l>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void init_context_setup_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      c.init<pdu_session_res_failed_to_setup_list_cxt_fail_l>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
  }
}
init_context_setup_fail_ies_o::value_c::value_c(const init_context_setup_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      c.init(other.c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
  }
}
init_context_setup_fail_ies_o::value_c&
init_context_setup_fail_ies_o::value_c::operator=(const init_context_setup_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      c.set(other.c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& init_context_setup_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& init_context_setup_fail_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_failed_to_setup_list_cxt_fail_l&
init_context_setup_fail_ies_o::value_c::pdu_session_res_failed_to_setup_list_cxt_fail()
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_cxt_fail, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>();
}
cause_c& init_context_setup_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& init_context_setup_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& init_context_setup_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& init_context_setup_fail_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_failed_to_setup_list_cxt_fail_l&
init_context_setup_fail_ies_o::value_c::pdu_session_res_failed_to_setup_list_cxt_fail() const
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_cxt_fail, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>();
}
const cause_c& init_context_setup_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& init_context_setup_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void init_context_setup_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      j.start_array("PDUSessionResourceFailedToSetupListCxtFail");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE init_context_setup_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>(), 1, 256, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>(), bref, 1, 256, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

init_context_setup_fail_ies_container::init_context_setup_fail_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  pdu_session_res_failed_to_setup_list_cxt_fail(132, crit_e::ignore),
  cause(15, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE init_context_setup_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += pdu_session_res_failed_to_setup_list_cxt_fail_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (pdu_session_res_failed_to_setup_list_cxt_fail_present) {
    HANDLE_CODE(pdu_session_res_failed_to_setup_list_cxt_fail.pack(bref));
  }
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 132: {
        pdu_session_res_failed_to_setup_list_cxt_fail_present = true;
        pdu_session_res_failed_to_setup_list_cxt_fail.id      = id;
        HANDLE_CODE(pdu_session_res_failed_to_setup_list_cxt_fail.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_failed_to_setup_list_cxt_fail.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void init_context_setup_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (pdu_session_res_failed_to_setup_list_cxt_fail_present) {
    j.write_fieldname("");
    pdu_session_res_failed_to_setup_list_cxt_fail.to_json(j);
  }
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// InitialContextSetupRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t init_context_setup_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10,  85,  48,  110, 18,  28,  71,  0,   119, 94,  108, 36,  117, 31,  34,
                                   38,  24,  91,  118, 146, 33,  165, 177, 199, 205, 206, 209, 216, 215, 218,
                                   217, 219, 222, 234, 238, 254, 264, 326, 328, 334, 335, 345, 346, 347};
  return map_enum_number(names, 44, idx, "id");
}
bool init_context_setup_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10,  85,  48,  110, 18,  28,  71,  0,   119, 94,  108, 36,  117, 31,  34,
                                   38,  24,  91,  118, 146, 33,  165, 177, 199, 205, 206, 209, 216, 215, 218,
                                   217, 219, 222, 234, 238, 254, 264, 326, 328, 334, 335, 345, 346, 347};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e init_context_setup_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 48:
      return crit_e::reject;
    case 110:
      return crit_e::reject;
    case 18:
      return crit_e::ignore;
    case 28:
      return crit_e::reject;
    case 71:
      return crit_e::reject;
    case 0:
      return crit_e::reject;
    case 119:
      return crit_e::reject;
    case 94:
      return crit_e::reject;
    case 108:
      return crit_e::ignore;
    case 36:
      return crit_e::ignore;
    case 117:
      return crit_e::ignore;
    case 31:
      return crit_e::ignore;
    case 34:
      return crit_e::ignore;
    case 38:
      return crit_e::ignore;
    case 24:
      return crit_e::reject;
    case 91:
      return crit_e::ignore;
    case 118:
      return crit_e::ignore;
    case 146:
      return crit_e::ignore;
    case 33:
      return crit_e::ignore;
    case 165:
      return crit_e::ignore;
    case 177:
      return crit_e::ignore;
    case 199:
      return crit_e::ignore;
    case 205:
      return crit_e::ignore;
    case 206:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 216:
      return crit_e::ignore;
    case 215:
      return crit_e::ignore;
    case 218:
      return crit_e::ignore;
    case 217:
      return crit_e::ignore;
    case 219:
      return crit_e::ignore;
    case 222:
      return crit_e::ignore;
    case 234:
      return crit_e::ignore;
    case 238:
      return crit_e::ignore;
    case 254:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    case 326:
      return crit_e::ignore;
    case 328:
      return crit_e::ignore;
    case 334:
      return crit_e::ignore;
    case 335:
      return crit_e::ignore;
    case 345:
      return crit_e::ignore;
    case 346:
      return crit_e::ignore;
    case 347:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
init_context_setup_request_ies_o::value_c init_context_setup_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 48:
      ret.set(value_c::types::old_amf);
      break;
    case 110:
      ret.set(value_c::types::ue_aggr_max_bit_rate);
      break;
    case 18:
      ret.set(value_c::types::core_network_assist_info_for_inactive);
      break;
    case 28:
      ret.set(value_c::types::guami);
      break;
    case 71:
      ret.set(value_c::types::pdu_session_res_setup_list_cxt_req);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 119:
      ret.set(value_c::types::ue_security_cap);
      break;
    case 94:
      ret.set(value_c::types::security_key);
      break;
    case 108:
      ret.set(value_c::types::trace_activation);
      break;
    case 36:
      ret.set(value_c::types::mob_restrict_list);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 31:
      ret.set(value_c::types::idx_to_rfsp);
      break;
    case 34:
      ret.set(value_c::types::masked_imeisv);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 24:
      ret.set(value_c::types::emergency_fallback_ind);
      break;
    case 91:
      ret.set(value_c::types::rrc_inactive_transition_report_request);
      break;
    case 118:
      ret.set(value_c::types::ue_radio_cap_for_paging);
      break;
    case 146:
      ret.set(value_c::types::redirection_voice_fallback);
      break;
    case 33:
      ret.set(value_c::types::location_report_request_type);
      break;
    case 165:
      ret.set(value_c::types::cn_assisted_ran_tuning);
      break;
    case 177:
      ret.set(value_c::types::srvcc_operation_possible);
      break;
    case 199:
      ret.set(value_c::types::iab_authorized);
      break;
    case 205:
      ret.set(value_c::types::enhanced_coverage_restrict);
      break;
    case 206:
      ret.set(value_c::types::extended_connected_time);
      break;
    case 209:
      ret.set(value_c::types::ue_diff_info);
      break;
    case 216:
      ret.set(value_c::types::nr_v2x_services_authorized);
      break;
    case 215:
      ret.set(value_c::types::ltev2x_services_authorized);
      break;
    case 218:
      ret.set(value_c::types::nr_ue_sidelink_aggr_max_bitrate);
      break;
    case 217:
      ret.set(value_c::types::lte_ue_sidelink_aggr_max_bitrate);
      break;
    case 219:
      ret.set(value_c::types::pc5_qos_params);
      break;
    case 222:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 234:
      ret.set(value_c::types::ue_up_c_iot_support);
      break;
    case 238:
      ret.set(value_c::types::rg_level_wireline_access_characteristics);
      break;
    case 254:
      ret.set(value_c::types::management_based_mdt_plmn_list);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 326:
      ret.set(value_c::types::time_sync_assist_info);
      break;
    case 328:
      ret.set(value_c::types::q_mcc_onfig_info);
      break;
    case 334:
      ret.set(value_c::types::target_nssai_info);
      break;
    case 335:
      ret.set(value_c::types::ue_slice_max_bit_rate_list);
      break;
    case 345:
      ret.set(value_c::types::five_g_pro_se_authorized);
      break;
    case 346:
      ret.set(value_c::types::five_g_pro_se_ue_pc5_aggr_max_bit_rate);
      break;
    case 347:
      ret.set(value_c::types::five_g_pro_se_pc5_qos_params);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e init_context_setup_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 48:
      return presence_e::optional;
    case 110:
      return presence_e::conditional;
    case 18:
      return presence_e::optional;
    case 28:
      return presence_e::mandatory;
    case 71:
      return presence_e::optional;
    case 0:
      return presence_e::mandatory;
    case 119:
      return presence_e::mandatory;
    case 94:
      return presence_e::mandatory;
    case 108:
      return presence_e::optional;
    case 36:
      return presence_e::optional;
    case 117:
      return presence_e::optional;
    case 31:
      return presence_e::optional;
    case 34:
      return presence_e::optional;
    case 38:
      return presence_e::optional;
    case 24:
      return presence_e::optional;
    case 91:
      return presence_e::optional;
    case 118:
      return presence_e::optional;
    case 146:
      return presence_e::optional;
    case 33:
      return presence_e::optional;
    case 165:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 199:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 206:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 216:
      return presence_e::optional;
    case 215:
      return presence_e::optional;
    case 218:
      return presence_e::optional;
    case 217:
      return presence_e::optional;
    case 219:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    case 234:
      return presence_e::optional;
    case 238:
      return presence_e::optional;
    case 254:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 326:
      return presence_e::optional;
    case 328:
      return presence_e::optional;
    case 334:
      return presence_e::optional;
    case 335:
      return presence_e::optional;
    case 345:
      return presence_e::optional;
    case 346:
      return presence_e::optional;
    case 347:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void init_context_setup_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::old_amf:
      c.destroy<printable_string<1, 150, true, true>>();
      break;
    case types::ue_aggr_max_bit_rate:
      c.destroy<ue_aggr_max_bit_rate_s>();
      break;
    case types::core_network_assist_info_for_inactive:
      c.destroy<core_network_assist_info_for_inactive_s>();
      break;
    case types::guami:
      c.destroy<guami_s>();
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      c.destroy<pdu_session_res_setup_list_cxt_req_l>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    case types::ue_security_cap:
      c.destroy<ue_security_cap_s>();
      break;
    case types::security_key:
      c.destroy<fixed_bitstring<256, false, true>>();
      break;
    case types::trace_activation:
      c.destroy<trace_activation_s>();
      break;
    case types::mob_restrict_list:
      c.destroy<mob_restrict_list_s>();
      break;
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::masked_imeisv:
      c.destroy<fixed_bitstring<64, false, true>>();
      break;
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::emergency_fallback_ind:
      c.destroy<emergency_fallback_ind_s>();
      break;
    case types::ue_radio_cap_for_paging:
      c.destroy<ue_radio_cap_for_paging_s>();
      break;
    case types::location_report_request_type:
      c.destroy<location_report_request_type_s>();
      break;
    case types::cn_assisted_ran_tuning:
      c.destroy<cn_assisted_ran_tuning_s>();
      break;
    case types::ue_diff_info:
      c.destroy<ue_diff_info_s>();
      break;
    case types::nr_v2x_services_authorized:
      c.destroy<nr_v2x_services_authorized_s>();
      break;
    case types::ltev2x_services_authorized:
      c.destroy<ltev2x_services_authorized_s>();
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.destroy<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.destroy<lte_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::pc5_qos_params:
      c.destroy<pc5_qos_params_s>();
      break;
    case types::rg_level_wireline_access_characteristics:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::management_based_mdt_plmn_list:
      c.destroy<mdt_plmn_list_l>();
      break;
    case types::ue_radio_cap_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::time_sync_assist_info:
      c.destroy<time_sync_assist_info_s>();
      break;
    case types::q_mcc_onfig_info:
      c.destroy<q_mcc_onfig_info_s>();
      break;
    case types::target_nssai_info:
      c.destroy<target_nssai_info_s>();
      break;
    case types::ue_slice_max_bit_rate_list:
      c.destroy<ue_slice_max_bit_rate_list_l>();
      break;
    case types::five_g_pro_se_authorized:
      c.destroy<five_g_pro_se_authorized_s>();
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.destroy<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.destroy<five_g_pro_se_pc5_qos_params_s>();
      break;
    default:
      break;
  }
}
void init_context_setup_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::old_amf:
      c.init<printable_string<1, 150, true, true>>();
      break;
    case types::ue_aggr_max_bit_rate:
      c.init<ue_aggr_max_bit_rate_s>();
      break;
    case types::core_network_assist_info_for_inactive:
      c.init<core_network_assist_info_for_inactive_s>();
      break;
    case types::guami:
      c.init<guami_s>();
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      c.init<pdu_session_res_setup_list_cxt_req_l>();
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::ue_security_cap:
      c.init<ue_security_cap_s>();
      break;
    case types::security_key:
      c.init<fixed_bitstring<256, false, true>>();
      break;
    case types::trace_activation:
      c.init<trace_activation_s>();
      break;
    case types::mob_restrict_list:
      c.init<mob_restrict_list_s>();
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true>>();
      break;
    case types::idx_to_rfsp:
      break;
    case types::masked_imeisv:
      c.init<fixed_bitstring<64, false, true>>();
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::emergency_fallback_ind:
      c.init<emergency_fallback_ind_s>();
      break;
    case types::rrc_inactive_transition_report_request:
      break;
    case types::ue_radio_cap_for_paging:
      c.init<ue_radio_cap_for_paging_s>();
      break;
    case types::redirection_voice_fallback:
      break;
    case types::location_report_request_type:
      c.init<location_report_request_type_s>();
      break;
    case types::cn_assisted_ran_tuning:
      c.init<cn_assisted_ran_tuning_s>();
      break;
    case types::srvcc_operation_possible:
      break;
    case types::iab_authorized:
      break;
    case types::enhanced_coverage_restrict:
      break;
    case types::extended_connected_time:
      break;
    case types::ue_diff_info:
      c.init<ue_diff_info_s>();
      break;
    case types::nr_v2x_services_authorized:
      c.init<nr_v2x_services_authorized_s>();
      break;
    case types::ltev2x_services_authorized:
      c.init<ltev2x_services_authorized_s>();
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.init<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.init<lte_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::pc5_qos_params:
      c.init<pc5_qos_params_s>();
      break;
    case types::ce_mode_brestricted:
      break;
    case types::ue_up_c_iot_support:
      break;
    case types::rg_level_wireline_access_characteristics:
      c.init<unbounded_octstring<true>>();
      break;
    case types::management_based_mdt_plmn_list:
      c.init<mdt_plmn_list_l>();
      break;
    case types::ue_radio_cap_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::time_sync_assist_info:
      c.init<time_sync_assist_info_s>();
      break;
    case types::q_mcc_onfig_info:
      c.init<q_mcc_onfig_info_s>();
      break;
    case types::target_nssai_info:
      c.init<target_nssai_info_s>();
      break;
    case types::ue_slice_max_bit_rate_list:
      c.init<ue_slice_max_bit_rate_list_l>();
      break;
    case types::five_g_pro_se_authorized:
      c.init<five_g_pro_se_authorized_s>();
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.init<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.init<five_g_pro_se_pc5_qos_params_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
  }
}
init_context_setup_request_ies_o::value_c::value_c(const init_context_setup_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::old_amf:
      c.init(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.init(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::core_network_assist_info_for_inactive:
      c.init(other.c.get<core_network_assist_info_for_inactive_s>());
      break;
    case types::guami:
      c.init(other.c.get<guami_s>());
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      c.init(other.c.get<pdu_session_res_setup_list_cxt_req_l>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::ue_security_cap:
      c.init(other.c.get<ue_security_cap_s>());
      break;
    case types::security_key:
      c.init(other.c.get<fixed_bitstring<256, false, true>>());
      break;
    case types::trace_activation:
      c.init(other.c.get<trace_activation_s>());
      break;
    case types::mob_restrict_list:
      c.init(other.c.get<mob_restrict_list_s>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::idx_to_rfsp:
      c.init(other.c.get<uint16_t>());
      break;
    case types::masked_imeisv:
      c.init(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::emergency_fallback_ind:
      c.init(other.c.get<emergency_fallback_ind_s>());
      break;
    case types::rrc_inactive_transition_report_request:
      c.init(other.c.get<rrc_inactive_transition_report_request_e>());
      break;
    case types::ue_radio_cap_for_paging:
      c.init(other.c.get<ue_radio_cap_for_paging_s>());
      break;
    case types::redirection_voice_fallback:
      c.init(other.c.get<redirection_voice_fallback_e>());
      break;
    case types::location_report_request_type:
      c.init(other.c.get<location_report_request_type_s>());
      break;
    case types::cn_assisted_ran_tuning:
      c.init(other.c.get<cn_assisted_ran_tuning_s>());
      break;
    case types::srvcc_operation_possible:
      c.init(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::iab_authorized:
      c.init(other.c.get<iab_authorized_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.init(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::extended_connected_time:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      c.init(other.c.get<ue_diff_info_s>());
      break;
    case types::nr_v2x_services_authorized:
      c.init(other.c.get<nr_v2x_services_authorized_s>());
      break;
    case types::ltev2x_services_authorized:
      c.init(other.c.get<ltev2x_services_authorized_s>());
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.init(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.init(other.c.get<lte_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::pc5_qos_params:
      c.init(other.c.get<pc5_qos_params_s>());
      break;
    case types::ce_mode_brestricted:
      c.init(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_up_c_iot_support:
      c.init(other.c.get<ue_up_c_iot_support_e>());
      break;
    case types::rg_level_wireline_access_characteristics:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::management_based_mdt_plmn_list:
      c.init(other.c.get<mdt_plmn_list_l>());
      break;
    case types::ue_radio_cap_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::time_sync_assist_info:
      c.init(other.c.get<time_sync_assist_info_s>());
      break;
    case types::q_mcc_onfig_info:
      c.init(other.c.get<q_mcc_onfig_info_s>());
      break;
    case types::target_nssai_info:
      c.init(other.c.get<target_nssai_info_s>());
      break;
    case types::ue_slice_max_bit_rate_list:
      c.init(other.c.get<ue_slice_max_bit_rate_list_l>());
      break;
    case types::five_g_pro_se_authorized:
      c.init(other.c.get<five_g_pro_se_authorized_s>());
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.init(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.init(other.c.get<five_g_pro_se_pc5_qos_params_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
  }
}
init_context_setup_request_ies_o::value_c&
init_context_setup_request_ies_o::value_c::operator=(const init_context_setup_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::old_amf:
      c.set(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.set(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::core_network_assist_info_for_inactive:
      c.set(other.c.get<core_network_assist_info_for_inactive_s>());
      break;
    case types::guami:
      c.set(other.c.get<guami_s>());
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      c.set(other.c.get<pdu_session_res_setup_list_cxt_req_l>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::ue_security_cap:
      c.set(other.c.get<ue_security_cap_s>());
      break;
    case types::security_key:
      c.set(other.c.get<fixed_bitstring<256, false, true>>());
      break;
    case types::trace_activation:
      c.set(other.c.get<trace_activation_s>());
      break;
    case types::mob_restrict_list:
      c.set(other.c.get<mob_restrict_list_s>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::idx_to_rfsp:
      c.set(other.c.get<uint16_t>());
      break;
    case types::masked_imeisv:
      c.set(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::emergency_fallback_ind:
      c.set(other.c.get<emergency_fallback_ind_s>());
      break;
    case types::rrc_inactive_transition_report_request:
      c.set(other.c.get<rrc_inactive_transition_report_request_e>());
      break;
    case types::ue_radio_cap_for_paging:
      c.set(other.c.get<ue_radio_cap_for_paging_s>());
      break;
    case types::redirection_voice_fallback:
      c.set(other.c.get<redirection_voice_fallback_e>());
      break;
    case types::location_report_request_type:
      c.set(other.c.get<location_report_request_type_s>());
      break;
    case types::cn_assisted_ran_tuning:
      c.set(other.c.get<cn_assisted_ran_tuning_s>());
      break;
    case types::srvcc_operation_possible:
      c.set(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::iab_authorized:
      c.set(other.c.get<iab_authorized_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.set(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::extended_connected_time:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      c.set(other.c.get<ue_diff_info_s>());
      break;
    case types::nr_v2x_services_authorized:
      c.set(other.c.get<nr_v2x_services_authorized_s>());
      break;
    case types::ltev2x_services_authorized:
      c.set(other.c.get<ltev2x_services_authorized_s>());
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.set(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.set(other.c.get<lte_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::pc5_qos_params:
      c.set(other.c.get<pc5_qos_params_s>());
      break;
    case types::ce_mode_brestricted:
      c.set(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_up_c_iot_support:
      c.set(other.c.get<ue_up_c_iot_support_e>());
      break;
    case types::rg_level_wireline_access_characteristics:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::management_based_mdt_plmn_list:
      c.set(other.c.get<mdt_plmn_list_l>());
      break;
    case types::ue_radio_cap_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::time_sync_assist_info:
      c.set(other.c.get<time_sync_assist_info_s>());
      break;
    case types::q_mcc_onfig_info:
      c.set(other.c.get<q_mcc_onfig_info_s>());
      break;
    case types::target_nssai_info:
      c.set(other.c.get<target_nssai_info_s>());
      break;
    case types::ue_slice_max_bit_rate_list:
      c.set(other.c.get<ue_slice_max_bit_rate_list_l>());
      break;
    case types::five_g_pro_se_authorized:
      c.set(other.c.get<five_g_pro_se_authorized_s>());
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.set(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.set(other.c.get<five_g_pro_se_pc5_qos_params_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& init_context_setup_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& init_context_setup_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
printable_string<1, 150, true, true>& init_context_setup_request_ies_o::value_c::old_amf()
{
  assert_choice_type(types::old_amf, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
ue_aggr_max_bit_rate_s& init_context_setup_request_ies_o::value_c::ue_aggr_max_bit_rate()
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
core_network_assist_info_for_inactive_s&
init_context_setup_request_ies_o::value_c::core_network_assist_info_for_inactive()
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
guami_s& init_context_setup_request_ies_o::value_c::guami()
{
  assert_choice_type(types::guami, type_, "Value");
  return c.get<guami_s>();
}
pdu_session_res_setup_list_cxt_req_l& init_context_setup_request_ies_o::value_c::pdu_session_res_setup_list_cxt_req()
{
  assert_choice_type(types::pdu_session_res_setup_list_cxt_req, type_, "Value");
  return c.get<pdu_session_res_setup_list_cxt_req_l>();
}
allowed_nssai_l& init_context_setup_request_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
ue_security_cap_s& init_context_setup_request_ies_o::value_c::ue_security_cap()
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
fixed_bitstring<256, false, true>& init_context_setup_request_ies_o::value_c::security_key()
{
  assert_choice_type(types::security_key, type_, "Value");
  return c.get<fixed_bitstring<256, false, true>>();
}
trace_activation_s& init_context_setup_request_ies_o::value_c::trace_activation()
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
mob_restrict_list_s& init_context_setup_request_ies_o::value_c::mob_restrict_list()
{
  assert_choice_type(types::mob_restrict_list, type_, "Value");
  return c.get<mob_restrict_list_s>();
}
unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
uint16_t& init_context_setup_request_ies_o::value_c::idx_to_rfsp()
{
  assert_choice_type(types::idx_to_rfsp, type_, "Value");
  return c.get<uint16_t>();
}
fixed_bitstring<64, false, true>& init_context_setup_request_ies_o::value_c::masked_imeisv()
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
emergency_fallback_ind_s& init_context_setup_request_ies_o::value_c::emergency_fallback_ind()
{
  assert_choice_type(types::emergency_fallback_ind, type_, "Value");
  return c.get<emergency_fallback_ind_s>();
}
rrc_inactive_transition_report_request_e&
init_context_setup_request_ies_o::value_c::rrc_inactive_transition_report_request()
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
ue_radio_cap_for_paging_s& init_context_setup_request_ies_o::value_c::ue_radio_cap_for_paging()
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<ue_radio_cap_for_paging_s>();
}
redirection_voice_fallback_e& init_context_setup_request_ies_o::value_c::redirection_voice_fallback()
{
  assert_choice_type(types::redirection_voice_fallback, type_, "Value");
  return c.get<redirection_voice_fallback_e>();
}
location_report_request_type_s& init_context_setup_request_ies_o::value_c::location_report_request_type()
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
cn_assisted_ran_tuning_s& init_context_setup_request_ies_o::value_c::cn_assisted_ran_tuning()
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
srvcc_operation_possible_e& init_context_setup_request_ies_o::value_c::srvcc_operation_possible()
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
iab_authorized_e& init_context_setup_request_ies_o::value_c::iab_authorized()
{
  assert_choice_type(types::iab_authorized, type_, "Value");
  return c.get<iab_authorized_e>();
}
enhanced_coverage_restrict_e& init_context_setup_request_ies_o::value_c::enhanced_coverage_restrict()
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
uint16_t& init_context_setup_request_ies_o::value_c::extended_connected_time()
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
ue_diff_info_s& init_context_setup_request_ies_o::value_c::ue_diff_info()
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
nr_v2x_services_authorized_s& init_context_setup_request_ies_o::value_c::nr_v2x_services_authorized()
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
ltev2x_services_authorized_s& init_context_setup_request_ies_o::value_c::ltev2x_services_authorized()
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& init_context_setup_request_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
lte_ue_sidelink_aggr_max_bitrate_s& init_context_setup_request_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
pc5_qos_params_s& init_context_setup_request_ies_o::value_c::pc5_qos_params()
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
ce_mode_brestricted_e& init_context_setup_request_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
ue_up_c_iot_support_e& init_context_setup_request_ies_o::value_c::ue_up_c_iot_support()
{
  assert_choice_type(types::ue_up_c_iot_support, type_, "Value");
  return c.get<ue_up_c_iot_support_e>();
}
unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::rg_level_wireline_access_characteristics()
{
  assert_choice_type(types::rg_level_wireline_access_characteristics, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
mdt_plmn_list_l& init_context_setup_request_ies_o::value_c::management_based_mdt_plmn_list()
{
  assert_choice_type(types::management_based_mdt_plmn_list, type_, "Value");
  return c.get<mdt_plmn_list_l>();
}
unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
time_sync_assist_info_s& init_context_setup_request_ies_o::value_c::time_sync_assist_info()
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
q_mcc_onfig_info_s& init_context_setup_request_ies_o::value_c::q_mcc_onfig_info()
{
  assert_choice_type(types::q_mcc_onfig_info, type_, "Value");
  return c.get<q_mcc_onfig_info_s>();
}
target_nssai_info_s& init_context_setup_request_ies_o::value_c::target_nssai_info()
{
  assert_choice_type(types::target_nssai_info, type_, "Value");
  return c.get<target_nssai_info_s>();
}
ue_slice_max_bit_rate_list_l& init_context_setup_request_ies_o::value_c::ue_slice_max_bit_rate_list()
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
five_g_pro_se_authorized_s& init_context_setup_request_ies_o::value_c::five_g_pro_se_authorized()
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& init_context_setup_request_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate()
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
five_g_pro_se_pc5_qos_params_s& init_context_setup_request_ies_o::value_c::five_g_pro_se_pc5_qos_params()
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
const uint64_t& init_context_setup_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& init_context_setup_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const printable_string<1, 150, true, true>& init_context_setup_request_ies_o::value_c::old_amf() const
{
  assert_choice_type(types::old_amf, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
const ue_aggr_max_bit_rate_s& init_context_setup_request_ies_o::value_c::ue_aggr_max_bit_rate() const
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
const core_network_assist_info_for_inactive_s&
init_context_setup_request_ies_o::value_c::core_network_assist_info_for_inactive() const
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
const guami_s& init_context_setup_request_ies_o::value_c::guami() const
{
  assert_choice_type(types::guami, type_, "Value");
  return c.get<guami_s>();
}
const pdu_session_res_setup_list_cxt_req_l&
init_context_setup_request_ies_o::value_c::pdu_session_res_setup_list_cxt_req() const
{
  assert_choice_type(types::pdu_session_res_setup_list_cxt_req, type_, "Value");
  return c.get<pdu_session_res_setup_list_cxt_req_l>();
}
const allowed_nssai_l& init_context_setup_request_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const ue_security_cap_s& init_context_setup_request_ies_o::value_c::ue_security_cap() const
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
const fixed_bitstring<256, false, true>& init_context_setup_request_ies_o::value_c::security_key() const
{
  assert_choice_type(types::security_key, type_, "Value");
  return c.get<fixed_bitstring<256, false, true>>();
}
const trace_activation_s& init_context_setup_request_ies_o::value_c::trace_activation() const
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
const mob_restrict_list_s& init_context_setup_request_ies_o::value_c::mob_restrict_list() const
{
  assert_choice_type(types::mob_restrict_list, type_, "Value");
  return c.get<mob_restrict_list_s>();
}
const unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint16_t& init_context_setup_request_ies_o::value_c::idx_to_rfsp() const
{
  assert_choice_type(types::idx_to_rfsp, type_, "Value");
  return c.get<uint16_t>();
}
const fixed_bitstring<64, false, true>& init_context_setup_request_ies_o::value_c::masked_imeisv() const
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
const unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const emergency_fallback_ind_s& init_context_setup_request_ies_o::value_c::emergency_fallback_ind() const
{
  assert_choice_type(types::emergency_fallback_ind, type_, "Value");
  return c.get<emergency_fallback_ind_s>();
}
const rrc_inactive_transition_report_request_e&
init_context_setup_request_ies_o::value_c::rrc_inactive_transition_report_request() const
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
const ue_radio_cap_for_paging_s& init_context_setup_request_ies_o::value_c::ue_radio_cap_for_paging() const
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<ue_radio_cap_for_paging_s>();
}
const redirection_voice_fallback_e& init_context_setup_request_ies_o::value_c::redirection_voice_fallback() const
{
  assert_choice_type(types::redirection_voice_fallback, type_, "Value");
  return c.get<redirection_voice_fallback_e>();
}
const location_report_request_type_s& init_context_setup_request_ies_o::value_c::location_report_request_type() const
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
const cn_assisted_ran_tuning_s& init_context_setup_request_ies_o::value_c::cn_assisted_ran_tuning() const
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
const srvcc_operation_possible_e& init_context_setup_request_ies_o::value_c::srvcc_operation_possible() const
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
const iab_authorized_e& init_context_setup_request_ies_o::value_c::iab_authorized() const
{
  assert_choice_type(types::iab_authorized, type_, "Value");
  return c.get<iab_authorized_e>();
}
const enhanced_coverage_restrict_e& init_context_setup_request_ies_o::value_c::enhanced_coverage_restrict() const
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
const uint16_t& init_context_setup_request_ies_o::value_c::extended_connected_time() const
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
const ue_diff_info_s& init_context_setup_request_ies_o::value_c::ue_diff_info() const
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
const nr_v2x_services_authorized_s& init_context_setup_request_ies_o::value_c::nr_v2x_services_authorized() const
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
const ltev2x_services_authorized_s& init_context_setup_request_ies_o::value_c::ltev2x_services_authorized() const
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s&
init_context_setup_request_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const lte_ue_sidelink_aggr_max_bitrate_s&
init_context_setup_request_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
const pc5_qos_params_s& init_context_setup_request_ies_o::value_c::pc5_qos_params() const
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
const ce_mode_brestricted_e& init_context_setup_request_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const ue_up_c_iot_support_e& init_context_setup_request_ies_o::value_c::ue_up_c_iot_support() const
{
  assert_choice_type(types::ue_up_c_iot_support, type_, "Value");
  return c.get<ue_up_c_iot_support_e>();
}
const unbounded_octstring<true>&
init_context_setup_request_ies_o::value_c::rg_level_wireline_access_characteristics() const
{
  assert_choice_type(types::rg_level_wireline_access_characteristics, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mdt_plmn_list_l& init_context_setup_request_ies_o::value_c::management_based_mdt_plmn_list() const
{
  assert_choice_type(types::management_based_mdt_plmn_list, type_, "Value");
  return c.get<mdt_plmn_list_l>();
}
const unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const time_sync_assist_info_s& init_context_setup_request_ies_o::value_c::time_sync_assist_info() const
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
const q_mcc_onfig_info_s& init_context_setup_request_ies_o::value_c::q_mcc_onfig_info() const
{
  assert_choice_type(types::q_mcc_onfig_info, type_, "Value");
  return c.get<q_mcc_onfig_info_s>();
}
const target_nssai_info_s& init_context_setup_request_ies_o::value_c::target_nssai_info() const
{
  assert_choice_type(types::target_nssai_info, type_, "Value");
  return c.get<target_nssai_info_s>();
}
const ue_slice_max_bit_rate_list_l& init_context_setup_request_ies_o::value_c::ue_slice_max_bit_rate_list() const
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
const five_g_pro_se_authorized_s& init_context_setup_request_ies_o::value_c::five_g_pro_se_authorized() const
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s&
init_context_setup_request_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate() const
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const five_g_pro_se_pc5_qos_params_s& init_context_setup_request_ies_o::value_c::five_g_pro_se_pc5_qos_params() const
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
void init_context_setup_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::old_amf:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true>>().to_string());
      break;
    case types::ue_aggr_max_bit_rate:
      j.write_fieldname("UEAggregateMaximumBitRate");
      c.get<ue_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::core_network_assist_info_for_inactive:
      j.write_fieldname("CoreNetworkAssistanceInformationForInactive");
      c.get<core_network_assist_info_for_inactive_s>().to_json(j);
      break;
    case types::guami:
      j.write_fieldname("GUAMI");
      c.get<guami_s>().to_json(j);
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      j.start_array("PDUSessionResourceSetupListCxtReq");
      for (const auto& e1 : c.get<pdu_session_res_setup_list_cxt_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ue_security_cap:
      j.write_fieldname("UESecurityCapabilities");
      c.get<ue_security_cap_s>().to_json(j);
      break;
    case types::security_key:
      j.write_str("BIT STRING", c.get<fixed_bitstring<256, false, true>>().to_string());
      break;
    case types::trace_activation:
      j.write_fieldname("TraceActivation");
      c.get<trace_activation_s>().to_json(j);
      break;
    case types::mob_restrict_list:
      j.write_fieldname("MobilityRestrictionList");
      c.get<mob_restrict_list_s>().to_json(j);
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::idx_to_rfsp:
      j.write_int("INTEGER (1..256,...)", c.get<uint16_t>());
      break;
    case types::masked_imeisv:
      j.write_str("BIT STRING", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::emergency_fallback_ind:
      j.write_fieldname("EmergencyFallbackIndicator");
      c.get<emergency_fallback_ind_s>().to_json(j);
      break;
    case types::rrc_inactive_transition_report_request:
      j.write_str("RRCInactiveTransitionReportRequest", c.get<rrc_inactive_transition_report_request_e>().to_string());
      break;
    case types::ue_radio_cap_for_paging:
      j.write_fieldname("UERadioCapabilityForPaging");
      c.get<ue_radio_cap_for_paging_s>().to_json(j);
      break;
    case types::redirection_voice_fallback:
      j.write_str("RedirectionVoiceFallback", c.get<redirection_voice_fallback_e>().to_string());
      break;
    case types::location_report_request_type:
      j.write_fieldname("LocationReportingRequestType");
      c.get<location_report_request_type_s>().to_json(j);
      break;
    case types::cn_assisted_ran_tuning:
      j.write_fieldname("CNAssistedRANTuning");
      c.get<cn_assisted_ran_tuning_s>().to_json(j);
      break;
    case types::srvcc_operation_possible:
      j.write_str("SRVCCOperationPossible", c.get<srvcc_operation_possible_e>().to_string());
      break;
    case types::iab_authorized:
      j.write_str("IAB-Authorized", c.get<iab_authorized_e>().to_string());
      break;
    case types::enhanced_coverage_restrict:
      j.write_str("Enhanced-CoverageRestriction", "restricted");
      break;
    case types::extended_connected_time:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      j.write_fieldname("UE-DifferentiationInfo");
      c.get<ue_diff_info_s>().to_json(j);
      break;
    case types::nr_v2x_services_authorized:
      j.write_fieldname("NRV2XServicesAuthorized");
      c.get<nr_v2x_services_authorized_s>().to_json(j);
      break;
    case types::ltev2x_services_authorized:
      j.write_fieldname("LTEV2XServicesAuthorized");
      c.get<ltev2x_services_authorized_s>().to_json(j);
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("LTEUESidelinkAggregateMaximumBitrate");
      c.get<lte_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::pc5_qos_params:
      j.write_fieldname("PC5QoSParameters");
      c.get<pc5_qos_params_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CEmodeBrestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::ue_up_c_iot_support:
      j.write_str("UE-UP-CIoT-Support", "supported");
      break;
    case types::rg_level_wireline_access_characteristics:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::management_based_mdt_plmn_list:
      j.start_array("MDTPLMNList");
      for (const auto& e1 : c.get<mdt_plmn_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::time_sync_assist_info:
      j.write_fieldname("TimeSyncAssistanceInfo");
      c.get<time_sync_assist_info_s>().to_json(j);
      break;
    case types::q_mcc_onfig_info:
      j.write_fieldname("QMCConfigInfo");
      c.get<q_mcc_onfig_info_s>().to_json(j);
      break;
    case types::target_nssai_info:
      j.write_fieldname("TargetNSSAIInformation");
      c.get<target_nssai_info_s>().to_json(j);
      break;
    case types::ue_slice_max_bit_rate_list:
      j.start_array("UESliceMaximumBitRateList");
      for (const auto& e1 : c.get<ue_slice_max_bit_rate_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::five_g_pro_se_authorized:
      j.write_fieldname("FiveG-ProSeAuthorized");
      c.get<five_g_pro_se_authorized_s>().to_json(j);
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::five_g_pro_se_pc5_qos_params:
      j.write_fieldname("FiveG-ProSePC5QoSParameters");
      c.get<five_g_pro_se_pc5_qos_params_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE init_context_setup_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::old_amf:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().pack(bref)));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().pack(bref));
      break;
    case types::guami:
      HANDLE_CODE(c.get<guami_s>().pack(bref));
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_setup_list_cxt_req_l>(), 1, 256, true));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().pack(bref));
      break;
    case types::security_key:
      HANDLE_CODE((c.get<fixed_bitstring<256, false, true>>().pack(bref)));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().pack(bref));
      break;
    case types::mob_restrict_list:
      HANDLE_CODE(c.get<mob_restrict_list_s>().pack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::idx_to_rfsp:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::emergency_fallback_ind:
      HANDLE_CODE(c.get<emergency_fallback_ind_s>().pack(bref));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().pack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().pack(bref));
      break;
    case types::redirection_voice_fallback:
      HANDLE_CODE(c.get<redirection_voice_fallback_e>().pack(bref));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().pack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().pack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().pack(bref));
      break;
    case types::iab_authorized:
      HANDLE_CODE(c.get<iab_authorized_e>().pack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().pack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().pack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().pack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().pack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::ue_up_c_iot_support:
      HANDLE_CODE(c.get<ue_up_c_iot_support_e>().pack(bref));
      break;
    case types::rg_level_wireline_access_characteristics:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::management_based_mdt_plmn_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mdt_plmn_list_l>(), 1, 16, true));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().pack(bref));
      break;
    case types::q_mcc_onfig_info:
      HANDLE_CODE(c.get<q_mcc_onfig_info_s>().pack(bref));
      break;
    case types::target_nssai_info:
      HANDLE_CODE(c.get<target_nssai_info_s>().pack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_slice_max_bit_rate_list_l>(), 1, 8, true));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().pack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::old_amf:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().unpack(bref)));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().unpack(bref));
      break;
    case types::guami:
      HANDLE_CODE(c.get<guami_s>().unpack(bref));
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_setup_list_cxt_req_l>(), bref, 1, 256, true));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().unpack(bref));
      break;
    case types::security_key:
      HANDLE_CODE((c.get<fixed_bitstring<256, false, true>>().unpack(bref)));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().unpack(bref));
      break;
    case types::mob_restrict_list:
      HANDLE_CODE(c.get<mob_restrict_list_s>().unpack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::idx_to_rfsp:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::emergency_fallback_ind:
      HANDLE_CODE(c.get<emergency_fallback_ind_s>().unpack(bref));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().unpack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().unpack(bref));
      break;
    case types::redirection_voice_fallback:
      HANDLE_CODE(c.get<redirection_voice_fallback_e>().unpack(bref));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().unpack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().unpack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().unpack(bref));
      break;
    case types::iab_authorized:
      HANDLE_CODE(c.get<iab_authorized_e>().unpack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().unpack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().unpack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().unpack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().unpack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::ue_up_c_iot_support:
      HANDLE_CODE(c.get<ue_up_c_iot_support_e>().unpack(bref));
      break;
    case types::rg_level_wireline_access_characteristics:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::management_based_mdt_plmn_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mdt_plmn_list_l>(), bref, 1, 16, true));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().unpack(bref));
      break;
    case types::q_mcc_onfig_info:
      HANDLE_CODE(c.get<q_mcc_onfig_info_s>().unpack(bref));
      break;
    case types::target_nssai_info:
      HANDLE_CODE(c.get<target_nssai_info_s>().unpack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_slice_max_bit_rate_list_l>(), bref, 1, 8, true));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().unpack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

init_context_setup_request_ies_container::init_context_setup_request_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  old_amf(48, crit_e::reject),
  ue_aggr_max_bit_rate(110, crit_e::reject),
  core_network_assist_info_for_inactive(18, crit_e::ignore),
  guami(28, crit_e::reject),
  pdu_session_res_setup_list_cxt_req(71, crit_e::reject),
  allowed_nssai(0, crit_e::reject),
  ue_security_cap(119, crit_e::reject),
  security_key(94, crit_e::reject),
  trace_activation(108, crit_e::ignore),
  mob_restrict_list(36, crit_e::ignore),
  ue_radio_cap(117, crit_e::ignore),
  idx_to_rfsp(31, crit_e::ignore),
  masked_imeisv(34, crit_e::ignore),
  nas_pdu(38, crit_e::ignore),
  emergency_fallback_ind(24, crit_e::reject),
  rrc_inactive_transition_report_request(91, crit_e::ignore),
  ue_radio_cap_for_paging(118, crit_e::ignore),
  redirection_voice_fallback(146, crit_e::ignore),
  location_report_request_type(33, crit_e::ignore),
  cn_assisted_ran_tuning(165, crit_e::ignore),
  srvcc_operation_possible(177, crit_e::ignore),
  iab_authorized(199, crit_e::ignore),
  enhanced_coverage_restrict(205, crit_e::ignore),
  extended_connected_time(206, crit_e::ignore),
  ue_diff_info(209, crit_e::ignore),
  nr_v2x_services_authorized(216, crit_e::ignore),
  ltev2x_services_authorized(215, crit_e::ignore),
  nr_ue_sidelink_aggr_max_bitrate(218, crit_e::ignore),
  lte_ue_sidelink_aggr_max_bitrate(217, crit_e::ignore),
  pc5_qos_params(219, crit_e::ignore),
  ce_mode_brestricted(222, crit_e::ignore),
  ue_up_c_iot_support(234, crit_e::ignore),
  rg_level_wireline_access_characteristics(238, crit_e::ignore),
  management_based_mdt_plmn_list(254, crit_e::ignore),
  ue_radio_cap_id(264, crit_e::reject),
  time_sync_assist_info(326, crit_e::ignore),
  q_mcc_onfig_info(328, crit_e::ignore),
  target_nssai_info(334, crit_e::ignore),
  ue_slice_max_bit_rate_list(335, crit_e::ignore),
  five_g_pro_se_authorized(345, crit_e::ignore),
  five_g_pro_se_ue_pc5_aggr_max_bit_rate(346, crit_e::ignore),
  five_g_pro_se_pc5_qos_params(347, crit_e::ignore)
{
}
SRSASN_CODE init_context_setup_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 6;
  nof_ies += old_amf_present ? 1 : 0;
  nof_ies += ue_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += core_network_assist_info_for_inactive_present ? 1 : 0;
  nof_ies += pdu_session_res_setup_list_cxt_req_present ? 1 : 0;
  nof_ies += trace_activation_present ? 1 : 0;
  nof_ies += mob_restrict_list_present ? 1 : 0;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  nof_ies += idx_to_rfsp_present ? 1 : 0;
  nof_ies += masked_imeisv_present ? 1 : 0;
  nof_ies += nas_pdu_present ? 1 : 0;
  nof_ies += emergency_fallback_ind_present ? 1 : 0;
  nof_ies += rrc_inactive_transition_report_request_present ? 1 : 0;
  nof_ies += ue_radio_cap_for_paging_present ? 1 : 0;
  nof_ies += redirection_voice_fallback_present ? 1 : 0;
  nof_ies += location_report_request_type_present ? 1 : 0;
  nof_ies += cn_assisted_ran_tuning_present ? 1 : 0;
  nof_ies += srvcc_operation_possible_present ? 1 : 0;
  nof_ies += iab_authorized_present ? 1 : 0;
  nof_ies += enhanced_coverage_restrict_present ? 1 : 0;
  nof_ies += extended_connected_time_present ? 1 : 0;
  nof_ies += ue_diff_info_present ? 1 : 0;
  nof_ies += nr_v2x_services_authorized_present ? 1 : 0;
  nof_ies += ltev2x_services_authorized_present ? 1 : 0;
  nof_ies += nr_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += lte_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += pc5_qos_params_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += ue_up_c_iot_support_present ? 1 : 0;
  nof_ies += rg_level_wireline_access_characteristics_present ? 1 : 0;
  nof_ies += management_based_mdt_plmn_list_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += time_sync_assist_info_present ? 1 : 0;
  nof_ies += q_mcc_onfig_info_present ? 1 : 0;
  nof_ies += target_nssai_info_present ? 1 : 0;
  nof_ies += ue_slice_max_bit_rate_list_present ? 1 : 0;
  nof_ies += five_g_pro_se_authorized_present ? 1 : 0;
  nof_ies += five_g_pro_se_ue_pc5_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += five_g_pro_se_pc5_qos_params_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (old_amf_present) {
    HANDLE_CODE(old_amf.pack(bref));
  }
  if (ue_aggr_max_bit_rate_present) {
    HANDLE_CODE(ue_aggr_max_bit_rate.pack(bref));
  }
  if (core_network_assist_info_for_inactive_present) {
    HANDLE_CODE(core_network_assist_info_for_inactive.pack(bref));
  }
  HANDLE_CODE(guami.pack(bref));
  if (pdu_session_res_setup_list_cxt_req_present) {
    HANDLE_CODE(pdu_session_res_setup_list_cxt_req.pack(bref));
  }
  HANDLE_CODE(allowed_nssai.pack(bref));
  HANDLE_CODE(ue_security_cap.pack(bref));
  HANDLE_CODE(security_key.pack(bref));
  if (trace_activation_present) {
    HANDLE_CODE(trace_activation.pack(bref));
  }
  if (mob_restrict_list_present) {
    HANDLE_CODE(mob_restrict_list.pack(bref));
  }
  if (ue_radio_cap_present) {
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (idx_to_rfsp_present) {
    HANDLE_CODE(idx_to_rfsp.pack(bref));
  }
  if (masked_imeisv_present) {
    HANDLE_CODE(masked_imeisv.pack(bref));
  }
  if (nas_pdu_present) {
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  if (emergency_fallback_ind_present) {
    HANDLE_CODE(emergency_fallback_ind.pack(bref));
  }
  if (rrc_inactive_transition_report_request_present) {
    HANDLE_CODE(rrc_inactive_transition_report_request.pack(bref));
  }
  if (ue_radio_cap_for_paging_present) {
    HANDLE_CODE(ue_radio_cap_for_paging.pack(bref));
  }
  if (redirection_voice_fallback_present) {
    HANDLE_CODE(redirection_voice_fallback.pack(bref));
  }
  if (location_report_request_type_present) {
    HANDLE_CODE(location_report_request_type.pack(bref));
  }
  if (cn_assisted_ran_tuning_present) {
    HANDLE_CODE(cn_assisted_ran_tuning.pack(bref));
  }
  if (srvcc_operation_possible_present) {
    HANDLE_CODE(srvcc_operation_possible.pack(bref));
  }
  if (iab_authorized_present) {
    HANDLE_CODE(iab_authorized.pack(bref));
  }
  if (enhanced_coverage_restrict_present) {
    HANDLE_CODE(enhanced_coverage_restrict.pack(bref));
  }
  if (extended_connected_time_present) {
    HANDLE_CODE(extended_connected_time.pack(bref));
  }
  if (ue_diff_info_present) {
    HANDLE_CODE(ue_diff_info.pack(bref));
  }
  if (nr_v2x_services_authorized_present) {
    HANDLE_CODE(nr_v2x_services_authorized.pack(bref));
  }
  if (ltev2x_services_authorized_present) {
    HANDLE_CODE(ltev2x_services_authorized.pack(bref));
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (pc5_qos_params_present) {
    HANDLE_CODE(pc5_qos_params.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (ue_up_c_iot_support_present) {
    HANDLE_CODE(ue_up_c_iot_support.pack(bref));
  }
  if (rg_level_wireline_access_characteristics_present) {
    HANDLE_CODE(rg_level_wireline_access_characteristics.pack(bref));
  }
  if (management_based_mdt_plmn_list_present) {
    HANDLE_CODE(management_based_mdt_plmn_list.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (time_sync_assist_info_present) {
    HANDLE_CODE(time_sync_assist_info.pack(bref));
  }
  if (q_mcc_onfig_info_present) {
    HANDLE_CODE(q_mcc_onfig_info.pack(bref));
  }
  if (target_nssai_info_present) {
    HANDLE_CODE(target_nssai_info.pack(bref));
  }
  if (ue_slice_max_bit_rate_list_present) {
    HANDLE_CODE(ue_slice_max_bit_rate_list.pack(bref));
  }
  if (five_g_pro_se_authorized_present) {
    HANDLE_CODE(five_g_pro_se_authorized.pack(bref));
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.pack(bref));
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    HANDLE_CODE(five_g_pro_se_pc5_qos_params.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 6;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 48: {
        old_amf_present = true;
        old_amf.id      = id;
        HANDLE_CODE(old_amf.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(old_amf.value.unpack(bref));
        break;
      }
      case 110: {
        ue_aggr_max_bit_rate_present = true;
        ue_aggr_max_bit_rate.id      = id;
        HANDLE_CODE(ue_aggr_max_bit_rate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_aggr_max_bit_rate.value.unpack(bref));
        break;
      }
      case 18: {
        core_network_assist_info_for_inactive_present = true;
        core_network_assist_info_for_inactive.id      = id;
        HANDLE_CODE(core_network_assist_info_for_inactive.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(core_network_assist_info_for_inactive.value.unpack(bref));
        break;
      }
      case 28: {
        nof_mandatory_ies--;
        guami.id = id;
        HANDLE_CODE(guami.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(guami.value.unpack(bref));
        break;
      }
      case 71: {
        pdu_session_res_setup_list_cxt_req_present = true;
        pdu_session_res_setup_list_cxt_req.id      = id;
        HANDLE_CODE(pdu_session_res_setup_list_cxt_req.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_setup_list_cxt_req.value.unpack(bref));
        break;
      }
      case 0: {
        nof_mandatory_ies--;
        allowed_nssai.id = id;
        HANDLE_CODE(allowed_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(allowed_nssai.value.unpack(bref));
        break;
      }
      case 119: {
        nof_mandatory_ies--;
        ue_security_cap.id = id;
        HANDLE_CODE(ue_security_cap.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_security_cap.value.unpack(bref));
        break;
      }
      case 94: {
        nof_mandatory_ies--;
        security_key.id = id;
        HANDLE_CODE(security_key.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_key.value.unpack(bref));
        break;
      }
      case 108: {
        trace_activation_present = true;
        trace_activation.id      = id;
        HANDLE_CODE(trace_activation.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trace_activation.value.unpack(bref));
        break;
      }
      case 36: {
        mob_restrict_list_present = true;
        mob_restrict_list.id      = id;
        HANDLE_CODE(mob_restrict_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mob_restrict_list.value.unpack(bref));
        break;
      }
      case 117: {
        ue_radio_cap_present = true;
        ue_radio_cap.id      = id;
        HANDLE_CODE(ue_radio_cap.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.value.unpack(bref));
        break;
      }
      case 31: {
        idx_to_rfsp_present = true;
        idx_to_rfsp.id      = id;
        HANDLE_CODE(idx_to_rfsp.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(idx_to_rfsp.value.unpack(bref));
        break;
      }
      case 34: {
        masked_imeisv_present = true;
        masked_imeisv.id      = id;
        HANDLE_CODE(masked_imeisv.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(masked_imeisv.value.unpack(bref));
        break;
      }
      case 38: {
        nas_pdu_present = true;
        nas_pdu.id      = id;
        HANDLE_CODE(nas_pdu.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.value.unpack(bref));
        break;
      }
      case 24: {
        emergency_fallback_ind_present = true;
        emergency_fallback_ind.id      = id;
        HANDLE_CODE(emergency_fallback_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(emergency_fallback_ind.value.unpack(bref));
        break;
      }
      case 91: {
        rrc_inactive_transition_report_request_present = true;
        rrc_inactive_transition_report_request.id      = id;
        HANDLE_CODE(rrc_inactive_transition_report_request.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_inactive_transition_report_request.value.unpack(bref));
        break;
      }
      case 118: {
        ue_radio_cap_for_paging_present = true;
        ue_radio_cap_for_paging.id      = id;
        HANDLE_CODE(ue_radio_cap_for_paging.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_for_paging.value.unpack(bref));
        break;
      }
      case 146: {
        redirection_voice_fallback_present = true;
        redirection_voice_fallback.id      = id;
        HANDLE_CODE(redirection_voice_fallback.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redirection_voice_fallback.value.unpack(bref));
        break;
      }
      case 33: {
        location_report_request_type_present = true;
        location_report_request_type.id      = id;
        HANDLE_CODE(location_report_request_type.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(location_report_request_type.value.unpack(bref));
        break;
      }
      case 165: {
        cn_assisted_ran_tuning_present = true;
        cn_assisted_ran_tuning.id      = id;
        HANDLE_CODE(cn_assisted_ran_tuning.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_assisted_ran_tuning.value.unpack(bref));
        break;
      }
      case 177: {
        srvcc_operation_possible_present = true;
        srvcc_operation_possible.id      = id;
        HANDLE_CODE(srvcc_operation_possible.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(srvcc_operation_possible.value.unpack(bref));
        break;
      }
      case 199: {
        iab_authorized_present = true;
        iab_authorized.id      = id;
        HANDLE_CODE(iab_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(iab_authorized.value.unpack(bref));
        break;
      }
      case 205: {
        enhanced_coverage_restrict_present = true;
        enhanced_coverage_restrict.id      = id;
        HANDLE_CODE(enhanced_coverage_restrict.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(enhanced_coverage_restrict.value.unpack(bref));
        break;
      }
      case 206: {
        extended_connected_time_present = true;
        extended_connected_time.id      = id;
        HANDLE_CODE(extended_connected_time.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_connected_time.value.unpack(bref));
        break;
      }
      case 209: {
        ue_diff_info_present = true;
        ue_diff_info.id      = id;
        HANDLE_CODE(ue_diff_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_diff_info.value.unpack(bref));
        break;
      }
      case 216: {
        nr_v2x_services_authorized_present = true;
        nr_v2x_services_authorized.id      = id;
        HANDLE_CODE(nr_v2x_services_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_v2x_services_authorized.value.unpack(bref));
        break;
      }
      case 215: {
        ltev2x_services_authorized_present = true;
        ltev2x_services_authorized.id      = id;
        HANDLE_CODE(ltev2x_services_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ltev2x_services_authorized.value.unpack(bref));
        break;
      }
      case 218: {
        nr_ue_sidelink_aggr_max_bitrate_present = true;
        nr_ue_sidelink_aggr_max_bitrate.id      = id;
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.value.unpack(bref));
        break;
      }
      case 217: {
        lte_ue_sidelink_aggr_max_bitrate_present = true;
        lte_ue_sidelink_aggr_max_bitrate.id      = id;
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.value.unpack(bref));
        break;
      }
      case 219: {
        pc5_qos_params_present = true;
        pc5_qos_params.id      = id;
        HANDLE_CODE(pc5_qos_params.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pc5_qos_params.value.unpack(bref));
        break;
      }
      case 222: {
        ce_mode_brestricted_present = true;
        ce_mode_brestricted.id      = id;
        HANDLE_CODE(ce_mode_brestricted.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_brestricted.value.unpack(bref));
        break;
      }
      case 234: {
        ue_up_c_iot_support_present = true;
        ue_up_c_iot_support.id      = id;
        HANDLE_CODE(ue_up_c_iot_support.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_up_c_iot_support.value.unpack(bref));
        break;
      }
      case 238: {
        rg_level_wireline_access_characteristics_present = true;
        rg_level_wireline_access_characteristics.id      = id;
        HANDLE_CODE(rg_level_wireline_access_characteristics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rg_level_wireline_access_characteristics.value.unpack(bref));
        break;
      }
      case 254: {
        management_based_mdt_plmn_list_present = true;
        management_based_mdt_plmn_list.id      = id;
        HANDLE_CODE(management_based_mdt_plmn_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(management_based_mdt_plmn_list.value.unpack(bref));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        ue_radio_cap_id.id      = id;
        HANDLE_CODE(ue_radio_cap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.value.unpack(bref));
        break;
      }
      case 326: {
        time_sync_assist_info_present = true;
        time_sync_assist_info.id      = id;
        HANDLE_CODE(time_sync_assist_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_sync_assist_info.value.unpack(bref));
        break;
      }
      case 328: {
        q_mcc_onfig_info_present = true;
        q_mcc_onfig_info.id      = id;
        HANDLE_CODE(q_mcc_onfig_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(q_mcc_onfig_info.value.unpack(bref));
        break;
      }
      case 334: {
        target_nssai_info_present = true;
        target_nssai_info.id      = id;
        HANDLE_CODE(target_nssai_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(target_nssai_info.value.unpack(bref));
        break;
      }
      case 335: {
        ue_slice_max_bit_rate_list_present = true;
        ue_slice_max_bit_rate_list.id      = id;
        HANDLE_CODE(ue_slice_max_bit_rate_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_slice_max_bit_rate_list.value.unpack(bref));
        break;
      }
      case 345: {
        five_g_pro_se_authorized_present = true;
        five_g_pro_se_authorized.id      = id;
        HANDLE_CODE(five_g_pro_se_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_authorized.value.unpack(bref));
        break;
      }
      case 346: {
        five_g_pro_se_ue_pc5_aggr_max_bit_rate_present = true;
        five_g_pro_se_ue_pc5_aggr_max_bit_rate.id      = id;
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.value.unpack(bref));
        break;
      }
      case 347: {
        five_g_pro_se_pc5_qos_params_present = true;
        five_g_pro_se_pc5_qos_params.id      = id;
        HANDLE_CODE(five_g_pro_se_pc5_qos_params.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_pc5_qos_params.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void init_context_setup_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (old_amf_present) {
    j.write_fieldname("");
    old_amf.to_json(j);
  }
  if (ue_aggr_max_bit_rate_present) {
    j.write_fieldname("");
    ue_aggr_max_bit_rate.to_json(j);
  }
  if (core_network_assist_info_for_inactive_present) {
    j.write_fieldname("");
    core_network_assist_info_for_inactive.to_json(j);
  }
  j.write_fieldname("");
  guami.to_json(j);
  if (pdu_session_res_setup_list_cxt_req_present) {
    j.write_fieldname("");
    pdu_session_res_setup_list_cxt_req.to_json(j);
  }
  j.write_fieldname("");
  allowed_nssai.to_json(j);
  j.write_fieldname("");
  ue_security_cap.to_json(j);
  j.write_fieldname("");
  security_key.to_json(j);
  if (trace_activation_present) {
    j.write_fieldname("");
    trace_activation.to_json(j);
  }
  if (mob_restrict_list_present) {
    j.write_fieldname("");
    mob_restrict_list.to_json(j);
  }
  if (ue_radio_cap_present) {
    j.write_fieldname("");
    ue_radio_cap.to_json(j);
  }
  if (idx_to_rfsp_present) {
    j.write_fieldname("");
    idx_to_rfsp.to_json(j);
  }
  if (masked_imeisv_present) {
    j.write_fieldname("");
    masked_imeisv.to_json(j);
  }
  if (nas_pdu_present) {
    j.write_fieldname("");
    nas_pdu.to_json(j);
  }
  if (emergency_fallback_ind_present) {
    j.write_fieldname("");
    emergency_fallback_ind.to_json(j);
  }
  if (rrc_inactive_transition_report_request_present) {
    j.write_fieldname("");
    rrc_inactive_transition_report_request.to_json(j);
  }
  if (ue_radio_cap_for_paging_present) {
    j.write_fieldname("");
    ue_radio_cap_for_paging.to_json(j);
  }
  if (redirection_voice_fallback_present) {
    j.write_fieldname("");
    redirection_voice_fallback.to_json(j);
  }
  if (location_report_request_type_present) {
    j.write_fieldname("");
    location_report_request_type.to_json(j);
  }
  if (cn_assisted_ran_tuning_present) {
    j.write_fieldname("");
    cn_assisted_ran_tuning.to_json(j);
  }
  if (srvcc_operation_possible_present) {
    j.write_fieldname("");
    srvcc_operation_possible.to_json(j);
  }
  if (iab_authorized_present) {
    j.write_fieldname("");
    iab_authorized.to_json(j);
  }
  if (enhanced_coverage_restrict_present) {
    j.write_fieldname("");
    enhanced_coverage_restrict.to_json(j);
  }
  if (extended_connected_time_present) {
    j.write_fieldname("");
    extended_connected_time.to_json(j);
  }
  if (ue_diff_info_present) {
    j.write_fieldname("");
    ue_diff_info.to_json(j);
  }
  if (nr_v2x_services_authorized_present) {
    j.write_fieldname("");
    nr_v2x_services_authorized.to_json(j);
  }
  if (ltev2x_services_authorized_present) {
    j.write_fieldname("");
    ltev2x_services_authorized.to_json(j);
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    j.write_fieldname("");
    nr_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    j.write_fieldname("");
    lte_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (pc5_qos_params_present) {
    j.write_fieldname("");
    pc5_qos_params.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_fieldname("");
    ce_mode_brestricted.to_json(j);
  }
  if (ue_up_c_iot_support_present) {
    j.write_fieldname("");
    ue_up_c_iot_support.to_json(j);
  }
  if (rg_level_wireline_access_characteristics_present) {
    j.write_fieldname("");
    rg_level_wireline_access_characteristics.to_json(j);
  }
  if (management_based_mdt_plmn_list_present) {
    j.write_fieldname("");
    management_based_mdt_plmn_list.to_json(j);
  }
  if (ue_radio_cap_id_present) {
    j.write_fieldname("");
    ue_radio_cap_id.to_json(j);
  }
  if (time_sync_assist_info_present) {
    j.write_fieldname("");
    time_sync_assist_info.to_json(j);
  }
  if (q_mcc_onfig_info_present) {
    j.write_fieldname("");
    q_mcc_onfig_info.to_json(j);
  }
  if (target_nssai_info_present) {
    j.write_fieldname("");
    target_nssai_info.to_json(j);
  }
  if (ue_slice_max_bit_rate_list_present) {
    j.write_fieldname("");
    ue_slice_max_bit_rate_list.to_json(j);
  }
  if (five_g_pro_se_authorized_present) {
    j.write_fieldname("");
    five_g_pro_se_authorized.to_json(j);
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    j.write_fieldname("");
    five_g_pro_se_ue_pc5_aggr_max_bit_rate.to_json(j);
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    j.write_fieldname("");
    five_g_pro_se_pc5_qos_params.to_json(j);
  }
  j.end_obj();
}

// InitialContextSetupResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t init_context_setup_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 72, 55, 19};
  return map_enum_number(names, 5, idx, "id");
}
bool init_context_setup_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 72, 55, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e init_context_setup_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 72:
      return crit_e::ignore;
    case 55:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
init_context_setup_resp_ies_o::value_c init_context_setup_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 72:
      ret.set(value_c::types::pdu_session_res_setup_list_cxt_res);
      break;
    case 55:
      ret.set(value_c::types::pdu_session_res_failed_to_setup_list_cxt_res);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e init_context_setup_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 72:
      return presence_e::optional;
    case 55:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void init_context_setup_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_setup_list_cxt_res:
      c.destroy<pdu_session_res_setup_list_cxt_res_l>();
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      c.destroy<pdu_session_res_failed_to_setup_list_cxt_res_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void init_context_setup_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_setup_list_cxt_res:
      c.init<pdu_session_res_setup_list_cxt_res_l>();
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      c.init<pdu_session_res_failed_to_setup_list_cxt_res_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
  }
}
init_context_setup_resp_ies_o::value_c::value_c(const init_context_setup_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_setup_list_cxt_res:
      c.init(other.c.get<pdu_session_res_setup_list_cxt_res_l>());
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      c.init(other.c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
  }
}
init_context_setup_resp_ies_o::value_c&
init_context_setup_resp_ies_o::value_c::operator=(const init_context_setup_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_setup_list_cxt_res:
      c.set(other.c.get<pdu_session_res_setup_list_cxt_res_l>());
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      c.set(other.c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& init_context_setup_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& init_context_setup_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_setup_list_cxt_res_l& init_context_setup_resp_ies_o::value_c::pdu_session_res_setup_list_cxt_res()
{
  assert_choice_type(types::pdu_session_res_setup_list_cxt_res, type_, "Value");
  return c.get<pdu_session_res_setup_list_cxt_res_l>();
}
pdu_session_res_failed_to_setup_list_cxt_res_l&
init_context_setup_resp_ies_o::value_c::pdu_session_res_failed_to_setup_list_cxt_res()
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_cxt_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>();
}
crit_diagnostics_s& init_context_setup_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& init_context_setup_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& init_context_setup_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_setup_list_cxt_res_l&
init_context_setup_resp_ies_o::value_c::pdu_session_res_setup_list_cxt_res() const
{
  assert_choice_type(types::pdu_session_res_setup_list_cxt_res, type_, "Value");
  return c.get<pdu_session_res_setup_list_cxt_res_l>();
}
const pdu_session_res_failed_to_setup_list_cxt_res_l&
init_context_setup_resp_ies_o::value_c::pdu_session_res_failed_to_setup_list_cxt_res() const
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_cxt_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>();
}
const crit_diagnostics_s& init_context_setup_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void init_context_setup_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_setup_list_cxt_res:
      j.start_array("PDUSessionResourceSetupListCxtRes");
      for (const auto& e1 : c.get<pdu_session_res_setup_list_cxt_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      j.start_array("PDUSessionResourceFailedToSetupListCxtRes");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE init_context_setup_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_setup_list_cxt_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_setup_list_cxt_res_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_setup_list_cxt_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_setup_list_cxt_res_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

init_context_setup_resp_ies_container::init_context_setup_resp_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  pdu_session_res_setup_list_cxt_res(72, crit_e::ignore),
  pdu_session_res_failed_to_setup_list_cxt_res(55, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE init_context_setup_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += pdu_session_res_setup_list_cxt_res_present ? 1 : 0;
  nof_ies += pdu_session_res_failed_to_setup_list_cxt_res_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (pdu_session_res_setup_list_cxt_res_present) {
    HANDLE_CODE(pdu_session_res_setup_list_cxt_res.pack(bref));
  }
  if (pdu_session_res_failed_to_setup_list_cxt_res_present) {
    HANDLE_CODE(pdu_session_res_failed_to_setup_list_cxt_res.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 72: {
        pdu_session_res_setup_list_cxt_res_present = true;
        pdu_session_res_setup_list_cxt_res.id      = id;
        HANDLE_CODE(pdu_session_res_setup_list_cxt_res.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_setup_list_cxt_res.value.unpack(bref));
        break;
      }
      case 55: {
        pdu_session_res_failed_to_setup_list_cxt_res_present = true;
        pdu_session_res_failed_to_setup_list_cxt_res.id      = id;
        HANDLE_CODE(pdu_session_res_failed_to_setup_list_cxt_res.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_failed_to_setup_list_cxt_res.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void init_context_setup_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (pdu_session_res_setup_list_cxt_res_present) {
    j.write_fieldname("");
    pdu_session_res_setup_list_cxt_res.to_json(j);
  }
  if (pdu_session_res_failed_to_setup_list_cxt_res_present) {
    j.write_fieldname("");
    pdu_session_res_failed_to_setup_list_cxt_res.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// InitialUEMessage-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t init_ue_msg_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {85, 38, 121, 90, 26, 3, 112, 0, 171, 174, 201, 224, 225, 227, 245, 259, 333};
  return map_enum_number(names, 17, idx, "id");
}
bool init_ue_msg_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {85, 38, 121, 90, 26, 3, 112, 0, 171, 174, 201, 224, 225, 227, 245, 259, 333};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e init_ue_msg_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 85:
      return crit_e::reject;
    case 38:
      return crit_e::reject;
    case 121:
      return crit_e::reject;
    case 90:
      return crit_e::ignore;
    case 26:
      return crit_e::reject;
    case 3:
      return crit_e::ignore;
    case 112:
      return crit_e::ignore;
    case 0:
      return crit_e::reject;
    case 171:
      return crit_e::ignore;
    case 174:
      return crit_e::ignore;
    case 201:
      return crit_e::reject;
    case 224:
      return crit_e::reject;
    case 225:
      return crit_e::ignore;
    case 227:
      return crit_e::ignore;
    case 245:
      return crit_e::ignore;
    case 259:
      return crit_e::reject;
    case 333:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
init_ue_msg_ies_o::value_c init_ue_msg_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 90:
      ret.set(value_c::types::rrc_establishment_cause);
      break;
    case 26:
      ret.set(value_c::types::five_g_s_tmsi);
      break;
    case 3:
      ret.set(value_c::types::amf_set_id);
      break;
    case 112:
      ret.set(value_c::types::ue_context_request);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 171:
      ret.set(value_c::types::source_to_target_amf_info_reroute);
      break;
    case 174:
      ret.set(value_c::types::sel_plmn_id);
      break;
    case 201:
      ret.set(value_c::types::iab_node_ind);
      break;
    case 224:
      ret.set(value_c::types::ce_mode_b_support_ind);
      break;
    case 225:
      ret.set(value_c::types::ltem_ind);
      break;
    case 227:
      ret.set(value_c::types::edt_session);
      break;
    case 245:
      ret.set(value_c::types::authenticated_ind);
      break;
    case 259:
      ret.set(value_c::types::npn_access_info);
      break;
    case 333:
      ret.set(value_c::types::red_cap_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e init_ue_msg_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 85:
      return presence_e::mandatory;
    case 38:
      return presence_e::mandatory;
    case 121:
      return presence_e::mandatory;
    case 90:
      return presence_e::mandatory;
    case 26:
      return presence_e::optional;
    case 3:
      return presence_e::optional;
    case 112:
      return presence_e::optional;
    case 0:
      return presence_e::optional;
    case 171:
      return presence_e::optional;
    case 174:
      return presence_e::optional;
    case 201:
      return presence_e::optional;
    case 224:
      return presence_e::optional;
    case 225:
      return presence_e::optional;
    case 227:
      return presence_e::optional;
    case 245:
      return presence_e::optional;
    case 259:
      return presence_e::optional;
    case 333:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void init_ue_msg_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    case types::five_g_s_tmsi:
      c.destroy<five_g_s_tmsi_s>();
      break;
    case types::amf_set_id:
      c.destroy<fixed_bitstring<10, false, true>>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    case types::source_to_target_amf_info_reroute:
      c.destroy<source_to_target_amf_info_reroute_s>();
      break;
    case types::sel_plmn_id:
      c.destroy<fixed_octstring<3, true>>();
      break;
    case types::npn_access_info:
      c.destroy<npn_access_info_c>();
      break;
    default:
      break;
  }
}
void init_ue_msg_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ran_ue_ngap_id:
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::rrc_establishment_cause:
      break;
    case types::five_g_s_tmsi:
      c.init<five_g_s_tmsi_s>();
      break;
    case types::amf_set_id:
      c.init<fixed_bitstring<10, false, true>>();
      break;
    case types::ue_context_request:
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::source_to_target_amf_info_reroute:
      c.init<source_to_target_amf_info_reroute_s>();
      break;
    case types::sel_plmn_id:
      c.init<fixed_octstring<3, true>>();
      break;
    case types::iab_node_ind:
      break;
    case types::ce_mode_b_support_ind:
      break;
    case types::ltem_ind:
      break;
    case types::edt_session:
      break;
    case types::authenticated_ind:
      break;
    case types::npn_access_info:
      c.init<npn_access_info_c>();
      break;
    case types::red_cap_ind:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
  }
}
init_ue_msg_ies_o::value_c::value_c(const init_ue_msg_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::rrc_establishment_cause:
      c.init(other.c.get<rrc_establishment_cause_e>());
      break;
    case types::five_g_s_tmsi:
      c.init(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::amf_set_id:
      c.init(other.c.get<fixed_bitstring<10, false, true>>());
      break;
    case types::ue_context_request:
      c.init(other.c.get<ue_context_request_e>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::source_to_target_amf_info_reroute:
      c.init(other.c.get<source_to_target_amf_info_reroute_s>());
      break;
    case types::sel_plmn_id:
      c.init(other.c.get<fixed_octstring<3, true>>());
      break;
    case types::iab_node_ind:
      c.init(other.c.get<iab_node_ind_e>());
      break;
    case types::ce_mode_b_support_ind:
      c.init(other.c.get<ce_mode_b_support_ind_e>());
      break;
    case types::ltem_ind:
      c.init(other.c.get<ltem_ind_e>());
      break;
    case types::edt_session:
      c.init(other.c.get<edt_session_e>());
      break;
    case types::authenticated_ind:
      c.init(other.c.get<authenticated_ind_e>());
      break;
    case types::npn_access_info:
      c.init(other.c.get<npn_access_info_c>());
      break;
    case types::red_cap_ind:
      c.init(other.c.get<red_cap_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
  }
}
init_ue_msg_ies_o::value_c& init_ue_msg_ies_o::value_c::operator=(const init_ue_msg_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::rrc_establishment_cause:
      c.set(other.c.get<rrc_establishment_cause_e>());
      break;
    case types::five_g_s_tmsi:
      c.set(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::amf_set_id:
      c.set(other.c.get<fixed_bitstring<10, false, true>>());
      break;
    case types::ue_context_request:
      c.set(other.c.get<ue_context_request_e>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::source_to_target_amf_info_reroute:
      c.set(other.c.get<source_to_target_amf_info_reroute_s>());
      break;
    case types::sel_plmn_id:
      c.set(other.c.get<fixed_octstring<3, true>>());
      break;
    case types::iab_node_ind:
      c.set(other.c.get<iab_node_ind_e>());
      break;
    case types::ce_mode_b_support_ind:
      c.set(other.c.get<ce_mode_b_support_ind_e>());
      break;
    case types::ltem_ind:
      c.set(other.c.get<ltem_ind_e>());
      break;
    case types::edt_session:
      c.set(other.c.get<edt_session_e>());
      break;
    case types::authenticated_ind:
      c.set(other.c.get<authenticated_ind_e>());
      break;
    case types::npn_access_info:
      c.set(other.c.get<npn_access_info_c>());
      break;
    case types::red_cap_ind:
      c.set(other.c.get<red_cap_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
  }

  return *this;
}
uint64_t& init_ue_msg_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& init_ue_msg_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
user_location_info_c& init_ue_msg_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
rrc_establishment_cause_e& init_ue_msg_ies_o::value_c::rrc_establishment_cause()
{
  assert_choice_type(types::rrc_establishment_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
five_g_s_tmsi_s& init_ue_msg_ies_o::value_c::five_g_s_tmsi()
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
fixed_bitstring<10, false, true>& init_ue_msg_ies_o::value_c::amf_set_id()
{
  assert_choice_type(types::amf_set_id, type_, "Value");
  return c.get<fixed_bitstring<10, false, true>>();
}
ue_context_request_e& init_ue_msg_ies_o::value_c::ue_context_request()
{
  assert_choice_type(types::ue_context_request, type_, "Value");
  return c.get<ue_context_request_e>();
}
allowed_nssai_l& init_ue_msg_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
source_to_target_amf_info_reroute_s& init_ue_msg_ies_o::value_c::source_to_target_amf_info_reroute()
{
  assert_choice_type(types::source_to_target_amf_info_reroute, type_, "Value");
  return c.get<source_to_target_amf_info_reroute_s>();
}
fixed_octstring<3, true>& init_ue_msg_ies_o::value_c::sel_plmn_id()
{
  assert_choice_type(types::sel_plmn_id, type_, "Value");
  return c.get<fixed_octstring<3, true>>();
}
iab_node_ind_e& init_ue_msg_ies_o::value_c::iab_node_ind()
{
  assert_choice_type(types::iab_node_ind, type_, "Value");
  return c.get<iab_node_ind_e>();
}
ce_mode_b_support_ind_e& init_ue_msg_ies_o::value_c::ce_mode_b_support_ind()
{
  assert_choice_type(types::ce_mode_b_support_ind, type_, "Value");
  return c.get<ce_mode_b_support_ind_e>();
}
ltem_ind_e& init_ue_msg_ies_o::value_c::ltem_ind()
{
  assert_choice_type(types::ltem_ind, type_, "Value");
  return c.get<ltem_ind_e>();
}
edt_session_e& init_ue_msg_ies_o::value_c::edt_session()
{
  assert_choice_type(types::edt_session, type_, "Value");
  return c.get<edt_session_e>();
}
authenticated_ind_e& init_ue_msg_ies_o::value_c::authenticated_ind()
{
  assert_choice_type(types::authenticated_ind, type_, "Value");
  return c.get<authenticated_ind_e>();
}
npn_access_info_c& init_ue_msg_ies_o::value_c::npn_access_info()
{
  assert_choice_type(types::npn_access_info, type_, "Value");
  return c.get<npn_access_info_c>();
}
red_cap_ind_e& init_ue_msg_ies_o::value_c::red_cap_ind()
{
  assert_choice_type(types::red_cap_ind, type_, "Value");
  return c.get<red_cap_ind_e>();
}
const uint64_t& init_ue_msg_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& init_ue_msg_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const user_location_info_c& init_ue_msg_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const rrc_establishment_cause_e& init_ue_msg_ies_o::value_c::rrc_establishment_cause() const
{
  assert_choice_type(types::rrc_establishment_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
const five_g_s_tmsi_s& init_ue_msg_ies_o::value_c::five_g_s_tmsi() const
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
const fixed_bitstring<10, false, true>& init_ue_msg_ies_o::value_c::amf_set_id() const
{
  assert_choice_type(types::amf_set_id, type_, "Value");
  return c.get<fixed_bitstring<10, false, true>>();
}
const ue_context_request_e& init_ue_msg_ies_o::value_c::ue_context_request() const
{
  assert_choice_type(types::ue_context_request, type_, "Value");
  return c.get<ue_context_request_e>();
}
const allowed_nssai_l& init_ue_msg_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const source_to_target_amf_info_reroute_s& init_ue_msg_ies_o::value_c::source_to_target_amf_info_reroute() const
{
  assert_choice_type(types::source_to_target_amf_info_reroute, type_, "Value");
  return c.get<source_to_target_amf_info_reroute_s>();
}
const fixed_octstring<3, true>& init_ue_msg_ies_o::value_c::sel_plmn_id() const
{
  assert_choice_type(types::sel_plmn_id, type_, "Value");
  return c.get<fixed_octstring<3, true>>();
}
const iab_node_ind_e& init_ue_msg_ies_o::value_c::iab_node_ind() const
{
  assert_choice_type(types::iab_node_ind, type_, "Value");
  return c.get<iab_node_ind_e>();
}
const ce_mode_b_support_ind_e& init_ue_msg_ies_o::value_c::ce_mode_b_support_ind() const
{
  assert_choice_type(types::ce_mode_b_support_ind, type_, "Value");
  return c.get<ce_mode_b_support_ind_e>();
}
const ltem_ind_e& init_ue_msg_ies_o::value_c::ltem_ind() const
{
  assert_choice_type(types::ltem_ind, type_, "Value");
  return c.get<ltem_ind_e>();
}
const edt_session_e& init_ue_msg_ies_o::value_c::edt_session() const
{
  assert_choice_type(types::edt_session, type_, "Value");
  return c.get<edt_session_e>();
}
const authenticated_ind_e& init_ue_msg_ies_o::value_c::authenticated_ind() const
{
  assert_choice_type(types::authenticated_ind, type_, "Value");
  return c.get<authenticated_ind_e>();
}
const npn_access_info_c& init_ue_msg_ies_o::value_c::npn_access_info() const
{
  assert_choice_type(types::npn_access_info, type_, "Value");
  return c.get<npn_access_info_c>();
}
const red_cap_ind_e& init_ue_msg_ies_o::value_c::red_cap_ind() const
{
  assert_choice_type(types::red_cap_ind, type_, "Value");
  return c.get<red_cap_ind_e>();
}
void init_ue_msg_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::rrc_establishment_cause:
      j.write_str("RRCEstablishmentCause", c.get<rrc_establishment_cause_e>().to_string());
      break;
    case types::five_g_s_tmsi:
      j.write_fieldname("FiveG-S-TMSI");
      c.get<five_g_s_tmsi_s>().to_json(j);
      break;
    case types::amf_set_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<10, false, true>>().to_string());
      break;
    case types::ue_context_request:
      j.write_str("UEContextRequest", "requested");
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::source_to_target_amf_info_reroute:
      j.write_fieldname("SourceToTarget-AMFInformationReroute");
      c.get<source_to_target_amf_info_reroute_s>().to_json(j);
      break;
    case types::sel_plmn_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<3, true>>().to_string());
      break;
    case types::iab_node_ind:
      j.write_str("IABNodeIndication", "true");
      break;
    case types::ce_mode_b_support_ind:
      j.write_str("CEmodeBSupport-Indicator", "supported");
      break;
    case types::ltem_ind:
      j.write_str("LTEM-Indication", "lte-m");
      break;
    case types::edt_session:
      j.write_str("EDT-Session", "true");
      break;
    case types::authenticated_ind:
      j.write_str("AuthenticatedIndication", "true");
      break;
    case types::npn_access_info:
      j.write_fieldname("NPN-AccessInformation");
      c.get<npn_access_info_c>().to_json(j);
      break;
    case types::red_cap_ind:
      j.write_str("RedCapIndication", "redcap");
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE init_ue_msg_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::rrc_establishment_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().pack(bref));
      break;
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().pack(bref));
      break;
    case types::amf_set_id:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().pack(bref)));
      break;
    case types::ue_context_request:
      HANDLE_CODE(c.get<ue_context_request_e>().pack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::source_to_target_amf_info_reroute:
      HANDLE_CODE(c.get<source_to_target_amf_info_reroute_s>().pack(bref));
      break;
    case types::sel_plmn_id:
      HANDLE_CODE((c.get<fixed_octstring<3, true>>().pack(bref)));
      break;
    case types::iab_node_ind:
      HANDLE_CODE(c.get<iab_node_ind_e>().pack(bref));
      break;
    case types::ce_mode_b_support_ind:
      HANDLE_CODE(c.get<ce_mode_b_support_ind_e>().pack(bref));
      break;
    case types::ltem_ind:
      HANDLE_CODE(c.get<ltem_ind_e>().pack(bref));
      break;
    case types::edt_session:
      HANDLE_CODE(c.get<edt_session_e>().pack(bref));
      break;
    case types::authenticated_ind:
      HANDLE_CODE(c.get<authenticated_ind_e>().pack(bref));
      break;
    case types::npn_access_info:
      HANDLE_CODE(c.get<npn_access_info_c>().pack(bref));
      break;
    case types::red_cap_ind:
      HANDLE_CODE(c.get<red_cap_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE init_ue_msg_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::rrc_establishment_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().unpack(bref));
      break;
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().unpack(bref));
      break;
    case types::amf_set_id:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().unpack(bref)));
      break;
    case types::ue_context_request:
      HANDLE_CODE(c.get<ue_context_request_e>().unpack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::source_to_target_amf_info_reroute:
      HANDLE_CODE(c.get<source_to_target_amf_info_reroute_s>().unpack(bref));
      break;
    case types::sel_plmn_id:
      HANDLE_CODE((c.get<fixed_octstring<3, true>>().unpack(bref)));
      break;
    case types::iab_node_ind:
      HANDLE_CODE(c.get<iab_node_ind_e>().unpack(bref));
      break;
    case types::ce_mode_b_support_ind:
      HANDLE_CODE(c.get<ce_mode_b_support_ind_e>().unpack(bref));
      break;
    case types::ltem_ind:
      HANDLE_CODE(c.get<ltem_ind_e>().unpack(bref));
      break;
    case types::edt_session:
      HANDLE_CODE(c.get<edt_session_e>().unpack(bref));
      break;
    case types::authenticated_ind:
      HANDLE_CODE(c.get<authenticated_ind_e>().unpack(bref));
      break;
    case types::npn_access_info:
      HANDLE_CODE(c.get<npn_access_info_c>().unpack(bref));
      break;
    case types::red_cap_ind:
      HANDLE_CODE(c.get<red_cap_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

init_ue_msg_ies_container::init_ue_msg_ies_container() :
  ran_ue_ngap_id(85, crit_e::reject),
  nas_pdu(38, crit_e::reject),
  user_location_info(121, crit_e::reject),
  rrc_establishment_cause(90, crit_e::ignore),
  five_g_s_tmsi(26, crit_e::reject),
  amf_set_id(3, crit_e::ignore),
  ue_context_request(112, crit_e::ignore),
  allowed_nssai(0, crit_e::reject),
  source_to_target_amf_info_reroute(171, crit_e::ignore),
  sel_plmn_id(174, crit_e::ignore),
  iab_node_ind(201, crit_e::reject),
  ce_mode_b_support_ind(224, crit_e::reject),
  ltem_ind(225, crit_e::ignore),
  edt_session(227, crit_e::ignore),
  authenticated_ind(245, crit_e::ignore),
  npn_access_info(259, crit_e::reject),
  red_cap_ind(333, crit_e::ignore)
{
}
SRSASN_CODE init_ue_msg_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += five_g_s_tmsi_present ? 1 : 0;
  nof_ies += amf_set_id_present ? 1 : 0;
  nof_ies += ue_context_request_present ? 1 : 0;
  nof_ies += allowed_nssai_present ? 1 : 0;
  nof_ies += source_to_target_amf_info_reroute_present ? 1 : 0;
  nof_ies += sel_plmn_id_present ? 1 : 0;
  nof_ies += iab_node_ind_present ? 1 : 0;
  nof_ies += ce_mode_b_support_ind_present ? 1 : 0;
  nof_ies += ltem_ind_present ? 1 : 0;
  nof_ies += edt_session_present ? 1 : 0;
  nof_ies += authenticated_ind_present ? 1 : 0;
  nof_ies += npn_access_info_present ? 1 : 0;
  nof_ies += red_cap_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(nas_pdu.pack(bref));
  HANDLE_CODE(user_location_info.pack(bref));
  HANDLE_CODE(rrc_establishment_cause.pack(bref));
  if (five_g_s_tmsi_present) {
    HANDLE_CODE(five_g_s_tmsi.pack(bref));
  }
  if (amf_set_id_present) {
    HANDLE_CODE(amf_set_id.pack(bref));
  }
  if (ue_context_request_present) {
    HANDLE_CODE(ue_context_request.pack(bref));
  }
  if (allowed_nssai_present) {
    HANDLE_CODE(allowed_nssai.pack(bref));
  }
  if (source_to_target_amf_info_reroute_present) {
    HANDLE_CODE(source_to_target_amf_info_reroute.pack(bref));
  }
  if (sel_plmn_id_present) {
    HANDLE_CODE(sel_plmn_id.pack(bref));
  }
  if (iab_node_ind_present) {
    HANDLE_CODE(iab_node_ind.pack(bref));
  }
  if (ce_mode_b_support_ind_present) {
    HANDLE_CODE(ce_mode_b_support_ind.pack(bref));
  }
  if (ltem_ind_present) {
    HANDLE_CODE(ltem_ind.pack(bref));
  }
  if (edt_session_present) {
    HANDLE_CODE(edt_session.pack(bref));
  }
  if (authenticated_ind_present) {
    HANDLE_CODE(authenticated_ind.pack(bref));
  }
  if (npn_access_info_present) {
    HANDLE_CODE(npn_access_info.pack(bref));
  }
  if (red_cap_ind_present) {
    HANDLE_CODE(red_cap_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_ue_msg_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 38: {
        nof_mandatory_ies--;
        nas_pdu.id = id;
        HANDLE_CODE(nas_pdu.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.value.unpack(bref));
        break;
      }
      case 121: {
        nof_mandatory_ies--;
        user_location_info.id = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      case 90: {
        nof_mandatory_ies--;
        rrc_establishment_cause.id = id;
        HANDLE_CODE(rrc_establishment_cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_establishment_cause.value.unpack(bref));
        break;
      }
      case 26: {
        five_g_s_tmsi_present = true;
        five_g_s_tmsi.id      = id;
        HANDLE_CODE(five_g_s_tmsi.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_s_tmsi.value.unpack(bref));
        break;
      }
      case 3: {
        amf_set_id_present = true;
        amf_set_id.id      = id;
        HANDLE_CODE(amf_set_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_set_id.value.unpack(bref));
        break;
      }
      case 112: {
        ue_context_request_present = true;
        ue_context_request.id      = id;
        HANDLE_CODE(ue_context_request.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_context_request.value.unpack(bref));
        break;
      }
      case 0: {
        allowed_nssai_present = true;
        allowed_nssai.id      = id;
        HANDLE_CODE(allowed_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(allowed_nssai.value.unpack(bref));
        break;
      }
      case 171: {
        source_to_target_amf_info_reroute_present = true;
        source_to_target_amf_info_reroute.id      = id;
        HANDLE_CODE(source_to_target_amf_info_reroute.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_to_target_amf_info_reroute.value.unpack(bref));
        break;
      }
      case 174: {
        sel_plmn_id_present = true;
        sel_plmn_id.id      = id;
        HANDLE_CODE(sel_plmn_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(sel_plmn_id.value.unpack(bref));
        break;
      }
      case 201: {
        iab_node_ind_present = true;
        iab_node_ind.id      = id;
        HANDLE_CODE(iab_node_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(iab_node_ind.value.unpack(bref));
        break;
      }
      case 224: {
        ce_mode_b_support_ind_present = true;
        ce_mode_b_support_ind.id      = id;
        HANDLE_CODE(ce_mode_b_support_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_b_support_ind.value.unpack(bref));
        break;
      }
      case 225: {
        ltem_ind_present = true;
        ltem_ind.id      = id;
        HANDLE_CODE(ltem_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ltem_ind.value.unpack(bref));
        break;
      }
      case 227: {
        edt_session_present = true;
        edt_session.id      = id;
        HANDLE_CODE(edt_session.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(edt_session.value.unpack(bref));
        break;
      }
      case 245: {
        authenticated_ind_present = true;
        authenticated_ind.id      = id;
        HANDLE_CODE(authenticated_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(authenticated_ind.value.unpack(bref));
        break;
      }
      case 259: {
        npn_access_info_present = true;
        npn_access_info.id      = id;
        HANDLE_CODE(npn_access_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(npn_access_info.value.unpack(bref));
        break;
      }
      case 333: {
        red_cap_ind_present = true;
        red_cap_ind.id      = id;
        HANDLE_CODE(red_cap_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(red_cap_ind.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void init_ue_msg_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  nas_pdu.to_json(j);
  j.write_fieldname("");
  user_location_info.to_json(j);
  j.write_fieldname("");
  rrc_establishment_cause.to_json(j);
  if (five_g_s_tmsi_present) {
    j.write_fieldname("");
    five_g_s_tmsi.to_json(j);
  }
  if (amf_set_id_present) {
    j.write_fieldname("");
    amf_set_id.to_json(j);
  }
  if (ue_context_request_present) {
    j.write_fieldname("");
    ue_context_request.to_json(j);
  }
  if (allowed_nssai_present) {
    j.write_fieldname("");
    allowed_nssai.to_json(j);
  }
  if (source_to_target_amf_info_reroute_present) {
    j.write_fieldname("");
    source_to_target_amf_info_reroute.to_json(j);
  }
  if (sel_plmn_id_present) {
    j.write_fieldname("");
    sel_plmn_id.to_json(j);
  }
  if (iab_node_ind_present) {
    j.write_fieldname("");
    iab_node_ind.to_json(j);
  }
  if (ce_mode_b_support_ind_present) {
    j.write_fieldname("");
    ce_mode_b_support_ind.to_json(j);
  }
  if (ltem_ind_present) {
    j.write_fieldname("");
    ltem_ind.to_json(j);
  }
  if (edt_session_present) {
    j.write_fieldname("");
    edt_session.to_json(j);
  }
  if (authenticated_ind_present) {
    j.write_fieldname("");
    authenticated_ind.to_json(j);
  }
  if (npn_access_info_present) {
    j.write_fieldname("");
    npn_access_info.to_json(j);
  }
  if (red_cap_ind_present) {
    j.write_fieldname("");
    red_cap_ind.to_json(j);
  }
  j.end_obj();
}

// LocationReportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t location_report_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 121, 116, 33};
  return map_enum_number(names, 5, idx, "id");
}
bool location_report_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 121, 116, 33};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e location_report_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 121:
      return crit_e::ignore;
    case 116:
      return crit_e::ignore;
    case 33:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
location_report_ies_o::value_c location_report_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 116:
      ret.set(value_c::types::ue_presence_in_area_of_interest_list);
      break;
    case 33:
      ret.set(value_c::types::location_report_request_type);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e location_report_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 121:
      return presence_e::mandatory;
    case 116:
      return presence_e::optional;
    case 33:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void location_report_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    case types::ue_presence_in_area_of_interest_list:
      c.destroy<ue_presence_in_area_of_interest_list_l>();
      break;
    case types::location_report_request_type:
      c.destroy<location_report_request_type_s>();
      break;
    default:
      break;
  }
}
void location_report_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::ue_presence_in_area_of_interest_list:
      c.init<ue_presence_in_area_of_interest_list_l>();
      break;
    case types::location_report_request_type:
      c.init<location_report_request_type_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
  }
}
location_report_ies_o::value_c::value_c(const location_report_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::ue_presence_in_area_of_interest_list:
      c.init(other.c.get<ue_presence_in_area_of_interest_list_l>());
      break;
    case types::location_report_request_type:
      c.init(other.c.get<location_report_request_type_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
  }
}
location_report_ies_o::value_c& location_report_ies_o::value_c::operator=(const location_report_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::ue_presence_in_area_of_interest_list:
      c.set(other.c.get<ue_presence_in_area_of_interest_list_l>());
      break;
    case types::location_report_request_type:
      c.set(other.c.get<location_report_request_type_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
  }

  return *this;
}
uint64_t& location_report_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& location_report_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
user_location_info_c& location_report_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
ue_presence_in_area_of_interest_list_l& location_report_ies_o::value_c::ue_presence_in_area_of_interest_list()
{
  assert_choice_type(types::ue_presence_in_area_of_interest_list, type_, "Value");
  return c.get<ue_presence_in_area_of_interest_list_l>();
}
location_report_request_type_s& location_report_ies_o::value_c::location_report_request_type()
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
const uint64_t& location_report_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& location_report_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const user_location_info_c& location_report_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const ue_presence_in_area_of_interest_list_l&
location_report_ies_o::value_c::ue_presence_in_area_of_interest_list() const
{
  assert_choice_type(types::ue_presence_in_area_of_interest_list, type_, "Value");
  return c.get<ue_presence_in_area_of_interest_list_l>();
}
const location_report_request_type_s& location_report_ies_o::value_c::location_report_request_type() const
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
void location_report_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::ue_presence_in_area_of_interest_list:
      j.start_array("UEPresenceInAreaOfInterestList");
      for (const auto& e1 : c.get<ue_presence_in_area_of_interest_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::location_report_request_type:
      j.write_fieldname("LocationReportingRequestType");
      c.get<location_report_request_type_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE location_report_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::ue_presence_in_area_of_interest_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_presence_in_area_of_interest_list_l>(), 1, 64, true));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::ue_presence_in_area_of_interest_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_presence_in_area_of_interest_list_l>(), bref, 1, 64, true));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// LocationReportingControlIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t location_report_ctrl_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 33};
  return map_enum_number(names, 3, idx, "id");
}
bool location_report_ctrl_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 33};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e location_report_ctrl_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 33:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
location_report_ctrl_ies_o::value_c location_report_ctrl_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 33:
      ret.set(value_c::types::location_report_request_type);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e location_report_ctrl_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 33:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void location_report_ctrl_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::location_report_request_type:
      c.destroy<location_report_request_type_s>();
      break;
    default:
      break;
  }
}
void location_report_ctrl_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::location_report_request_type:
      c.init<location_report_request_type_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
  }
}
location_report_ctrl_ies_o::value_c::value_c(const location_report_ctrl_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::location_report_request_type:
      c.init(other.c.get<location_report_request_type_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
  }
}
location_report_ctrl_ies_o::value_c&
location_report_ctrl_ies_o::value_c::operator=(const location_report_ctrl_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::location_report_request_type:
      c.set(other.c.get<location_report_request_type_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
  }

  return *this;
}
uint64_t& location_report_ctrl_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& location_report_ctrl_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
location_report_request_type_s& location_report_ctrl_ies_o::value_c::location_report_request_type()
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
const uint64_t& location_report_ctrl_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& location_report_ctrl_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const location_report_request_type_s& location_report_ctrl_ies_o::value_c::location_report_request_type() const
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
void location_report_ctrl_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::location_report_request_type:
      j.write_fieldname("LocationReportingRequestType");
      c.get<location_report_request_type_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE location_report_ctrl_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_ctrl_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// LocationReportingFailureIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t location_report_fail_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15};
  return map_enum_number(names, 3, idx, "id");
}
bool location_report_fail_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e location_report_fail_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
location_report_fail_ind_ies_o::value_c location_report_fail_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e location_report_fail_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void location_report_fail_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void location_report_fail_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
  }
}
location_report_fail_ind_ies_o::value_c::value_c(const location_report_fail_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
  }
}
location_report_fail_ind_ies_o::value_c&
location_report_fail_ind_ies_o::value_c::operator=(const location_report_fail_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& location_report_fail_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& location_report_fail_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& location_report_fail_ind_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const uint64_t& location_report_fail_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& location_report_fail_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& location_report_fail_ind_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void location_report_fail_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE location_report_fail_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_fail_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// MulticastGroupPagingIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_group_paging_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 298, 307};
  return map_enum_number(names, 3, idx, "id");
}
bool multicast_group_paging_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 298, 307};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_group_paging_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::ignore;
    case 298:
      return crit_e::ignore;
    case 307:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_group_paging_ies_o::value_c multicast_group_paging_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 298:
      ret.set(value_c::types::mbs_service_area);
      break;
    case 307:
      ret.set(value_c::types::multicast_group_paging_area_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_group_paging_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 298:
      return presence_e::optional;
    case 307:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_group_paging_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_service_area:
      c.destroy<mbs_service_area_c>();
      break;
    case types::multicast_group_paging_area_list:
      c.destroy<multicast_group_paging_area_list_l>();
      break;
    default:
      break;
  }
}
void multicast_group_paging_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_service_area:
      c.init<mbs_service_area_c>();
      break;
    case types::multicast_group_paging_area_list:
      c.init<multicast_group_paging_area_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_group_paging_ies_o::value_c");
  }
}
multicast_group_paging_ies_o::value_c::value_c(const multicast_group_paging_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_service_area:
      c.init(other.c.get<mbs_service_area_c>());
      break;
    case types::multicast_group_paging_area_list:
      c.init(other.c.get<multicast_group_paging_area_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_group_paging_ies_o::value_c");
  }
}
multicast_group_paging_ies_o::value_c&
multicast_group_paging_ies_o::value_c::operator=(const multicast_group_paging_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_service_area:
      c.set(other.c.get<mbs_service_area_c>());
      break;
    case types::multicast_group_paging_area_list:
      c.set(other.c.get<multicast_group_paging_area_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_group_paging_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_group_paging_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
mbs_service_area_c& multicast_group_paging_ies_o::value_c::mbs_service_area()
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
multicast_group_paging_area_list_l& multicast_group_paging_ies_o::value_c::multicast_group_paging_area_list()
{
  assert_choice_type(types::multicast_group_paging_area_list, type_, "Value");
  return c.get<multicast_group_paging_area_list_l>();
}
const mbs_session_id_s& multicast_group_paging_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const mbs_service_area_c& multicast_group_paging_ies_o::value_c::mbs_service_area() const
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
const multicast_group_paging_area_list_l&
multicast_group_paging_ies_o::value_c::multicast_group_paging_area_list() const
{
  assert_choice_type(types::multicast_group_paging_area_list, type_, "Value");
  return c.get<multicast_group_paging_area_list_l>();
}
void multicast_group_paging_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_service_area:
      j.write_fieldname("MBS-ServiceArea");
      c.get<mbs_service_area_c>().to_json(j);
      break;
    case types::multicast_group_paging_area_list:
      j.start_array("MulticastGroupPagingAreaList");
      for (const auto& e1 : c.get<multicast_group_paging_area_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "multicast_group_paging_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_group_paging_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().pack(bref));
      break;
    case types::multicast_group_paging_area_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<multicast_group_paging_area_list_l>(), 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_group_paging_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_group_paging_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().unpack(bref));
      break;
    case types::multicast_group_paging_area_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<multicast_group_paging_area_list_l>(), bref, 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_group_paging_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// MulticastSessionActivationFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_activation_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 15, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool multicast_session_activation_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_activation_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_activation_fail_ies_o::value_c multicast_session_activation_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_activation_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_activation_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void multicast_session_activation_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_fail_ies_o::value_c");
  }
}
multicast_session_activation_fail_ies_o::value_c::value_c(const multicast_session_activation_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_fail_ies_o::value_c");
  }
}
multicast_session_activation_fail_ies_o::value_c& multicast_session_activation_fail_ies_o::value_c::operator=(
    const multicast_session_activation_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_fail_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_activation_fail_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
cause_c& multicast_session_activation_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& multicast_session_activation_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& multicast_session_activation_fail_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const cause_c& multicast_session_activation_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& multicast_session_activation_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void multicast_session_activation_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_activation_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// MulticastSessionActivationRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_activation_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 304};
  return map_enum_number(names, 2, idx, "id");
}
bool multicast_session_activation_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 304};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_activation_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 304:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_activation_request_ies_o::value_c
multicast_session_activation_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 304:
      ret.set(value_c::types::multicast_session_activation_request_transfer);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_activation_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 304:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_activation_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::multicast_session_activation_request_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void multicast_session_activation_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::multicast_session_activation_request_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_request_ies_o::value_c");
  }
}
multicast_session_activation_request_ies_o::value_c::value_c(
    const multicast_session_activation_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::multicast_session_activation_request_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_request_ies_o::value_c");
  }
}
multicast_session_activation_request_ies_o::value_c& multicast_session_activation_request_ies_o::value_c::operator=(
    const multicast_session_activation_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::multicast_session_activation_request_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_request_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_activation_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>&
multicast_session_activation_request_ies_o::value_c::multicast_session_activation_request_transfer()
{
  assert_choice_type(types::multicast_session_activation_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_id_s& multicast_session_activation_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>&
multicast_session_activation_request_ies_o::value_c::multicast_session_activation_request_transfer() const
{
  assert_choice_type(types::multicast_session_activation_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void multicast_session_activation_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::multicast_session_activation_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_activation_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::multicast_session_activation_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::multicast_session_activation_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// MulticastSessionActivationResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_activation_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 19};
  return map_enum_number(names, 2, idx, "id");
}
bool multicast_session_activation_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_activation_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_activation_resp_ies_o::value_c multicast_session_activation_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_activation_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_activation_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void multicast_session_activation_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_resp_ies_o::value_c");
  }
}
multicast_session_activation_resp_ies_o::value_c::value_c(const multicast_session_activation_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_resp_ies_o::value_c");
  }
}
multicast_session_activation_resp_ies_o::value_c& multicast_session_activation_resp_ies_o::value_c::operator=(
    const multicast_session_activation_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_resp_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_activation_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
crit_diagnostics_s& multicast_session_activation_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& multicast_session_activation_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const crit_diagnostics_s& multicast_session_activation_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void multicast_session_activation_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_activation_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// MulticastSessionDeactivationRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_deactivation_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 305};
  return map_enum_number(names, 2, idx, "id");
}
bool multicast_session_deactivation_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 305};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_deactivation_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 305:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_deactivation_request_ies_o::value_c
multicast_session_deactivation_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 305:
      ret.set(value_c::types::multicast_session_deactivation_request_transfer);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_deactivation_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 305:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_deactivation_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::multicast_session_deactivation_request_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void multicast_session_deactivation_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::multicast_session_deactivation_request_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_request_ies_o::value_c");
  }
}
multicast_session_deactivation_request_ies_o::value_c::value_c(
    const multicast_session_deactivation_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::multicast_session_deactivation_request_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_request_ies_o::value_c");
  }
}
multicast_session_deactivation_request_ies_o::value_c& multicast_session_deactivation_request_ies_o::value_c::operator=(
    const multicast_session_deactivation_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::multicast_session_deactivation_request_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_request_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_deactivation_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>&
multicast_session_deactivation_request_ies_o::value_c::multicast_session_deactivation_request_transfer()
{
  assert_choice_type(types::multicast_session_deactivation_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_id_s& multicast_session_deactivation_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>&
multicast_session_deactivation_request_ies_o::value_c::multicast_session_deactivation_request_transfer() const
{
  assert_choice_type(types::multicast_session_deactivation_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void multicast_session_deactivation_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::multicast_session_deactivation_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_deactivation_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::multicast_session_deactivation_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_deactivation_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::multicast_session_deactivation_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// MulticastSessionDeactivationResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_deactivation_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 19};
  return map_enum_number(names, 2, idx, "id");
}
bool multicast_session_deactivation_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_deactivation_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_deactivation_resp_ies_o::value_c
multicast_session_deactivation_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_deactivation_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_deactivation_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void multicast_session_deactivation_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_resp_ies_o::value_c");
  }
}
multicast_session_deactivation_resp_ies_o::value_c::value_c(
    const multicast_session_deactivation_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_resp_ies_o::value_c");
  }
}
multicast_session_deactivation_resp_ies_o::value_c& multicast_session_deactivation_resp_ies_o::value_c::operator=(
    const multicast_session_deactivation_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_resp_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_deactivation_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
crit_diagnostics_s& multicast_session_deactivation_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& multicast_session_deactivation_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const crit_diagnostics_s& multicast_session_deactivation_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void multicast_session_deactivation_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_deactivation_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_deactivation_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// MulticastSessionUpdateFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_upd_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 15, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool multicast_session_upd_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_upd_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_upd_fail_ies_o::value_c multicast_session_upd_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_upd_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_upd_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void multicast_session_upd_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_area_session_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_fail_ies_o::value_c");
  }
}
multicast_session_upd_fail_ies_o::value_c::value_c(const multicast_session_upd_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_fail_ies_o::value_c");
  }
}
multicast_session_upd_fail_ies_o::value_c&
multicast_session_upd_fail_ies_o::value_c::operator=(const multicast_session_upd_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_fail_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_upd_fail_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& multicast_session_upd_fail_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
cause_c& multicast_session_upd_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& multicast_session_upd_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& multicast_session_upd_fail_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& multicast_session_upd_fail_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const cause_c& multicast_session_upd_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& multicast_session_upd_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void multicast_session_upd_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_upd_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// MulticastSessionUpdateRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_upd_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 306};
  return map_enum_number(names, 3, idx, "id");
}
bool multicast_session_upd_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 306};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_upd_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 306:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_upd_request_ies_o::value_c multicast_session_upd_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 306:
      ret.set(value_c::types::multicast_session_upd_request_transfer);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_upd_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 306:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_upd_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::multicast_session_upd_request_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void multicast_session_upd_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_area_session_id:
      break;
    case types::multicast_session_upd_request_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_ies_o::value_c");
  }
}
multicast_session_upd_request_ies_o::value_c::value_c(const multicast_session_upd_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::multicast_session_upd_request_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_ies_o::value_c");
  }
}
multicast_session_upd_request_ies_o::value_c&
multicast_session_upd_request_ies_o::value_c::operator=(const multicast_session_upd_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::multicast_session_upd_request_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_upd_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& multicast_session_upd_request_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& multicast_session_upd_request_ies_o::value_c::multicast_session_upd_request_transfer()
{
  assert_choice_type(types::multicast_session_upd_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_id_s& multicast_session_upd_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& multicast_session_upd_request_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>&
multicast_session_upd_request_ies_o::value_c::multicast_session_upd_request_transfer() const
{
  assert_choice_type(types::multicast_session_upd_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void multicast_session_upd_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::multicast_session_upd_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_upd_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::multicast_session_upd_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::multicast_session_upd_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// MulticastSessionUpdateResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_upd_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool multicast_session_upd_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_upd_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_upd_resp_ies_o::value_c multicast_session_upd_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_upd_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_upd_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void multicast_session_upd_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_area_session_id:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_resp_ies_o::value_c");
  }
}
multicast_session_upd_resp_ies_o::value_c::value_c(const multicast_session_upd_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_resp_ies_o::value_c");
  }
}
multicast_session_upd_resp_ies_o::value_c&
multicast_session_upd_resp_ies_o::value_c::operator=(const multicast_session_upd_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_resp_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_upd_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& multicast_session_upd_resp_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
crit_diagnostics_s& multicast_session_upd_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& multicast_session_upd_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& multicast_session_upd_resp_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const crit_diagnostics_s& multicast_session_upd_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void multicast_session_upd_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_upd_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// NASNonDeliveryIndication-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t nas_non_delivery_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 38, 15};
  return map_enum_number(names, 4, idx, "id");
}
bool nas_non_delivery_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 38, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e nas_non_delivery_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 38:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
nas_non_delivery_ind_ies_o::value_c nas_non_delivery_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e nas_non_delivery_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 38:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void nas_non_delivery_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void nas_non_delivery_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
  }
}
nas_non_delivery_ind_ies_o::value_c::value_c(const nas_non_delivery_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
  }
}
nas_non_delivery_ind_ies_o::value_c&
nas_non_delivery_ind_ies_o::value_c::operator=(const nas_non_delivery_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& nas_non_delivery_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& nas_non_delivery_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& nas_non_delivery_ind_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
cause_c& nas_non_delivery_ind_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const uint64_t& nas_non_delivery_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& nas_non_delivery_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& nas_non_delivery_ind_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const cause_c& nas_non_delivery_ind_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void nas_non_delivery_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE nas_non_delivery_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE nas_non_delivery_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// NGResetAcknowledgeIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ng_reset_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {111, 19};
  return map_enum_number(names, 2, idx, "id");
}
bool ng_reset_ack_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {111, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ng_reset_ack_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 111:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ng_reset_ack_ies_o::value_c ng_reset_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 111:
      ret.set(value_c::types::ue_associated_lc_ng_conn_list);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ng_reset_ack_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 111:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ng_reset_ack_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      c.destroy<ue_associated_lc_ng_conn_list_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ng_reset_ack_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      c.init<ue_associated_lc_ng_conn_list_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ack_ies_o::value_c");
  }
}
ng_reset_ack_ies_o::value_c::value_c(const ng_reset_ack_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      c.init(other.c.get<ue_associated_lc_ng_conn_list_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ack_ies_o::value_c");
  }
}
ng_reset_ack_ies_o::value_c& ng_reset_ack_ies_o::value_c::operator=(const ng_reset_ack_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      c.set(other.c.get<ue_associated_lc_ng_conn_list_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ack_ies_o::value_c");
  }

  return *this;
}
ue_associated_lc_ng_conn_list_l& ng_reset_ack_ies_o::value_c::ue_associated_lc_ng_conn_list()
{
  assert_choice_type(types::ue_associated_lc_ng_conn_list, type_, "Value");
  return c.get<ue_associated_lc_ng_conn_list_l>();
}
crit_diagnostics_s& ng_reset_ack_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const ue_associated_lc_ng_conn_list_l& ng_reset_ack_ies_o::value_c::ue_associated_lc_ng_conn_list() const
{
  assert_choice_type(types::ue_associated_lc_ng_conn_list, type_, "Value");
  return c.get<ue_associated_lc_ng_conn_list_l>();
}
const crit_diagnostics_s& ng_reset_ack_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ng_reset_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      j.start_array("UE-associatedLogicalNG-connectionList");
      for (const auto& e1 : c.get<ue_associated_lc_ng_conn_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ack_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_reset_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_associated_lc_ng_conn_list_l>(), 1, 65536, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ack_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_reset_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_associated_lc_ng_conn_list_l>(), bref, 1, 65536, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ack_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// NGResetIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ng_reset_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {15, 88};
  return map_enum_number(names, 2, idx, "id");
}
bool ng_reset_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {15, 88};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ng_reset_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 15:
      return crit_e::ignore;
    case 88:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ng_reset_ies_o::value_c ng_reset_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 88:
      ret.set(value_c::types::reset_type);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ng_reset_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 15:
      return presence_e::mandatory;
    case 88:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ng_reset_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::reset_type:
      c.destroy<reset_type_c>();
      break;
    default:
      break;
  }
}
void ng_reset_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cause:
      c.init<cause_c>();
      break;
    case types::reset_type:
      c.init<reset_type_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ies_o::value_c");
  }
}
ng_reset_ies_o::value_c::value_c(const ng_reset_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::reset_type:
      c.init(other.c.get<reset_type_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ies_o::value_c");
  }
}
ng_reset_ies_o::value_c& ng_reset_ies_o::value_c::operator=(const ng_reset_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::reset_type:
      c.set(other.c.get<reset_type_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ies_o::value_c");
  }

  return *this;
}
cause_c& ng_reset_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
reset_type_c& ng_reset_ies_o::value_c::reset_type()
{
  assert_choice_type(types::reset_type, type_, "Value");
  return c.get<reset_type_c>();
}
const cause_c& ng_reset_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const reset_type_c& ng_reset_ies_o::value_c::reset_type() const
{
  assert_choice_type(types::reset_type, type_, "Value");
  return c.get<reset_type_c>();
}
void ng_reset_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::reset_type:
      j.write_fieldname("ResetType");
      c.get<reset_type_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_reset_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::reset_type:
      HANDLE_CODE(c.get<reset_type_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_reset_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::reset_type:
      HANDLE_CODE(c.get<reset_type_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// NGSetupFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ng_setup_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {15, 107, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool ng_setup_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {15, 107, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ng_setup_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 15:
      return crit_e::ignore;
    case 107:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ng_setup_fail_ies_o::value_c ng_setup_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 107:
      ret.set(value_c::types::time_to_wait);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ng_setup_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 15:
      return presence_e::mandatory;
    case 107:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ng_setup_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ng_setup_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cause:
      c.init<cause_c>();
      break;
    case types::time_to_wait:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_fail_ies_o::value_c");
  }
}
ng_setup_fail_ies_o::value_c::value_c(const ng_setup_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::time_to_wait:
      c.init(other.c.get<time_to_wait_e>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_fail_ies_o::value_c");
  }
}
ng_setup_fail_ies_o::value_c& ng_setup_fail_ies_o::value_c::operator=(const ng_setup_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::time_to_wait:
      c.set(other.c.get<time_to_wait_e>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_fail_ies_o::value_c");
  }

  return *this;
}
cause_c& ng_setup_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
time_to_wait_e& ng_setup_fail_ies_o::value_c::time_to_wait()
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
crit_diagnostics_s& ng_setup_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const cause_c& ng_setup_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const time_to_wait_e& ng_setup_fail_ies_o::value_c::time_to_wait() const
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
const crit_diagnostics_s& ng_setup_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ng_setup_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::time_to_wait:
      j.write_str("TimeToWait", c.get<time_to_wait_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_setup_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_setup_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// NGSetupRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ng_setup_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {27, 82, 102, 21, 147, 204, 273};
  return map_enum_number(names, 7, idx, "id");
}
bool ng_setup_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {27, 82, 102, 21, 147, 204, 273};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ng_setup_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 27:
      return crit_e::reject;
    case 82:
      return crit_e::ignore;
    case 102:
      return crit_e::reject;
    case 21:
      return crit_e::ignore;
    case 147:
      return crit_e::ignore;
    case 204:
      return crit_e::ignore;
    case 273:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ng_setup_request_ies_o::value_c ng_setup_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 27:
      ret.set(value_c::types::global_ran_node_id);
      break;
    case 82:
      ret.set(value_c::types::ran_node_name);
      break;
    case 102:
      ret.set(value_c::types::supported_ta_list);
      break;
    case 21:
      ret.set(value_c::types::default_paging_drx);
      break;
    case 147:
      ret.set(value_c::types::ue_retention_info);
      break;
    case 204:
      ret.set(value_c::types::nb_iot_default_paging_drx);
      break;
    case 273:
      ret.set(value_c::types::extended_ran_node_name);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ng_setup_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 27:
      return presence_e::mandatory;
    case 82:
      return presence_e::optional;
    case 102:
      return presence_e::mandatory;
    case 21:
      return presence_e::mandatory;
    case 147:
      return presence_e::optional;
    case 204:
      return presence_e::optional;
    case 273:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ng_setup_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::global_ran_node_id:
      c.destroy<global_ran_node_id_c>();
      break;
    case types::ran_node_name:
      c.destroy<printable_string<1, 150, true, true>>();
      break;
    case types::supported_ta_list:
      c.destroy<supported_ta_list_l>();
      break;
    case types::extended_ran_node_name:
      c.destroy<extended_ran_node_name_s>();
      break;
    default:
      break;
  }
}
void ng_setup_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::global_ran_node_id:
      c.init<global_ran_node_id_c>();
      break;
    case types::ran_node_name:
      c.init<printable_string<1, 150, true, true>>();
      break;
    case types::supported_ta_list:
      c.init<supported_ta_list_l>();
      break;
    case types::default_paging_drx:
      break;
    case types::ue_retention_info:
      break;
    case types::nb_iot_default_paging_drx:
      break;
    case types::extended_ran_node_name:
      c.init<extended_ran_node_name_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_request_ies_o::value_c");
  }
}
ng_setup_request_ies_o::value_c::value_c(const ng_setup_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::global_ran_node_id:
      c.init(other.c.get<global_ran_node_id_c>());
      break;
    case types::ran_node_name:
      c.init(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::supported_ta_list:
      c.init(other.c.get<supported_ta_list_l>());
      break;
    case types::default_paging_drx:
      c.init(other.c.get<paging_drx_e>());
      break;
    case types::ue_retention_info:
      c.init(other.c.get<ue_retention_info_e>());
      break;
    case types::nb_iot_default_paging_drx:
      c.init(other.c.get<nb_iot_default_paging_drx_e>());
      break;
    case types::extended_ran_node_name:
      c.init(other.c.get<extended_ran_node_name_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_request_ies_o::value_c");
  }
}
ng_setup_request_ies_o::value_c&
ng_setup_request_ies_o::value_c::operator=(const ng_setup_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::global_ran_node_id:
      c.set(other.c.get<global_ran_node_id_c>());
      break;
    case types::ran_node_name:
      c.set(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::supported_ta_list:
      c.set(other.c.get<supported_ta_list_l>());
      break;
    case types::default_paging_drx:
      c.set(other.c.get<paging_drx_e>());
      break;
    case types::ue_retention_info:
      c.set(other.c.get<ue_retention_info_e>());
      break;
    case types::nb_iot_default_paging_drx:
      c.set(other.c.get<nb_iot_default_paging_drx_e>());
      break;
    case types::extended_ran_node_name:
      c.set(other.c.get<extended_ran_node_name_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_request_ies_o::value_c");
  }

  return *this;
}
global_ran_node_id_c& ng_setup_request_ies_o::value_c::global_ran_node_id()
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
printable_string<1, 150, true, true>& ng_setup_request_ies_o::value_c::ran_node_name()
{
  assert_choice_type(types::ran_node_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
supported_ta_list_l& ng_setup_request_ies_o::value_c::supported_ta_list()
{
  assert_choice_type(types::supported_ta_list, type_, "Value");
  return c.get<supported_ta_list_l>();
}
paging_drx_e& ng_setup_request_ies_o::value_c::default_paging_drx()
{
  assert_choice_type(types::default_paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
ue_retention_info_e& ng_setup_request_ies_o::value_c::ue_retention_info()
{
  assert_choice_type(types::ue_retention_info, type_, "Value");
  return c.get<ue_retention_info_e>();
}
nb_iot_default_paging_drx_e& ng_setup_request_ies_o::value_c::nb_iot_default_paging_drx()
{
  assert_choice_type(types::nb_iot_default_paging_drx, type_, "Value");
  return c.get<nb_iot_default_paging_drx_e>();
}
extended_ran_node_name_s& ng_setup_request_ies_o::value_c::extended_ran_node_name()
{
  assert_choice_type(types::extended_ran_node_name, type_, "Value");
  return c.get<extended_ran_node_name_s>();
}
const global_ran_node_id_c& ng_setup_request_ies_o::value_c::global_ran_node_id() const
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
const printable_string<1, 150, true, true>& ng_setup_request_ies_o::value_c::ran_node_name() const
{
  assert_choice_type(types::ran_node_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
const supported_ta_list_l& ng_setup_request_ies_o::value_c::supported_ta_list() const
{
  assert_choice_type(types::supported_ta_list, type_, "Value");
  return c.get<supported_ta_list_l>();
}
const paging_drx_e& ng_setup_request_ies_o::value_c::default_paging_drx() const
{
  assert_choice_type(types::default_paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
const ue_retention_info_e& ng_setup_request_ies_o::value_c::ue_retention_info() const
{
  assert_choice_type(types::ue_retention_info, type_, "Value");
  return c.get<ue_retention_info_e>();
}
const nb_iot_default_paging_drx_e& ng_setup_request_ies_o::value_c::nb_iot_default_paging_drx() const
{
  assert_choice_type(types::nb_iot_default_paging_drx, type_, "Value");
  return c.get<nb_iot_default_paging_drx_e>();
}
const extended_ran_node_name_s& ng_setup_request_ies_o::value_c::extended_ran_node_name() const
{
  assert_choice_type(types::extended_ran_node_name, type_, "Value");
  return c.get<extended_ran_node_name_s>();
}
void ng_setup_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::global_ran_node_id:
      j.write_fieldname("GlobalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    case types::ran_node_name:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true>>().to_string());
      break;
    case types::supported_ta_list:
      j.start_array("SupportedTAList");
      for (const auto& e1 : c.get<supported_ta_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::default_paging_drx:
      j.write_str("PagingDRX", c.get<paging_drx_e>().to_string());
      break;
    case types::ue_retention_info:
      j.write_str("UERetentionInformation", "ues-retained");
      break;
    case types::nb_iot_default_paging_drx:
      j.write_str("NB-IoT-DefaultPagingDRX", c.get<nb_iot_default_paging_drx_e>().to_string());
      break;
    case types::extended_ran_node_name:
      j.write_fieldname("Extended-RANNodeName");
      c.get<extended_ran_node_name_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_setup_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    case types::ran_node_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().pack(bref)));
      break;
    case types::supported_ta_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<supported_ta_list_l>(), 1, 256, true));
      break;
    case types::default_paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().pack(bref));
      break;
    case types::ue_retention_info:
      HANDLE_CODE(c.get<ue_retention_info_e>().pack(bref));
      break;
    case types::nb_iot_default_paging_drx:
      HANDLE_CODE(c.get<nb_iot_default_paging_drx_e>().pack(bref));
      break;
    case types::extended_ran_node_name:
      HANDLE_CODE(c.get<extended_ran_node_name_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_setup_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    case types::ran_node_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().unpack(bref)));
      break;
    case types::supported_ta_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<supported_ta_list_l>(), bref, 1, 256, true));
      break;
    case types::default_paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().unpack(bref));
      break;
    case types::ue_retention_info:
      HANDLE_CODE(c.get<ue_retention_info_e>().unpack(bref));
      break;
    case types::nb_iot_default_paging_drx:
      HANDLE_CODE(c.get<nb_iot_default_paging_drx_e>().unpack(bref));
      break;
    case types::extended_ran_node_name:
      HANDLE_CODE(c.get<extended_ran_node_name_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// NGSetupResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ng_setup_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {1, 96, 86, 80, 19, 147, 200, 274};
  return map_enum_number(names, 8, idx, "id");
}
bool ng_setup_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {1, 96, 86, 80, 19, 147, 200, 274};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ng_setup_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 1:
      return crit_e::reject;
    case 96:
      return crit_e::reject;
    case 86:
      return crit_e::ignore;
    case 80:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    case 147:
      return crit_e::ignore;
    case 200:
      return crit_e::ignore;
    case 274:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ng_setup_resp_ies_o::value_c ng_setup_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 1:
      ret.set(value_c::types::amf_name);
      break;
    case 96:
      ret.set(value_c::types::served_guami_list);
      break;
    case 86:
      ret.set(value_c::types::relative_amf_capacity);
      break;
    case 80:
      ret.set(value_c::types::plmn_support_list);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 147:
      ret.set(value_c::types::ue_retention_info);
      break;
    case 200:
      ret.set(value_c::types::iab_supported);
      break;
    case 274:
      ret.set(value_c::types::extended_amf_name);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ng_setup_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 1:
      return presence_e::mandatory;
    case 96:
      return presence_e::mandatory;
    case 86:
      return presence_e::mandatory;
    case 80:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    case 147:
      return presence_e::optional;
    case 200:
      return presence_e::optional;
    case 274:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ng_setup_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::amf_name:
      c.destroy<printable_string<1, 150, true, true>>();
      break;
    case types::served_guami_list:
      c.destroy<served_guami_list_l>();
      break;
    case types::plmn_support_list:
      c.destroy<plmn_support_list_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::extended_amf_name:
      c.destroy<extended_amf_name_s>();
      break;
    default:
      break;
  }
}
void ng_setup_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_name:
      c.init<printable_string<1, 150, true, true>>();
      break;
    case types::served_guami_list:
      c.init<served_guami_list_l>();
      break;
    case types::relative_amf_capacity:
      break;
    case types::plmn_support_list:
      c.init<plmn_support_list_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::ue_retention_info:
      break;
    case types::iab_supported:
      break;
    case types::extended_amf_name:
      c.init<extended_amf_name_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_resp_ies_o::value_c");
  }
}
ng_setup_resp_ies_o::value_c::value_c(const ng_setup_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_name:
      c.init(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::served_guami_list:
      c.init(other.c.get<served_guami_list_l>());
      break;
    case types::relative_amf_capacity:
      c.init(other.c.get<uint16_t>());
      break;
    case types::plmn_support_list:
      c.init(other.c.get<plmn_support_list_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::ue_retention_info:
      c.init(other.c.get<ue_retention_info_e>());
      break;
    case types::iab_supported:
      c.init(other.c.get<iab_supported_e>());
      break;
    case types::extended_amf_name:
      c.init(other.c.get<extended_amf_name_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_resp_ies_o::value_c");
  }
}
ng_setup_resp_ies_o::value_c& ng_setup_resp_ies_o::value_c::operator=(const ng_setup_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_name:
      c.set(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::served_guami_list:
      c.set(other.c.get<served_guami_list_l>());
      break;
    case types::relative_amf_capacity:
      c.set(other.c.get<uint16_t>());
      break;
    case types::plmn_support_list:
      c.set(other.c.get<plmn_support_list_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::ue_retention_info:
      c.set(other.c.get<ue_retention_info_e>());
      break;
    case types::iab_supported:
      c.set(other.c.get<iab_supported_e>());
      break;
    case types::extended_amf_name:
      c.set(other.c.get<extended_amf_name_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_resp_ies_o::value_c");
  }

  return *this;
}
printable_string<1, 150, true, true>& ng_setup_resp_ies_o::value_c::amf_name()
{
  assert_choice_type(types::amf_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
served_guami_list_l& ng_setup_resp_ies_o::value_c::served_guami_list()
{
  assert_choice_type(types::served_guami_list, type_, "Value");
  return c.get<served_guami_list_l>();
}
uint16_t& ng_setup_resp_ies_o::value_c::relative_amf_capacity()
{
  assert_choice_type(types::relative_amf_capacity, type_, "Value");
  return c.get<uint16_t>();
}
plmn_support_list_l& ng_setup_resp_ies_o::value_c::plmn_support_list()
{
  assert_choice_type(types::plmn_support_list, type_, "Value");
  return c.get<plmn_support_list_l>();
}
crit_diagnostics_s& ng_setup_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
ue_retention_info_e& ng_setup_resp_ies_o::value_c::ue_retention_info()
{
  assert_choice_type(types::ue_retention_info, type_, "Value");
  return c.get<ue_retention_info_e>();
}
iab_supported_e& ng_setup_resp_ies_o::value_c::iab_supported()
{
  assert_choice_type(types::iab_supported, type_, "Value");
  return c.get<iab_supported_e>();
}
extended_amf_name_s& ng_setup_resp_ies_o::value_c::extended_amf_name()
{
  assert_choice_type(types::extended_amf_name, type_, "Value");
  return c.get<extended_amf_name_s>();
}
const printable_string<1, 150, true, true>& ng_setup_resp_ies_o::value_c::amf_name() const
{
  assert_choice_type(types::amf_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
const served_guami_list_l& ng_setup_resp_ies_o::value_c::served_guami_list() const
{
  assert_choice_type(types::served_guami_list, type_, "Value");
  return c.get<served_guami_list_l>();
}
const uint16_t& ng_setup_resp_ies_o::value_c::relative_amf_capacity() const
{
  assert_choice_type(types::relative_amf_capacity, type_, "Value");
  return c.get<uint16_t>();
}
const plmn_support_list_l& ng_setup_resp_ies_o::value_c::plmn_support_list() const
{
  assert_choice_type(types::plmn_support_list, type_, "Value");
  return c.get<plmn_support_list_l>();
}
const crit_diagnostics_s& ng_setup_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const ue_retention_info_e& ng_setup_resp_ies_o::value_c::ue_retention_info() const
{
  assert_choice_type(types::ue_retention_info, type_, "Value");
  return c.get<ue_retention_info_e>();
}
const iab_supported_e& ng_setup_resp_ies_o::value_c::iab_supported() const
{
  assert_choice_type(types::iab_supported, type_, "Value");
  return c.get<iab_supported_e>();
}
const extended_amf_name_s& ng_setup_resp_ies_o::value_c::extended_amf_name() const
{
  assert_choice_type(types::extended_amf_name, type_, "Value");
  return c.get<extended_amf_name_s>();
}
void ng_setup_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_name:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true>>().to_string());
      break;
    case types::served_guami_list:
      j.start_array("ServedGUAMIList");
      for (const auto& e1 : c.get<served_guami_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::relative_amf_capacity:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::plmn_support_list:
      j.start_array("PLMNSupportList");
      for (const auto& e1 : c.get<plmn_support_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::ue_retention_info:
      j.write_str("UERetentionInformation", "ues-retained");
      break;
    case types::iab_supported:
      j.write_str("IAB-Supported", "true");
      break;
    case types::extended_amf_name:
      j.write_fieldname("Extended-AMFName");
      c.get<extended_amf_name_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_setup_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().pack(bref)));
      break;
    case types::served_guami_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<served_guami_list_l>(), 1, 256, true));
      break;
    case types::relative_amf_capacity:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::plmn_support_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<plmn_support_list_l>(), 1, 12, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::ue_retention_info:
      HANDLE_CODE(c.get<ue_retention_info_e>().pack(bref));
      break;
    case types::iab_supported:
      HANDLE_CODE(c.get<iab_supported_e>().pack(bref));
      break;
    case types::extended_amf_name:
      HANDLE_CODE(c.get<extended_amf_name_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_setup_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().unpack(bref)));
      break;
    case types::served_guami_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<served_guami_list_l>(), bref, 1, 256, true));
      break;
    case types::relative_amf_capacity:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::plmn_support_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<plmn_support_list_l>(), bref, 1, 12, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::ue_retention_info:
      HANDLE_CODE(c.get<ue_retention_info_e>().unpack(bref));
      break;
    case types::iab_supported:
      HANDLE_CODE(c.get<iab_supported_e>().unpack(bref));
      break;
    case types::extended_amf_name:
      HANDLE_CODE(c.get<extended_amf_name_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// OverloadStartIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t overload_start_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {2, 9, 49};
  return map_enum_number(names, 3, idx, "id");
}
bool overload_start_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {2, 9, 49};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e overload_start_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 2:
      return crit_e::reject;
    case 9:
      return crit_e::ignore;
    case 49:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
overload_start_ies_o::value_c overload_start_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 2:
      ret.set(value_c::types::amf_overload_resp);
      break;
    case 9:
      ret.set(value_c::types::amf_traffic_load_reduction_ind);
      break;
    case 49:
      ret.set(value_c::types::overload_start_nssai_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e overload_start_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 2:
      return presence_e::optional;
    case 9:
      return presence_e::optional;
    case 49:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void overload_start_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::amf_overload_resp:
      c.destroy<overload_resp_c>();
      break;
    case types::overload_start_nssai_list:
      c.destroy<overload_start_nssai_list_l>();
      break;
    default:
      break;
  }
}
void overload_start_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_overload_resp:
      c.init<overload_resp_c>();
      break;
    case types::amf_traffic_load_reduction_ind:
      break;
    case types::overload_start_nssai_list:
      c.init<overload_start_nssai_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
  }
}
overload_start_ies_o::value_c::value_c(const overload_start_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_overload_resp:
      c.init(other.c.get<overload_resp_c>());
      break;
    case types::amf_traffic_load_reduction_ind:
      c.init(other.c.get<uint8_t>());
      break;
    case types::overload_start_nssai_list:
      c.init(other.c.get<overload_start_nssai_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
  }
}
overload_start_ies_o::value_c& overload_start_ies_o::value_c::operator=(const overload_start_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_overload_resp:
      c.set(other.c.get<overload_resp_c>());
      break;
    case types::amf_traffic_load_reduction_ind:
      c.set(other.c.get<uint8_t>());
      break;
    case types::overload_start_nssai_list:
      c.set(other.c.get<overload_start_nssai_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
  }

  return *this;
}
overload_resp_c& overload_start_ies_o::value_c::amf_overload_resp()
{
  assert_choice_type(types::amf_overload_resp, type_, "Value");
  return c.get<overload_resp_c>();
}
uint8_t& overload_start_ies_o::value_c::amf_traffic_load_reduction_ind()
{
  assert_choice_type(types::amf_traffic_load_reduction_ind, type_, "Value");
  return c.get<uint8_t>();
}
overload_start_nssai_list_l& overload_start_ies_o::value_c::overload_start_nssai_list()
{
  assert_choice_type(types::overload_start_nssai_list, type_, "Value");
  return c.get<overload_start_nssai_list_l>();
}
const overload_resp_c& overload_start_ies_o::value_c::amf_overload_resp() const
{
  assert_choice_type(types::amf_overload_resp, type_, "Value");
  return c.get<overload_resp_c>();
}
const uint8_t& overload_start_ies_o::value_c::amf_traffic_load_reduction_ind() const
{
  assert_choice_type(types::amf_traffic_load_reduction_ind, type_, "Value");
  return c.get<uint8_t>();
}
const overload_start_nssai_list_l& overload_start_ies_o::value_c::overload_start_nssai_list() const
{
  assert_choice_type(types::overload_start_nssai_list, type_, "Value");
  return c.get<overload_start_nssai_list_l>();
}
void overload_start_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_overload_resp:
      j.write_fieldname("OverloadResponse");
      c.get<overload_resp_c>().to_json(j);
      break;
    case types::amf_traffic_load_reduction_ind:
      j.write_int("INTEGER (1..99)", c.get<uint8_t>());
      break;
    case types::overload_start_nssai_list:
      j.start_array("OverloadStartNSSAIList");
      for (const auto& e1 : c.get<overload_start_nssai_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE overload_start_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_overload_resp:
      HANDLE_CODE(c.get<overload_resp_c>().pack(bref));
      break;
    case types::amf_traffic_load_reduction_ind:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)1u, (uint8_t)99u, false, true));
      break;
    case types::overload_start_nssai_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<overload_start_nssai_list_l>(), 1, 1024, true));
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE overload_start_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_overload_resp:
      HANDLE_CODE(c.get<overload_resp_c>().unpack(bref));
      break;
    case types::amf_traffic_load_reduction_ind:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)1u, (uint8_t)99u, false, true));
      break;
    case types::overload_start_nssai_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<overload_start_nssai_list_l>(), bref, 1, 1024, true));
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PDUSessionResourceModifyConfirmIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_modify_confirm_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 62, 131, 19};
  return map_enum_number(names, 5, idx, "id");
}
bool pdu_session_res_modify_confirm_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 62, 131, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_confirm_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 62:
      return crit_e::ignore;
    case 131:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_confirm_ies_o::value_c pdu_session_res_modify_confirm_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 62:
      ret.set(value_c::types::pdu_session_res_modify_list_mod_cfm);
      break;
    case 131:
      ret.set(value_c::types::pdu_session_res_failed_to_modify_list_mod_cfm);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_confirm_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 62:
      return presence_e::optional;
    case 131:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_modify_confirm_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_modify_list_mod_cfm:
      c.destroy<pdu_session_res_modify_list_mod_cfm_l>();
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      c.destroy<pdu_session_res_failed_to_modify_list_mod_cfm_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void pdu_session_res_modify_confirm_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_modify_list_mod_cfm:
      c.init<pdu_session_res_modify_list_mod_cfm_l>();
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      c.init<pdu_session_res_failed_to_modify_list_mod_cfm_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_ies_o::value_c");
  }
}
pdu_session_res_modify_confirm_ies_o::value_c::value_c(const pdu_session_res_modify_confirm_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_cfm:
      c.init(other.c.get<pdu_session_res_modify_list_mod_cfm_l>());
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      c.init(other.c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_ies_o::value_c");
  }
}
pdu_session_res_modify_confirm_ies_o::value_c&
pdu_session_res_modify_confirm_ies_o::value_c::operator=(const pdu_session_res_modify_confirm_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_cfm:
      c.set(other.c.get<pdu_session_res_modify_list_mod_cfm_l>());
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      c.set(other.c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_modify_confirm_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_modify_confirm_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_modify_list_mod_cfm_l&
pdu_session_res_modify_confirm_ies_o::value_c::pdu_session_res_modify_list_mod_cfm()
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_cfm, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_cfm_l>();
}
pdu_session_res_failed_to_modify_list_mod_cfm_l&
pdu_session_res_modify_confirm_ies_o::value_c::pdu_session_res_failed_to_modify_list_mod_cfm()
{
  assert_choice_type(types::pdu_session_res_failed_to_modify_list_mod_cfm, type_, "Value");
  return c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>();
}
crit_diagnostics_s& pdu_session_res_modify_confirm_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& pdu_session_res_modify_confirm_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_modify_confirm_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_modify_list_mod_cfm_l&
pdu_session_res_modify_confirm_ies_o::value_c::pdu_session_res_modify_list_mod_cfm() const
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_cfm, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_cfm_l>();
}
const pdu_session_res_failed_to_modify_list_mod_cfm_l&
pdu_session_res_modify_confirm_ies_o::value_c::pdu_session_res_failed_to_modify_list_mod_cfm() const
{
  assert_choice_type(types::pdu_session_res_failed_to_modify_list_mod_cfm, type_, "Value");
  return c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>();
}
const crit_diagnostics_s& pdu_session_res_modify_confirm_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void pdu_session_res_modify_confirm_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_cfm:
      j.start_array("PDUSessionResourceModifyListModCfm");
      for (const auto& e1 : c.get<pdu_session_res_modify_list_mod_cfm_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      j.start_array("PDUSessionResourceFailedToModifyListModCfm");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_confirm_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_cfm:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_modify_list_mod_cfm_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_confirm_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_cfm:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_modify_list_mod_cfm_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PDUSessionResourceModifyIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_modify_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 63, 121};
  return map_enum_number(names, 4, idx, "id");
}
bool pdu_session_res_modify_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 63, 121};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 63:
      return crit_e::reject;
    case 121:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_ind_ies_o::value_c pdu_session_res_modify_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 63:
      ret.set(value_c::types::pdu_session_res_modify_list_mod_ind);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 63:
      return presence_e::mandatory;
    case 121:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_modify_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_modify_list_mod_ind:
      c.destroy<pdu_session_res_modify_list_mod_ind_l>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    default:
      break;
  }
}
void pdu_session_res_modify_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_modify_list_mod_ind:
      c.init<pdu_session_res_modify_list_mod_ind_l>();
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_ies_o::value_c");
  }
}
pdu_session_res_modify_ind_ies_o::value_c::value_c(const pdu_session_res_modify_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_ind:
      c.init(other.c.get<pdu_session_res_modify_list_mod_ind_l>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_ies_o::value_c");
  }
}
pdu_session_res_modify_ind_ies_o::value_c&
pdu_session_res_modify_ind_ies_o::value_c::operator=(const pdu_session_res_modify_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_ind:
      c.set(other.c.get<pdu_session_res_modify_list_mod_ind_l>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_modify_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_modify_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_modify_list_mod_ind_l& pdu_session_res_modify_ind_ies_o::value_c::pdu_session_res_modify_list_mod_ind()
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_ind, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_ind_l>();
}
user_location_info_c& pdu_session_res_modify_ind_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const uint64_t& pdu_session_res_modify_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_modify_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_modify_list_mod_ind_l&
pdu_session_res_modify_ind_ies_o::value_c::pdu_session_res_modify_list_mod_ind() const
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_ind, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_ind_l>();
}
const user_location_info_c& pdu_session_res_modify_ind_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
void pdu_session_res_modify_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_ind:
      j.start_array("PDUSessionResourceModifyListModInd");
      for (const auto& e1 : c.get<pdu_session_res_modify_list_mod_ind_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_ind:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_modify_list_mod_ind_l>(), 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_ind:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_modify_list_mod_ind_l>(), bref, 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PDUSessionResourceModifyRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_modify_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 83, 64};
  return map_enum_number(names, 4, idx, "id");
}
bool pdu_session_res_modify_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 83, 64};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 83:
      return crit_e::ignore;
    case 64:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_request_ies_o::value_c pdu_session_res_modify_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 83:
      ret.set(value_c::types::ran_paging_prio);
      break;
    case 64:
      ret.set(value_c::types::pdu_session_res_modify_list_mod_req);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 83:
      return presence_e::optional;
    case 64:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_modify_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_modify_list_mod_req:
      c.destroy<pdu_session_res_modify_list_mod_req_l>();
      break;
    default:
      break;
  }
}
void pdu_session_res_modify_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ran_paging_prio:
      break;
    case types::pdu_session_res_modify_list_mod_req:
      c.init<pdu_session_res_modify_list_mod_req_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_ies_o::value_c");
  }
}
pdu_session_res_modify_request_ies_o::value_c::value_c(const pdu_session_res_modify_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      c.init(other.c.get<uint16_t>());
      break;
    case types::pdu_session_res_modify_list_mod_req:
      c.init(other.c.get<pdu_session_res_modify_list_mod_req_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_ies_o::value_c");
  }
}
pdu_session_res_modify_request_ies_o::value_c&
pdu_session_res_modify_request_ies_o::value_c::operator=(const pdu_session_res_modify_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      c.set(other.c.get<uint16_t>());
      break;
    case types::pdu_session_res_modify_list_mod_req:
      c.set(other.c.get<pdu_session_res_modify_list_mod_req_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_modify_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_modify_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint16_t& pdu_session_res_modify_request_ies_o::value_c::ran_paging_prio()
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
pdu_session_res_modify_list_mod_req_l&
pdu_session_res_modify_request_ies_o::value_c::pdu_session_res_modify_list_mod_req()
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_req, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_req_l>();
}
const uint64_t& pdu_session_res_modify_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_modify_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint16_t& pdu_session_res_modify_request_ies_o::value_c::ran_paging_prio() const
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
const pdu_session_res_modify_list_mod_req_l&
pdu_session_res_modify_request_ies_o::value_c::pdu_session_res_modify_list_mod_req() const
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_req, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_req_l>();
}
void pdu_session_res_modify_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      j.write_int("INTEGER (1..256)", c.get<uint16_t>());
      break;
    case types::pdu_session_res_modify_list_mod_req:
      j.start_array("PDUSessionResourceModifyListModReq");
      for (const auto& e1 : c.get<pdu_session_res_modify_list_mod_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_modify_list_mod_req_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_modify_list_mod_req_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PDUSessionResourceModifyResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_modify_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 65, 54, 121, 19};
  return map_enum_number(names, 6, idx, "id");
}
bool pdu_session_res_modify_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 65, 54, 121, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 65:
      return crit_e::ignore;
    case 54:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_resp_ies_o::value_c pdu_session_res_modify_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 65:
      ret.set(value_c::types::pdu_session_res_modify_list_mod_res);
      break;
    case 54:
      ret.set(value_c::types::pdu_session_res_failed_to_modify_list_mod_res);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 65:
      return presence_e::optional;
    case 54:
      return presence_e::optional;
    case 121:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_modify_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_modify_list_mod_res:
      c.destroy<pdu_session_res_modify_list_mod_res_l>();
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      c.destroy<pdu_session_res_failed_to_modify_list_mod_res_l>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void pdu_session_res_modify_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_modify_list_mod_res:
      c.init<pdu_session_res_modify_list_mod_res_l>();
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      c.init<pdu_session_res_failed_to_modify_list_mod_res_l>();
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_ies_o::value_c");
  }
}
pdu_session_res_modify_resp_ies_o::value_c::value_c(const pdu_session_res_modify_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_res:
      c.init(other.c.get<pdu_session_res_modify_list_mod_res_l>());
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      c.init(other.c.get<pdu_session_res_failed_to_modify_list_mod_res_l>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_ies_o::value_c");
  }
}
pdu_session_res_modify_resp_ies_o::value_c&
pdu_session_res_modify_resp_ies_o::value_c::operator=(const pdu_session_res_modify_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_res:
      c.set(other.c.get<pdu_session_res_modify_list_mod_res_l>());
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      c.set(other.c.get<pdu_session_res_failed_to_modify_list_mod_res_l>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_modify_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_modify_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_modify_list_mod_res_l& pdu_session_res_modify_resp_ies_o::value_c::pdu_session_res_modify_list_mod_res()
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_res, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_res_l>();
}
pdu_session_res_failed_to_modify_list_mod_res_l&
pdu_session_res_modify_resp_ies_o::value_c::pdu_session_res_failed_to_modify_list_mod_res()
{
  assert_choice_type(types::pdu_session_res_failed_to_modify_list_mod_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_modify_list_mod_res_l>();
}
user_location_info_c& pdu_session_res_modify_resp_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
crit_diagnostics_s& pdu_session_res_modify_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& pdu_session_res_modify_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_modify_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_modify_list_mod_res_l&
pdu_session_res_modify_resp_ies_o::value_c::pdu_session_res_modify_list_mod_res() const
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_res, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_res_l>();
}
const pdu_session_res_failed_to_modify_list_mod_res_l&
pdu_session_res_modify_resp_ies_o::value_c::pdu_session_res_failed_to_modify_list_mod_res() const
{
  assert_choice_type(types::pdu_session_res_failed_to_modify_list_mod_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_modify_list_mod_res_l>();
}
const user_location_info_c& pdu_session_res_modify_resp_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const crit_diagnostics_s& pdu_session_res_modify_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void pdu_session_res_modify_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_res:
      j.start_array("PDUSessionResourceModifyListModRes");
      for (const auto& e1 : c.get<pdu_session_res_modify_list_mod_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      j.start_array("PDUSessionResourceFailedToModifyListModRes");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_modify_list_mod_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_modify_list_mod_res_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_modify_list_mod_res_l>(), 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_modify_list_mod_res_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_modify_list_mod_res_l>(), bref, 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PDUSessionResourceNotifyIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_notify_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 66, 67, 121};
  return map_enum_number(names, 5, idx, "id");
}
bool pdu_session_res_notify_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 66, 67, 121};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_notify_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 66:
      return crit_e::reject;
    case 67:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_notify_ies_o::value_c pdu_session_res_notify_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 66:
      ret.set(value_c::types::pdu_session_res_notify_list);
      break;
    case 67:
      ret.set(value_c::types::pdu_session_res_released_list_not);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_notify_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 66:
      return presence_e::optional;
    case 67:
      return presence_e::optional;
    case 121:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_notify_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_notify_list:
      c.destroy<pdu_session_res_notify_list_l>();
      break;
    case types::pdu_session_res_released_list_not:
      c.destroy<pdu_session_res_released_list_not_l>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    default:
      break;
  }
}
void pdu_session_res_notify_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_notify_list:
      c.init<pdu_session_res_notify_list_l>();
      break;
    case types::pdu_session_res_released_list_not:
      c.init<pdu_session_res_released_list_not_l>();
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_ies_o::value_c");
  }
}
pdu_session_res_notify_ies_o::value_c::value_c(const pdu_session_res_notify_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_notify_list:
      c.init(other.c.get<pdu_session_res_notify_list_l>());
      break;
    case types::pdu_session_res_released_list_not:
      c.init(other.c.get<pdu_session_res_released_list_not_l>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_ies_o::value_c");
  }
}
pdu_session_res_notify_ies_o::value_c&
pdu_session_res_notify_ies_o::value_c::operator=(const pdu_session_res_notify_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_notify_list:
      c.set(other.c.get<pdu_session_res_notify_list_l>());
      break;
    case types::pdu_session_res_released_list_not:
      c.set(other.c.get<pdu_session_res_released_list_not_l>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_notify_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_notify_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_notify_list_l& pdu_session_res_notify_ies_o::value_c::pdu_session_res_notify_list()
{
  assert_choice_type(types::pdu_session_res_notify_list, type_, "Value");
  return c.get<pdu_session_res_notify_list_l>();
}
pdu_session_res_released_list_not_l& pdu_session_res_notify_ies_o::value_c::pdu_session_res_released_list_not()
{
  assert_choice_type(types::pdu_session_res_released_list_not, type_, "Value");
  return c.get<pdu_session_res_released_list_not_l>();
}
user_location_info_c& pdu_session_res_notify_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const uint64_t& pdu_session_res_notify_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_notify_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_notify_list_l& pdu_session_res_notify_ies_o::value_c::pdu_session_res_notify_list() const
{
  assert_choice_type(types::pdu_session_res_notify_list, type_, "Value");
  return c.get<pdu_session_res_notify_list_l>();
}
const pdu_session_res_released_list_not_l&
pdu_session_res_notify_ies_o::value_c::pdu_session_res_released_list_not() const
{
  assert_choice_type(types::pdu_session_res_released_list_not, type_, "Value");
  return c.get<pdu_session_res_released_list_not_l>();
}
const user_location_info_c& pdu_session_res_notify_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
void pdu_session_res_notify_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_notify_list:
      j.start_array("PDUSessionResourceNotifyList");
      for (const auto& e1 : c.get<pdu_session_res_notify_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_released_list_not:
      j.start_array("PDUSessionResourceReleasedListNot");
      for (const auto& e1 : c.get<pdu_session_res_released_list_not_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_notify_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_notify_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_notify_list_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_released_list_not:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_released_list_not_l>(), 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_notify_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_notify_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_notify_list_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_released_list_not:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_released_list_not_l>(), bref, 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PDUSessionResourceReleaseCommandIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_release_cmd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 83, 38, 79};
  return map_enum_number(names, 5, idx, "id");
}
bool pdu_session_res_release_cmd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 83, 38, 79};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_release_cmd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 83:
      return crit_e::ignore;
    case 38:
      return crit_e::ignore;
    case 79:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_release_cmd_ies_o::value_c pdu_session_res_release_cmd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 83:
      ret.set(value_c::types::ran_paging_prio);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 79:
      ret.set(value_c::types::pdu_session_res_to_release_list_rel_cmd);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_release_cmd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 83:
      return presence_e::optional;
    case 38:
      return presence_e::optional;
    case 79:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_release_cmd_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      c.destroy<pdu_session_res_to_release_list_rel_cmd_l>();
      break;
    default:
      break;
  }
}
void pdu_session_res_release_cmd_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ran_paging_prio:
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      c.init<pdu_session_res_to_release_list_rel_cmd_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_cmd_ies_o::value_c");
  }
}
pdu_session_res_release_cmd_ies_o::value_c::value_c(const pdu_session_res_release_cmd_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      c.init(other.c.get<uint16_t>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      c.init(other.c.get<pdu_session_res_to_release_list_rel_cmd_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_cmd_ies_o::value_c");
  }
}
pdu_session_res_release_cmd_ies_o::value_c&
pdu_session_res_release_cmd_ies_o::value_c::operator=(const pdu_session_res_release_cmd_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      c.set(other.c.get<uint16_t>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      c.set(other.c.get<pdu_session_res_to_release_list_rel_cmd_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_cmd_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_release_cmd_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_release_cmd_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint16_t& pdu_session_res_release_cmd_ies_o::value_c::ran_paging_prio()
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
unbounded_octstring<true>& pdu_session_res_release_cmd_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
pdu_session_res_to_release_list_rel_cmd_l&
pdu_session_res_release_cmd_ies_o::value_c::pdu_session_res_to_release_list_rel_cmd()
{
  assert_choice_type(types::pdu_session_res_to_release_list_rel_cmd, type_, "Value");
  return c.get<pdu_session_res_to_release_list_rel_cmd_l>();
}
const uint64_t& pdu_session_res_release_cmd_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_release_cmd_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint16_t& pdu_session_res_release_cmd_ies_o::value_c::ran_paging_prio() const
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
const unbounded_octstring<true>& pdu_session_res_release_cmd_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const pdu_session_res_to_release_list_rel_cmd_l&
pdu_session_res_release_cmd_ies_o::value_c::pdu_session_res_to_release_list_rel_cmd() const
{
  assert_choice_type(types::pdu_session_res_to_release_list_rel_cmd, type_, "Value");
  return c.get<pdu_session_res_to_release_list_rel_cmd_l>();
}
void pdu_session_res_release_cmd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      j.write_int("INTEGER (1..256)", c.get<uint16_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      j.start_array("PDUSessionResourceToReleaseListRelCmd");
      for (const auto& e1 : c.get<pdu_session_res_to_release_list_rel_cmd_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_cmd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_release_cmd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_to_release_list_rel_cmd_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_cmd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_release_cmd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_to_release_list_rel_cmd_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_cmd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PDUSessionResourceReleaseResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_release_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 70, 121, 19};
  return map_enum_number(names, 5, idx, "id");
}
bool pdu_session_res_release_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 70, 121, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_release_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 70:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_release_resp_ies_o::value_c pdu_session_res_release_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 70:
      ret.set(value_c::types::pdu_session_res_released_list_rel_res);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_release_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 70:
      return presence_e::mandatory;
    case 121:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_release_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_released_list_rel_res:
      c.destroy<pdu_session_res_released_list_rel_res_l>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void pdu_session_res_release_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_released_list_rel_res:
      c.init<pdu_session_res_released_list_rel_res_l>();
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_resp_ies_o::value_c");
  }
}
pdu_session_res_release_resp_ies_o::value_c::value_c(const pdu_session_res_release_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_released_list_rel_res:
      c.init(other.c.get<pdu_session_res_released_list_rel_res_l>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_resp_ies_o::value_c");
  }
}
pdu_session_res_release_resp_ies_o::value_c&
pdu_session_res_release_resp_ies_o::value_c::operator=(const pdu_session_res_release_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_released_list_rel_res:
      c.set(other.c.get<pdu_session_res_released_list_rel_res_l>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_release_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_release_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_released_list_rel_res_l&
pdu_session_res_release_resp_ies_o::value_c::pdu_session_res_released_list_rel_res()
{
  assert_choice_type(types::pdu_session_res_released_list_rel_res, type_, "Value");
  return c.get<pdu_session_res_released_list_rel_res_l>();
}
user_location_info_c& pdu_session_res_release_resp_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
crit_diagnostics_s& pdu_session_res_release_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& pdu_session_res_release_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_release_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_released_list_rel_res_l&
pdu_session_res_release_resp_ies_o::value_c::pdu_session_res_released_list_rel_res() const
{
  assert_choice_type(types::pdu_session_res_released_list_rel_res, type_, "Value");
  return c.get<pdu_session_res_released_list_rel_res_l>();
}
const user_location_info_c& pdu_session_res_release_resp_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const crit_diagnostics_s& pdu_session_res_release_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void pdu_session_res_release_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_released_list_rel_res:
      j.start_array("PDUSessionResourceReleasedListRelRes");
      for (const auto& e1 : c.get<pdu_session_res_released_list_rel_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_release_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_released_list_rel_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_released_list_rel_res_l>(), 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_release_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_released_list_rel_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_released_list_rel_res_l>(), bref, 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PDUSessionResourceSetupRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_setup_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 83, 38, 74, 110, 335};
  return map_enum_number(names, 7, idx, "id");
}
bool pdu_session_res_setup_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 83, 38, 74, 110, 335};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_setup_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 83:
      return crit_e::ignore;
    case 38:
      return crit_e::reject;
    case 74:
      return crit_e::reject;
    case 110:
      return crit_e::ignore;
    case 335:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_setup_request_ies_o::value_c pdu_session_res_setup_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 83:
      ret.set(value_c::types::ran_paging_prio);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 74:
      ret.set(value_c::types::pdu_session_res_setup_list_su_req);
      break;
    case 110:
      ret.set(value_c::types::ue_aggr_max_bit_rate);
      break;
    case 335:
      ret.set(value_c::types::ue_slice_max_bit_rate_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_setup_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 83:
      return presence_e::optional;
    case 38:
      return presence_e::optional;
    case 74:
      return presence_e::mandatory;
    case 110:
      return presence_e::optional;
    case 335:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_setup_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::pdu_session_res_setup_list_su_req:
      c.destroy<pdu_session_res_setup_list_su_req_l>();
      break;
    case types::ue_aggr_max_bit_rate:
      c.destroy<ue_aggr_max_bit_rate_s>();
      break;
    case types::ue_slice_max_bit_rate_list:
      c.destroy<ue_slice_max_bit_rate_list_l>();
      break;
    default:
      break;
  }
}
void pdu_session_res_setup_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ran_paging_prio:
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::pdu_session_res_setup_list_su_req:
      c.init<pdu_session_res_setup_list_su_req_l>();
      break;
    case types::ue_aggr_max_bit_rate:
      c.init<ue_aggr_max_bit_rate_s>();
      break;
    case types::ue_slice_max_bit_rate_list:
      c.init<ue_slice_max_bit_rate_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_ies_o::value_c");
  }
}
pdu_session_res_setup_request_ies_o::value_c::value_c(const pdu_session_res_setup_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      c.init(other.c.get<uint16_t>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdu_session_res_setup_list_su_req:
      c.init(other.c.get<pdu_session_res_setup_list_su_req_l>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.init(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::ue_slice_max_bit_rate_list:
      c.init(other.c.get<ue_slice_max_bit_rate_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_ies_o::value_c");
  }
}
pdu_session_res_setup_request_ies_o::value_c&
pdu_session_res_setup_request_ies_o::value_c::operator=(const pdu_session_res_setup_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      c.set(other.c.get<uint16_t>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdu_session_res_setup_list_su_req:
      c.set(other.c.get<pdu_session_res_setup_list_su_req_l>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.set(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::ue_slice_max_bit_rate_list:
      c.set(other.c.get<ue_slice_max_bit_rate_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_setup_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_setup_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint16_t& pdu_session_res_setup_request_ies_o::value_c::ran_paging_prio()
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
unbounded_octstring<true>& pdu_session_res_setup_request_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
pdu_session_res_setup_list_su_req_l& pdu_session_res_setup_request_ies_o::value_c::pdu_session_res_setup_list_su_req()
{
  assert_choice_type(types::pdu_session_res_setup_list_su_req, type_, "Value");
  return c.get<pdu_session_res_setup_list_su_req_l>();
}
ue_aggr_max_bit_rate_s& pdu_session_res_setup_request_ies_o::value_c::ue_aggr_max_bit_rate()
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
ue_slice_max_bit_rate_list_l& pdu_session_res_setup_request_ies_o::value_c::ue_slice_max_bit_rate_list()
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
const uint64_t& pdu_session_res_setup_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_setup_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint16_t& pdu_session_res_setup_request_ies_o::value_c::ran_paging_prio() const
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
const unbounded_octstring<true>& pdu_session_res_setup_request_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const pdu_session_res_setup_list_su_req_l&
pdu_session_res_setup_request_ies_o::value_c::pdu_session_res_setup_list_su_req() const
{
  assert_choice_type(types::pdu_session_res_setup_list_su_req, type_, "Value");
  return c.get<pdu_session_res_setup_list_su_req_l>();
}
const ue_aggr_max_bit_rate_s& pdu_session_res_setup_request_ies_o::value_c::ue_aggr_max_bit_rate() const
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
const ue_slice_max_bit_rate_list_l& pdu_session_res_setup_request_ies_o::value_c::ue_slice_max_bit_rate_list() const
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
void pdu_session_res_setup_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      j.write_int("INTEGER (1..256)", c.get<uint16_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::pdu_session_res_setup_list_su_req:
      j.start_array("PDUSessionResourceSetupListSUReq");
      for (const auto& e1 : c.get<pdu_session_res_setup_list_su_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ue_aggr_max_bit_rate:
      j.write_fieldname("UEAggregateMaximumBitRate");
      c.get<ue_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::ue_slice_max_bit_rate_list:
      j.start_array("UESliceMaximumBitRateList");
      for (const auto& e1 : c.get<ue_slice_max_bit_rate_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_setup_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::pdu_session_res_setup_list_su_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_setup_list_su_req_l>(), 1, 256, true));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_slice_max_bit_rate_list_l>(), 1, 8, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::pdu_session_res_setup_list_su_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_setup_list_su_req_l>(), bref, 1, 256, true));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_slice_max_bit_rate_list_l>(), bref, 1, 8, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PDUSessionResourceSetupResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_setup_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 75, 58, 19, 121};
  return map_enum_number(names, 6, idx, "id");
}
bool pdu_session_res_setup_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 75, 58, 19, 121};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_setup_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 75:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_setup_resp_ies_o::value_c pdu_session_res_setup_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 75:
      ret.set(value_c::types::pdu_session_res_setup_list_su_res);
      break;
    case 58:
      ret.set(value_c::types::pdu_session_res_failed_to_setup_list_su_res);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_setup_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 75:
      return presence_e::optional;
    case 58:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    case 121:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_setup_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_setup_list_su_res:
      c.destroy<pdu_session_res_setup_list_su_res_l>();
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      c.destroy<pdu_session_res_failed_to_setup_list_su_res_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    default:
      break;
  }
}
void pdu_session_res_setup_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_setup_list_su_res:
      c.init<pdu_session_res_setup_list_su_res_l>();
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      c.init<pdu_session_res_failed_to_setup_list_su_res_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_ies_o::value_c");
  }
}
pdu_session_res_setup_resp_ies_o::value_c::value_c(const pdu_session_res_setup_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_setup_list_su_res:
      c.init(other.c.get<pdu_session_res_setup_list_su_res_l>());
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      c.init(other.c.get<pdu_session_res_failed_to_setup_list_su_res_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_ies_o::value_c");
  }
}
pdu_session_res_setup_resp_ies_o::value_c&
pdu_session_res_setup_resp_ies_o::value_c::operator=(const pdu_session_res_setup_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_setup_list_su_res:
      c.set(other.c.get<pdu_session_res_setup_list_su_res_l>());
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      c.set(other.c.get<pdu_session_res_failed_to_setup_list_su_res_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_setup_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_setup_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_setup_list_su_res_l& pdu_session_res_setup_resp_ies_o::value_c::pdu_session_res_setup_list_su_res()
{
  assert_choice_type(types::pdu_session_res_setup_list_su_res, type_, "Value");
  return c.get<pdu_session_res_setup_list_su_res_l>();
}
pdu_session_res_failed_to_setup_list_su_res_l&
pdu_session_res_setup_resp_ies_o::value_c::pdu_session_res_failed_to_setup_list_su_res()
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_su_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_su_res_l>();
}
crit_diagnostics_s& pdu_session_res_setup_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
user_location_info_c& pdu_session_res_setup_resp_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const uint64_t& pdu_session_res_setup_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_setup_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_setup_list_su_res_l&
pdu_session_res_setup_resp_ies_o::value_c::pdu_session_res_setup_list_su_res() const
{
  assert_choice_type(types::pdu_session_res_setup_list_su_res, type_, "Value");
  return c.get<pdu_session_res_setup_list_su_res_l>();
}
const pdu_session_res_failed_to_setup_list_su_res_l&
pdu_session_res_setup_resp_ies_o::value_c::pdu_session_res_failed_to_setup_list_su_res() const
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_su_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_su_res_l>();
}
const crit_diagnostics_s& pdu_session_res_setup_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const user_location_info_c& pdu_session_res_setup_resp_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
void pdu_session_res_setup_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_setup_list_su_res:
      j.start_array("PDUSessionResourceSetupListSURes");
      for (const auto& e1 : c.get<pdu_session_res_setup_list_su_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      j.start_array("PDUSessionResourceFailedToSetupListSURes");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_setup_list_su_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_setup_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_setup_list_su_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_setup_list_su_res_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_setup_list_su_res_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_setup_list_su_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_setup_list_su_res_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_setup_list_su_res_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PWSCancelRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pws_cancel_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {35, 95, 122, 14};
  return map_enum_number(names, 4, idx, "id");
}
bool pws_cancel_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {35, 95, 122, 14};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pws_cancel_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 35:
      return crit_e::reject;
    case 95:
      return crit_e::reject;
    case 122:
      return crit_e::ignore;
    case 14:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pws_cancel_request_ies_o::value_c pws_cancel_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 35:
      ret.set(value_c::types::msg_id);
      break;
    case 95:
      ret.set(value_c::types::serial_num);
      break;
    case 122:
      ret.set(value_c::types::warning_area_list);
      break;
    case 14:
      ret.set(value_c::types::cancel_all_warning_msgs);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pws_cancel_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 35:
      return presence_e::mandatory;
    case 95:
      return presence_e::mandatory;
    case 122:
      return presence_e::optional;
    case 14:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pws_cancel_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::msg_id:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::serial_num:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::warning_area_list:
      c.destroy<warning_area_list_c>();
      break;
    default:
      break;
  }
}
void pws_cancel_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::msg_id:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::serial_num:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::warning_area_list:
      c.init<warning_area_list_c>();
      break;
    case types::cancel_all_warning_msgs:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_request_ies_o::value_c");
  }
}
pws_cancel_request_ies_o::value_c::value_c(const pws_cancel_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::msg_id:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::serial_num:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::warning_area_list:
      c.init(other.c.get<warning_area_list_c>());
      break;
    case types::cancel_all_warning_msgs:
      c.init(other.c.get<cancel_all_warning_msgs_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_request_ies_o::value_c");
  }
}
pws_cancel_request_ies_o::value_c&
pws_cancel_request_ies_o::value_c::operator=(const pws_cancel_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::msg_id:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::serial_num:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::warning_area_list:
      c.set(other.c.get<warning_area_list_c>());
      break;
    case types::cancel_all_warning_msgs:
      c.set(other.c.get<cancel_all_warning_msgs_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_request_ies_o::value_c");
  }

  return *this;
}
fixed_bitstring<16, false, true>& pws_cancel_request_ies_o::value_c::msg_id()
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
fixed_bitstring<16, false, true>& pws_cancel_request_ies_o::value_c::serial_num()
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
warning_area_list_c& pws_cancel_request_ies_o::value_c::warning_area_list()
{
  assert_choice_type(types::warning_area_list, type_, "Value");
  return c.get<warning_area_list_c>();
}
cancel_all_warning_msgs_e& pws_cancel_request_ies_o::value_c::cancel_all_warning_msgs()
{
  assert_choice_type(types::cancel_all_warning_msgs, type_, "Value");
  return c.get<cancel_all_warning_msgs_e>();
}
const fixed_bitstring<16, false, true>& pws_cancel_request_ies_o::value_c::msg_id() const
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const fixed_bitstring<16, false, true>& pws_cancel_request_ies_o::value_c::serial_num() const
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const warning_area_list_c& pws_cancel_request_ies_o::value_c::warning_area_list() const
{
  assert_choice_type(types::warning_area_list, type_, "Value");
  return c.get<warning_area_list_c>();
}
const cancel_all_warning_msgs_e& pws_cancel_request_ies_o::value_c::cancel_all_warning_msgs() const
{
  assert_choice_type(types::cancel_all_warning_msgs, type_, "Value");
  return c.get<cancel_all_warning_msgs_e>();
}
void pws_cancel_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::msg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::serial_num:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::warning_area_list:
      j.write_fieldname("WarningAreaList");
      c.get<warning_area_list_c>().to_json(j);
      break;
    case types::cancel_all_warning_msgs:
      j.write_str("CancelAllWarningMessages", "true");
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pws_cancel_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::warning_area_list:
      HANDLE_CODE(c.get<warning_area_list_c>().pack(bref));
      break;
    case types::cancel_all_warning_msgs:
      HANDLE_CODE(c.get<cancel_all_warning_msgs_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_cancel_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::warning_area_list:
      HANDLE_CODE(c.get<warning_area_list_c>().unpack(bref));
      break;
    case types::cancel_all_warning_msgs:
      HANDLE_CODE(c.get<cancel_all_warning_msgs_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PWSCancelResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pws_cancel_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {35, 95, 12, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool pws_cancel_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {35, 95, 12, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pws_cancel_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 35:
      return crit_e::reject;
    case 95:
      return crit_e::reject;
    case 12:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pws_cancel_resp_ies_o::value_c pws_cancel_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 35:
      ret.set(value_c::types::msg_id);
      break;
    case 95:
      ret.set(value_c::types::serial_num);
      break;
    case 12:
      ret.set(value_c::types::broadcast_cancelled_area_list);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pws_cancel_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 35:
      return presence_e::mandatory;
    case 95:
      return presence_e::mandatory;
    case 12:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pws_cancel_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::msg_id:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::serial_num:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::broadcast_cancelled_area_list:
      c.destroy<broadcast_cancelled_area_list_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void pws_cancel_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::msg_id:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::serial_num:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::broadcast_cancelled_area_list:
      c.init<broadcast_cancelled_area_list_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_resp_ies_o::value_c");
  }
}
pws_cancel_resp_ies_o::value_c::value_c(const pws_cancel_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::msg_id:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::serial_num:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::broadcast_cancelled_area_list:
      c.init(other.c.get<broadcast_cancelled_area_list_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_resp_ies_o::value_c");
  }
}
pws_cancel_resp_ies_o::value_c& pws_cancel_resp_ies_o::value_c::operator=(const pws_cancel_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::msg_id:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::serial_num:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::broadcast_cancelled_area_list:
      c.set(other.c.get<broadcast_cancelled_area_list_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_resp_ies_o::value_c");
  }

  return *this;
}
fixed_bitstring<16, false, true>& pws_cancel_resp_ies_o::value_c::msg_id()
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
fixed_bitstring<16, false, true>& pws_cancel_resp_ies_o::value_c::serial_num()
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
broadcast_cancelled_area_list_c& pws_cancel_resp_ies_o::value_c::broadcast_cancelled_area_list()
{
  assert_choice_type(types::broadcast_cancelled_area_list, type_, "Value");
  return c.get<broadcast_cancelled_area_list_c>();
}
crit_diagnostics_s& pws_cancel_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const fixed_bitstring<16, false, true>& pws_cancel_resp_ies_o::value_c::msg_id() const
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const fixed_bitstring<16, false, true>& pws_cancel_resp_ies_o::value_c::serial_num() const
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const broadcast_cancelled_area_list_c& pws_cancel_resp_ies_o::value_c::broadcast_cancelled_area_list() const
{
  assert_choice_type(types::broadcast_cancelled_area_list, type_, "Value");
  return c.get<broadcast_cancelled_area_list_c>();
}
const crit_diagnostics_s& pws_cancel_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void pws_cancel_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::msg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::serial_num:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::broadcast_cancelled_area_list:
      j.write_fieldname("BroadcastCancelledAreaList");
      c.get<broadcast_cancelled_area_list_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pws_cancel_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::broadcast_cancelled_area_list:
      HANDLE_CODE(c.get<broadcast_cancelled_area_list_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_cancel_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::broadcast_cancelled_area_list:
      HANDLE_CODE(c.get<broadcast_cancelled_area_list_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PWSFailureIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pws_fail_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {81, 27};
  return map_enum_number(names, 2, idx, "id");
}
bool pws_fail_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {81, 27};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pws_fail_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 81:
      return crit_e::reject;
    case 27:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pws_fail_ind_ies_o::value_c pws_fail_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 81:
      ret.set(value_c::types::pws_failed_cell_id_list);
      break;
    case 27:
      ret.set(value_c::types::global_ran_node_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pws_fail_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 81:
      return presence_e::mandatory;
    case 27:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pws_fail_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pws_failed_cell_id_list:
      c.destroy<pws_failed_cell_id_list_c>();
      break;
    case types::global_ran_node_id:
      c.destroy<global_ran_node_id_c>();
      break;
    default:
      break;
  }
}
void pws_fail_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::pws_failed_cell_id_list:
      c.init<pws_failed_cell_id_list_c>();
      break;
    case types::global_ran_node_id:
      c.init<global_ran_node_id_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
  }
}
pws_fail_ind_ies_o::value_c::value_c(const pws_fail_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::pws_failed_cell_id_list:
      c.init(other.c.get<pws_failed_cell_id_list_c>());
      break;
    case types::global_ran_node_id:
      c.init(other.c.get<global_ran_node_id_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
  }
}
pws_fail_ind_ies_o::value_c& pws_fail_ind_ies_o::value_c::operator=(const pws_fail_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::pws_failed_cell_id_list:
      c.set(other.c.get<pws_failed_cell_id_list_c>());
      break;
    case types::global_ran_node_id:
      c.set(other.c.get<global_ran_node_id_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
  }

  return *this;
}
pws_failed_cell_id_list_c& pws_fail_ind_ies_o::value_c::pws_failed_cell_id_list()
{
  assert_choice_type(types::pws_failed_cell_id_list, type_, "Value");
  return c.get<pws_failed_cell_id_list_c>();
}
global_ran_node_id_c& pws_fail_ind_ies_o::value_c::global_ran_node_id()
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
const pws_failed_cell_id_list_c& pws_fail_ind_ies_o::value_c::pws_failed_cell_id_list() const
{
  assert_choice_type(types::pws_failed_cell_id_list, type_, "Value");
  return c.get<pws_failed_cell_id_list_c>();
}
const global_ran_node_id_c& pws_fail_ind_ies_o::value_c::global_ran_node_id() const
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
void pws_fail_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pws_failed_cell_id_list:
      j.write_fieldname("PWSFailedCellIDList");
      c.get<pws_failed_cell_id_list_c>().to_json(j);
      break;
    case types::global_ran_node_id:
      j.write_fieldname("GlobalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pws_fail_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pws_failed_cell_id_list:
      HANDLE_CODE(c.get<pws_failed_cell_id_list_c>().pack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_fail_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pws_failed_cell_id_list:
      HANDLE_CODE(c.get<pws_failed_cell_id_list_c>().unpack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PWSRestartIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pws_restart_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {16, 27, 104, 23};
  return map_enum_number(names, 4, idx, "id");
}
bool pws_restart_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {16, 27, 104, 23};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pws_restart_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 16:
      return crit_e::reject;
    case 27:
      return crit_e::reject;
    case 104:
      return crit_e::reject;
    case 23:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pws_restart_ind_ies_o::value_c pws_restart_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 16:
      ret.set(value_c::types::cell_id_list_for_restart);
      break;
    case 27:
      ret.set(value_c::types::global_ran_node_id);
      break;
    case 104:
      ret.set(value_c::types::tai_list_for_restart);
      break;
    case 23:
      ret.set(value_c::types::emergency_area_id_list_for_restart);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pws_restart_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 16:
      return presence_e::mandatory;
    case 27:
      return presence_e::mandatory;
    case 104:
      return presence_e::mandatory;
    case 23:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pws_restart_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cell_id_list_for_restart:
      c.destroy<cell_id_list_for_restart_c>();
      break;
    case types::global_ran_node_id:
      c.destroy<global_ran_node_id_c>();
      break;
    case types::tai_list_for_restart:
      c.destroy<tai_list_for_restart_l>();
      break;
    case types::emergency_area_id_list_for_restart:
      c.destroy<emergency_area_id_list_for_restart_l>();
      break;
    default:
      break;
  }
}
void pws_restart_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cell_id_list_for_restart:
      c.init<cell_id_list_for_restart_c>();
      break;
    case types::global_ran_node_id:
      c.init<global_ran_node_id_c>();
      break;
    case types::tai_list_for_restart:
      c.init<tai_list_for_restart_l>();
      break;
    case types::emergency_area_id_list_for_restart:
      c.init<emergency_area_id_list_for_restart_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
  }
}
pws_restart_ind_ies_o::value_c::value_c(const pws_restart_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_id_list_for_restart:
      c.init(other.c.get<cell_id_list_for_restart_c>());
      break;
    case types::global_ran_node_id:
      c.init(other.c.get<global_ran_node_id_c>());
      break;
    case types::tai_list_for_restart:
      c.init(other.c.get<tai_list_for_restart_l>());
      break;
    case types::emergency_area_id_list_for_restart:
      c.init(other.c.get<emergency_area_id_list_for_restart_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
  }
}
pws_restart_ind_ies_o::value_c& pws_restart_ind_ies_o::value_c::operator=(const pws_restart_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_id_list_for_restart:
      c.set(other.c.get<cell_id_list_for_restart_c>());
      break;
    case types::global_ran_node_id:
      c.set(other.c.get<global_ran_node_id_c>());
      break;
    case types::tai_list_for_restart:
      c.set(other.c.get<tai_list_for_restart_l>());
      break;
    case types::emergency_area_id_list_for_restart:
      c.set(other.c.get<emergency_area_id_list_for_restart_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
  }

  return *this;
}
cell_id_list_for_restart_c& pws_restart_ind_ies_o::value_c::cell_id_list_for_restart()
{
  assert_choice_type(types::cell_id_list_for_restart, type_, "Value");
  return c.get<cell_id_list_for_restart_c>();
}
global_ran_node_id_c& pws_restart_ind_ies_o::value_c::global_ran_node_id()
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
tai_list_for_restart_l& pws_restart_ind_ies_o::value_c::tai_list_for_restart()
{
  assert_choice_type(types::tai_list_for_restart, type_, "Value");
  return c.get<tai_list_for_restart_l>();
}
emergency_area_id_list_for_restart_l& pws_restart_ind_ies_o::value_c::emergency_area_id_list_for_restart()
{
  assert_choice_type(types::emergency_area_id_list_for_restart, type_, "Value");
  return c.get<emergency_area_id_list_for_restart_l>();
}
const cell_id_list_for_restart_c& pws_restart_ind_ies_o::value_c::cell_id_list_for_restart() const
{
  assert_choice_type(types::cell_id_list_for_restart, type_, "Value");
  return c.get<cell_id_list_for_restart_c>();
}
const global_ran_node_id_c& pws_restart_ind_ies_o::value_c::global_ran_node_id() const
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
const tai_list_for_restart_l& pws_restart_ind_ies_o::value_c::tai_list_for_restart() const
{
  assert_choice_type(types::tai_list_for_restart, type_, "Value");
  return c.get<tai_list_for_restart_l>();
}
const emergency_area_id_list_for_restart_l& pws_restart_ind_ies_o::value_c::emergency_area_id_list_for_restart() const
{
  assert_choice_type(types::emergency_area_id_list_for_restart, type_, "Value");
  return c.get<emergency_area_id_list_for_restart_l>();
}
void pws_restart_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_id_list_for_restart:
      j.write_fieldname("CellIDListForRestart");
      c.get<cell_id_list_for_restart_c>().to_json(j);
      break;
    case types::global_ran_node_id:
      j.write_fieldname("GlobalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    case types::tai_list_for_restart:
      j.start_array("TAIListForRestart");
      for (const auto& e1 : c.get<tai_list_for_restart_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::emergency_area_id_list_for_restart:
      j.start_array("EmergencyAreaIDListForRestart");
      for (const auto& e1 : c.get<emergency_area_id_list_for_restart_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pws_restart_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cell_id_list_for_restart:
      HANDLE_CODE(c.get<cell_id_list_for_restart_c>().pack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    case types::tai_list_for_restart:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_list_for_restart_l>(), 1, 2048, true));
      break;
    case types::emergency_area_id_list_for_restart:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<emergency_area_id_list_for_restart_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_restart_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cell_id_list_for_restart:
      HANDLE_CODE(c.get<cell_id_list_for_restart_c>().unpack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    case types::tai_list_for_restart:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_list_for_restart_l>(), bref, 1, 2048, true));
      break;
    case types::emergency_area_id_list_for_restart:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<emergency_area_id_list_for_restart_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PagingIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t paging_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {115, 50, 103, 52, 118, 51, 11, 203, 202, 205, 208, 223, 222, 332, 342, 344};
  return map_enum_number(names, 16, idx, "id");
}
bool paging_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {115, 50, 103, 52, 118, 51, 11, 203, 202, 205, 208, 223, 222, 332, 342, 344};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e paging_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 115:
      return crit_e::ignore;
    case 50:
      return crit_e::ignore;
    case 103:
      return crit_e::ignore;
    case 52:
      return crit_e::ignore;
    case 118:
      return crit_e::ignore;
    case 51:
      return crit_e::ignore;
    case 11:
      return crit_e::ignore;
    case 203:
      return crit_e::ignore;
    case 202:
      return crit_e::ignore;
    case 205:
      return crit_e::ignore;
    case 208:
      return crit_e::ignore;
    case 223:
      return crit_e::ignore;
    case 222:
      return crit_e::ignore;
    case 332:
      return crit_e::ignore;
    case 342:
      return crit_e::ignore;
    case 344:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
paging_ies_o::value_c paging_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 115:
      ret.set(value_c::types::ue_paging_id);
      break;
    case 50:
      ret.set(value_c::types::paging_drx);
      break;
    case 103:
      ret.set(value_c::types::tai_list_for_paging);
      break;
    case 52:
      ret.set(value_c::types::paging_prio);
      break;
    case 118:
      ret.set(value_c::types::ue_radio_cap_for_paging);
      break;
    case 51:
      ret.set(value_c::types::paging_origin);
      break;
    case 11:
      ret.set(value_c::types::assist_data_for_paging);
      break;
    case 203:
      ret.set(value_c::types::nb_iot_paging_e_drx_info);
      break;
    case 202:
      ret.set(value_c::types::nb_iot_paging_drx);
      break;
    case 205:
      ret.set(value_c::types::enhanced_coverage_restrict);
      break;
    case 208:
      ret.set(value_c::types::wus_assist_info);
      break;
    case 223:
      ret.set(value_c::types::eutra_paginge_drx_info);
      break;
    case 222:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 332:
      ret.set(value_c::types::nr_paginge_drx_info);
      break;
    case 342:
      ret.set(value_c::types::paging_cause);
      break;
    case 344:
      ret.set(value_c::types::pe_ip_sassist_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e paging_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 115:
      return presence_e::mandatory;
    case 50:
      return presence_e::optional;
    case 103:
      return presence_e::mandatory;
    case 52:
      return presence_e::optional;
    case 118:
      return presence_e::optional;
    case 51:
      return presence_e::optional;
    case 11:
      return presence_e::optional;
    case 203:
      return presence_e::optional;
    case 202:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 208:
      return presence_e::optional;
    case 223:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    case 332:
      return presence_e::optional;
    case 342:
      return presence_e::optional;
    case 344:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void paging_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_paging_id:
      c.destroy<ue_paging_id_c>();
      break;
    case types::tai_list_for_paging:
      c.destroy<tai_list_for_paging_l>();
      break;
    case types::ue_radio_cap_for_paging:
      c.destroy<ue_radio_cap_for_paging_s>();
      break;
    case types::assist_data_for_paging:
      c.destroy<assist_data_for_paging_s>();
      break;
    case types::nb_iot_paging_e_drx_info:
      c.destroy<nb_iot_paging_e_drx_info_s>();
      break;
    case types::wus_assist_info:
      c.destroy<wus_assist_info_s>();
      break;
    case types::eutra_paginge_drx_info:
      c.destroy<eutra_paginge_drx_info_s>();
      break;
    case types::nr_paginge_drx_info:
      c.destroy<nr_paginge_drx_info_s>();
      break;
    case types::pe_ip_sassist_info:
      c.destroy<pe_ip_sassist_info_s>();
      break;
    default:
      break;
  }
}
void paging_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ue_paging_id:
      c.init<ue_paging_id_c>();
      break;
    case types::paging_drx:
      break;
    case types::tai_list_for_paging:
      c.init<tai_list_for_paging_l>();
      break;
    case types::paging_prio:
      break;
    case types::ue_radio_cap_for_paging:
      c.init<ue_radio_cap_for_paging_s>();
      break;
    case types::paging_origin:
      break;
    case types::assist_data_for_paging:
      c.init<assist_data_for_paging_s>();
      break;
    case types::nb_iot_paging_e_drx_info:
      c.init<nb_iot_paging_e_drx_info_s>();
      break;
    case types::nb_iot_paging_drx:
      break;
    case types::enhanced_coverage_restrict:
      break;
    case types::wus_assist_info:
      c.init<wus_assist_info_s>();
      break;
    case types::eutra_paginge_drx_info:
      c.init<eutra_paginge_drx_info_s>();
      break;
    case types::ce_mode_brestricted:
      break;
    case types::nr_paginge_drx_info:
      c.init<nr_paginge_drx_info_s>();
      break;
    case types::paging_cause:
      break;
    case types::pe_ip_sassist_info:
      c.init<pe_ip_sassist_info_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
  }
}
paging_ies_o::value_c::value_c(const paging_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ue_paging_id:
      c.init(other.c.get<ue_paging_id_c>());
      break;
    case types::paging_drx:
      c.init(other.c.get<paging_drx_e>());
      break;
    case types::tai_list_for_paging:
      c.init(other.c.get<tai_list_for_paging_l>());
      break;
    case types::paging_prio:
      c.init(other.c.get<paging_prio_e>());
      break;
    case types::ue_radio_cap_for_paging:
      c.init(other.c.get<ue_radio_cap_for_paging_s>());
      break;
    case types::paging_origin:
      c.init(other.c.get<paging_origin_e>());
      break;
    case types::assist_data_for_paging:
      c.init(other.c.get<assist_data_for_paging_s>());
      break;
    case types::nb_iot_paging_e_drx_info:
      c.init(other.c.get<nb_iot_paging_e_drx_info_s>());
      break;
    case types::nb_iot_paging_drx:
      c.init(other.c.get<nb_iot_paging_drx_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.init(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::wus_assist_info:
      c.init(other.c.get<wus_assist_info_s>());
      break;
    case types::eutra_paginge_drx_info:
      c.init(other.c.get<eutra_paginge_drx_info_s>());
      break;
    case types::ce_mode_brestricted:
      c.init(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::nr_paginge_drx_info:
      c.init(other.c.get<nr_paginge_drx_info_s>());
      break;
    case types::paging_cause:
      c.init(other.c.get<paging_cause_e>());
      break;
    case types::pe_ip_sassist_info:
      c.init(other.c.get<pe_ip_sassist_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
  }
}
paging_ies_o::value_c& paging_ies_o::value_c::operator=(const paging_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ue_paging_id:
      c.set(other.c.get<ue_paging_id_c>());
      break;
    case types::paging_drx:
      c.set(other.c.get<paging_drx_e>());
      break;
    case types::tai_list_for_paging:
      c.set(other.c.get<tai_list_for_paging_l>());
      break;
    case types::paging_prio:
      c.set(other.c.get<paging_prio_e>());
      break;
    case types::ue_radio_cap_for_paging:
      c.set(other.c.get<ue_radio_cap_for_paging_s>());
      break;
    case types::paging_origin:
      c.set(other.c.get<paging_origin_e>());
      break;
    case types::assist_data_for_paging:
      c.set(other.c.get<assist_data_for_paging_s>());
      break;
    case types::nb_iot_paging_e_drx_info:
      c.set(other.c.get<nb_iot_paging_e_drx_info_s>());
      break;
    case types::nb_iot_paging_drx:
      c.set(other.c.get<nb_iot_paging_drx_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.set(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::wus_assist_info:
      c.set(other.c.get<wus_assist_info_s>());
      break;
    case types::eutra_paginge_drx_info:
      c.set(other.c.get<eutra_paginge_drx_info_s>());
      break;
    case types::ce_mode_brestricted:
      c.set(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::nr_paginge_drx_info:
      c.set(other.c.get<nr_paginge_drx_info_s>());
      break;
    case types::paging_cause:
      c.set(other.c.get<paging_cause_e>());
      break;
    case types::pe_ip_sassist_info:
      c.set(other.c.get<pe_ip_sassist_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
  }

  return *this;
}
ue_paging_id_c& paging_ies_o::value_c::ue_paging_id()
{
  assert_choice_type(types::ue_paging_id, type_, "Value");
  return c.get<ue_paging_id_c>();
}
paging_drx_e& paging_ies_o::value_c::paging_drx()
{
  assert_choice_type(types::paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
tai_list_for_paging_l& paging_ies_o::value_c::tai_list_for_paging()
{
  assert_choice_type(types::tai_list_for_paging, type_, "Value");
  return c.get<tai_list_for_paging_l>();
}
paging_prio_e& paging_ies_o::value_c::paging_prio()
{
  assert_choice_type(types::paging_prio, type_, "Value");
  return c.get<paging_prio_e>();
}
ue_radio_cap_for_paging_s& paging_ies_o::value_c::ue_radio_cap_for_paging()
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<ue_radio_cap_for_paging_s>();
}
paging_origin_e& paging_ies_o::value_c::paging_origin()
{
  assert_choice_type(types::paging_origin, type_, "Value");
  return c.get<paging_origin_e>();
}
assist_data_for_paging_s& paging_ies_o::value_c::assist_data_for_paging()
{
  assert_choice_type(types::assist_data_for_paging, type_, "Value");
  return c.get<assist_data_for_paging_s>();
}
nb_iot_paging_e_drx_info_s& paging_ies_o::value_c::nb_iot_paging_e_drx_info()
{
  assert_choice_type(types::nb_iot_paging_e_drx_info, type_, "Value");
  return c.get<nb_iot_paging_e_drx_info_s>();
}
nb_iot_paging_drx_e& paging_ies_o::value_c::nb_iot_paging_drx()
{
  assert_choice_type(types::nb_iot_paging_drx, type_, "Value");
  return c.get<nb_iot_paging_drx_e>();
}
enhanced_coverage_restrict_e& paging_ies_o::value_c::enhanced_coverage_restrict()
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
wus_assist_info_s& paging_ies_o::value_c::wus_assist_info()
{
  assert_choice_type(types::wus_assist_info, type_, "Value");
  return c.get<wus_assist_info_s>();
}
eutra_paginge_drx_info_s& paging_ies_o::value_c::eutra_paginge_drx_info()
{
  assert_choice_type(types::eutra_paginge_drx_info, type_, "Value");
  return c.get<eutra_paginge_drx_info_s>();
}
ce_mode_brestricted_e& paging_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
nr_paginge_drx_info_s& paging_ies_o::value_c::nr_paginge_drx_info()
{
  assert_choice_type(types::nr_paginge_drx_info, type_, "Value");
  return c.get<nr_paginge_drx_info_s>();
}
paging_cause_e& paging_ies_o::value_c::paging_cause()
{
  assert_choice_type(types::paging_cause, type_, "Value");
  return c.get<paging_cause_e>();
}
pe_ip_sassist_info_s& paging_ies_o::value_c::pe_ip_sassist_info()
{
  assert_choice_type(types::pe_ip_sassist_info, type_, "Value");
  return c.get<pe_ip_sassist_info_s>();
}
const ue_paging_id_c& paging_ies_o::value_c::ue_paging_id() const
{
  assert_choice_type(types::ue_paging_id, type_, "Value");
  return c.get<ue_paging_id_c>();
}
const paging_drx_e& paging_ies_o::value_c::paging_drx() const
{
  assert_choice_type(types::paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
const tai_list_for_paging_l& paging_ies_o::value_c::tai_list_for_paging() const
{
  assert_choice_type(types::tai_list_for_paging, type_, "Value");
  return c.get<tai_list_for_paging_l>();
}
const paging_prio_e& paging_ies_o::value_c::paging_prio() const
{
  assert_choice_type(types::paging_prio, type_, "Value");
  return c.get<paging_prio_e>();
}
const ue_radio_cap_for_paging_s& paging_ies_o::value_c::ue_radio_cap_for_paging() const
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<ue_radio_cap_for_paging_s>();
}
const paging_origin_e& paging_ies_o::value_c::paging_origin() const
{
  assert_choice_type(types::paging_origin, type_, "Value");
  return c.get<paging_origin_e>();
}
const assist_data_for_paging_s& paging_ies_o::value_c::assist_data_for_paging() const
{
  assert_choice_type(types::assist_data_for_paging, type_, "Value");
  return c.get<assist_data_for_paging_s>();
}
const nb_iot_paging_e_drx_info_s& paging_ies_o::value_c::nb_iot_paging_e_drx_info() const
{
  assert_choice_type(types::nb_iot_paging_e_drx_info, type_, "Value");
  return c.get<nb_iot_paging_e_drx_info_s>();
}
const nb_iot_paging_drx_e& paging_ies_o::value_c::nb_iot_paging_drx() const
{
  assert_choice_type(types::nb_iot_paging_drx, type_, "Value");
  return c.get<nb_iot_paging_drx_e>();
}
const enhanced_coverage_restrict_e& paging_ies_o::value_c::enhanced_coverage_restrict() const
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
const wus_assist_info_s& paging_ies_o::value_c::wus_assist_info() const
{
  assert_choice_type(types::wus_assist_info, type_, "Value");
  return c.get<wus_assist_info_s>();
}
const eutra_paginge_drx_info_s& paging_ies_o::value_c::eutra_paginge_drx_info() const
{
  assert_choice_type(types::eutra_paginge_drx_info, type_, "Value");
  return c.get<eutra_paginge_drx_info_s>();
}
const ce_mode_brestricted_e& paging_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const nr_paginge_drx_info_s& paging_ies_o::value_c::nr_paginge_drx_info() const
{
  assert_choice_type(types::nr_paginge_drx_info, type_, "Value");
  return c.get<nr_paginge_drx_info_s>();
}
const paging_cause_e& paging_ies_o::value_c::paging_cause() const
{
  assert_choice_type(types::paging_cause, type_, "Value");
  return c.get<paging_cause_e>();
}
const pe_ip_sassist_info_s& paging_ies_o::value_c::pe_ip_sassist_info() const
{
  assert_choice_type(types::pe_ip_sassist_info, type_, "Value");
  return c.get<pe_ip_sassist_info_s>();
}
void paging_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ue_paging_id:
      j.write_fieldname("UEPagingIdentity");
      c.get<ue_paging_id_c>().to_json(j);
      break;
    case types::paging_drx:
      j.write_str("PagingDRX", c.get<paging_drx_e>().to_string());
      break;
    case types::tai_list_for_paging:
      j.start_array("TAIListForPaging");
      for (const auto& e1 : c.get<tai_list_for_paging_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::paging_prio:
      j.write_str("PagingPriority", c.get<paging_prio_e>().to_string());
      break;
    case types::ue_radio_cap_for_paging:
      j.write_fieldname("UERadioCapabilityForPaging");
      c.get<ue_radio_cap_for_paging_s>().to_json(j);
      break;
    case types::paging_origin:
      j.write_str("PagingOrigin", "non-3gpp");
      break;
    case types::assist_data_for_paging:
      j.write_fieldname("AssistanceDataForPaging");
      c.get<assist_data_for_paging_s>().to_json(j);
      break;
    case types::nb_iot_paging_e_drx_info:
      j.write_fieldname("NB-IoT-Paging-eDRXInfo");
      c.get<nb_iot_paging_e_drx_info_s>().to_json(j);
      break;
    case types::nb_iot_paging_drx:
      j.write_str("NB-IoT-PagingDRX", c.get<nb_iot_paging_drx_e>().to_string());
      break;
    case types::enhanced_coverage_restrict:
      j.write_str("Enhanced-CoverageRestriction", "restricted");
      break;
    case types::wus_assist_info:
      j.write_fieldname("WUS-Assistance-Information");
      c.get<wus_assist_info_s>().to_json(j);
      break;
    case types::eutra_paginge_drx_info:
      j.write_fieldname("EUTRA-PagingeDRXInformation");
      c.get<eutra_paginge_drx_info_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CEmodeBrestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::nr_paginge_drx_info:
      j.write_fieldname("NR-PagingeDRXInformation");
      c.get<nr_paginge_drx_info_s>().to_json(j);
      break;
    case types::paging_cause:
      j.write_str("PagingCause", "voice");
      break;
    case types::pe_ip_sassist_info:
      j.write_fieldname("PEIPSassistanceInformation");
      c.get<pe_ip_sassist_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE paging_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_paging_id:
      HANDLE_CODE(c.get<ue_paging_id_c>().pack(bref));
      break;
    case types::paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().pack(bref));
      break;
    case types::tai_list_for_paging:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_list_for_paging_l>(), 1, 16, true));
      break;
    case types::paging_prio:
      HANDLE_CODE(c.get<paging_prio_e>().pack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().pack(bref));
      break;
    case types::paging_origin:
      HANDLE_CODE(c.get<paging_origin_e>().pack(bref));
      break;
    case types::assist_data_for_paging:
      HANDLE_CODE(c.get<assist_data_for_paging_s>().pack(bref));
      break;
    case types::nb_iot_paging_e_drx_info:
      HANDLE_CODE(c.get<nb_iot_paging_e_drx_info_s>().pack(bref));
      break;
    case types::nb_iot_paging_drx:
      HANDLE_CODE(c.get<nb_iot_paging_drx_e>().pack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().pack(bref));
      break;
    case types::wus_assist_info:
      HANDLE_CODE(c.get<wus_assist_info_s>().pack(bref));
      break;
    case types::eutra_paginge_drx_info:
      HANDLE_CODE(c.get<eutra_paginge_drx_info_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::nr_paginge_drx_info:
      HANDLE_CODE(c.get<nr_paginge_drx_info_s>().pack(bref));
      break;
    case types::paging_cause:
      HANDLE_CODE(c.get<paging_cause_e>().pack(bref));
      break;
    case types::pe_ip_sassist_info:
      HANDLE_CODE(c.get<pe_ip_sassist_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE paging_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_paging_id:
      HANDLE_CODE(c.get<ue_paging_id_c>().unpack(bref));
      break;
    case types::paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().unpack(bref));
      break;
    case types::tai_list_for_paging:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_list_for_paging_l>(), bref, 1, 16, true));
      break;
    case types::paging_prio:
      HANDLE_CODE(c.get<paging_prio_e>().unpack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().unpack(bref));
      break;
    case types::paging_origin:
      HANDLE_CODE(c.get<paging_origin_e>().unpack(bref));
      break;
    case types::assist_data_for_paging:
      HANDLE_CODE(c.get<assist_data_for_paging_s>().unpack(bref));
      break;
    case types::nb_iot_paging_e_drx_info:
      HANDLE_CODE(c.get<nb_iot_paging_e_drx_info_s>().unpack(bref));
      break;
    case types::nb_iot_paging_drx:
      HANDLE_CODE(c.get<nb_iot_paging_drx_e>().unpack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().unpack(bref));
      break;
    case types::wus_assist_info:
      HANDLE_CODE(c.get<wus_assist_info_s>().unpack(bref));
      break;
    case types::eutra_paginge_drx_info:
      HANDLE_CODE(c.get<eutra_paginge_drx_info_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::nr_paginge_drx_info:
      HANDLE_CODE(c.get<nr_paginge_drx_info_s>().unpack(bref));
      break;
    case types::paging_cause:
      HANDLE_CODE(c.get<paging_cause_e>().unpack(bref));
      break;
    case types::pe_ip_sassist_info:
      HANDLE_CODE(c.get<pe_ip_sassist_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PathSwitchRequestAcknowledgeIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t path_switch_request_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10,  85,  119, 93,  41,  77,  68,  0,   18,  91,  19,  146, 165, 177, 205, 206,
                                   209, 216, 215, 218, 217, 219, 222, 234, 264, 254, 326, 345, 346, 347, 359};
  return map_enum_number(names, 31, idx, "id");
}
bool path_switch_request_ack_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10,  85,  119, 93,  41,  77,  68,  0,   18,  91,  19,  146, 165, 177, 205, 206,
                                   209, 216, 215, 218, 217, 219, 222, 234, 264, 254, 326, 345, 346, 347, 359};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e path_switch_request_ack_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 119:
      return crit_e::reject;
    case 93:
      return crit_e::reject;
    case 41:
      return crit_e::reject;
    case 77:
      return crit_e::ignore;
    case 68:
      return crit_e::ignore;
    case 0:
      return crit_e::reject;
    case 18:
      return crit_e::ignore;
    case 91:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    case 146:
      return crit_e::ignore;
    case 165:
      return crit_e::ignore;
    case 177:
      return crit_e::ignore;
    case 205:
      return crit_e::ignore;
    case 206:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 216:
      return crit_e::ignore;
    case 215:
      return crit_e::ignore;
    case 218:
      return crit_e::ignore;
    case 217:
      return crit_e::ignore;
    case 219:
      return crit_e::ignore;
    case 222:
      return crit_e::ignore;
    case 234:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    case 254:
      return crit_e::ignore;
    case 326:
      return crit_e::ignore;
    case 345:
      return crit_e::ignore;
    case 346:
      return crit_e::ignore;
    case 347:
      return crit_e::ignore;
    case 359:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
path_switch_request_ack_ies_o::value_c path_switch_request_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 119:
      ret.set(value_c::types::ue_security_cap);
      break;
    case 93:
      ret.set(value_c::types::security_context);
      break;
    case 41:
      ret.set(value_c::types::new_security_context_ind);
      break;
    case 77:
      ret.set(value_c::types::pdu_session_res_switched_list);
      break;
    case 68:
      ret.set(value_c::types::pdu_session_res_released_list_ps_ack);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 18:
      ret.set(value_c::types::core_network_assist_info_for_inactive);
      break;
    case 91:
      ret.set(value_c::types::rrc_inactive_transition_report_request);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 146:
      ret.set(value_c::types::redirection_voice_fallback);
      break;
    case 165:
      ret.set(value_c::types::cn_assisted_ran_tuning);
      break;
    case 177:
      ret.set(value_c::types::srvcc_operation_possible);
      break;
    case 205:
      ret.set(value_c::types::enhanced_coverage_restrict);
      break;
    case 206:
      ret.set(value_c::types::extended_connected_time);
      break;
    case 209:
      ret.set(value_c::types::ue_diff_info);
      break;
    case 216:
      ret.set(value_c::types::nr_v2x_services_authorized);
      break;
    case 215:
      ret.set(value_c::types::ltev2x_services_authorized);
      break;
    case 218:
      ret.set(value_c::types::nr_ue_sidelink_aggr_max_bitrate);
      break;
    case 217:
      ret.set(value_c::types::lte_ue_sidelink_aggr_max_bitrate);
      break;
    case 219:
      ret.set(value_c::types::pc5_qos_params);
      break;
    case 222:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 234:
      ret.set(value_c::types::ue_up_c_iot_support);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 254:
      ret.set(value_c::types::management_based_mdt_plmn_list);
      break;
    case 326:
      ret.set(value_c::types::time_sync_assist_info);
      break;
    case 345:
      ret.set(value_c::types::five_g_pro_se_authorized);
      break;
    case 346:
      ret.set(value_c::types::five_g_pro_se_ue_pc5_aggr_max_bit_rate);
      break;
    case 347:
      ret.set(value_c::types::five_g_pro_se_pc5_qos_params);
      break;
    case 359:
      ret.set(value_c::types::management_based_mdt_plmn_mod_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e path_switch_request_ack_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 119:
      return presence_e::optional;
    case 93:
      return presence_e::mandatory;
    case 41:
      return presence_e::optional;
    case 77:
      return presence_e::mandatory;
    case 68:
      return presence_e::optional;
    case 0:
      return presence_e::mandatory;
    case 18:
      return presence_e::optional;
    case 91:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    case 146:
      return presence_e::optional;
    case 165:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 206:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 216:
      return presence_e::optional;
    case 215:
      return presence_e::optional;
    case 218:
      return presence_e::optional;
    case 217:
      return presence_e::optional;
    case 219:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    case 234:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 254:
      return presence_e::optional;
    case 326:
      return presence_e::optional;
    case 345:
      return presence_e::optional;
    case 346:
      return presence_e::optional;
    case 347:
      return presence_e::optional;
    case 359:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void path_switch_request_ack_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_security_cap:
      c.destroy<ue_security_cap_s>();
      break;
    case types::security_context:
      c.destroy<security_context_s>();
      break;
    case types::pdu_session_res_switched_list:
      c.destroy<pdu_session_res_switched_list_l>();
      break;
    case types::pdu_session_res_released_list_ps_ack:
      c.destroy<pdu_session_res_released_list_ps_ack_l>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    case types::core_network_assist_info_for_inactive:
      c.destroy<core_network_assist_info_for_inactive_s>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::cn_assisted_ran_tuning:
      c.destroy<cn_assisted_ran_tuning_s>();
      break;
    case types::ue_diff_info:
      c.destroy<ue_diff_info_s>();
      break;
    case types::nr_v2x_services_authorized:
      c.destroy<nr_v2x_services_authorized_s>();
      break;
    case types::ltev2x_services_authorized:
      c.destroy<ltev2x_services_authorized_s>();
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.destroy<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.destroy<lte_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::pc5_qos_params:
      c.destroy<pc5_qos_params_s>();
      break;
    case types::ue_radio_cap_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::management_based_mdt_plmn_list:
      c.destroy<mdt_plmn_list_l>();
      break;
    case types::time_sync_assist_info:
      c.destroy<time_sync_assist_info_s>();
      break;
    case types::five_g_pro_se_authorized:
      c.destroy<five_g_pro_se_authorized_s>();
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.destroy<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.destroy<five_g_pro_se_pc5_qos_params_s>();
      break;
    case types::management_based_mdt_plmn_mod_list:
      c.destroy<mdt_plmn_mod_list_l>();
      break;
    default:
      break;
  }
}
void path_switch_request_ack_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ue_security_cap:
      c.init<ue_security_cap_s>();
      break;
    case types::security_context:
      c.init<security_context_s>();
      break;
    case types::new_security_context_ind:
      break;
    case types::pdu_session_res_switched_list:
      c.init<pdu_session_res_switched_list_l>();
      break;
    case types::pdu_session_res_released_list_ps_ack:
      c.init<pdu_session_res_released_list_ps_ack_l>();
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::core_network_assist_info_for_inactive:
      c.init<core_network_assist_info_for_inactive_s>();
      break;
    case types::rrc_inactive_transition_report_request:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::redirection_voice_fallback:
      break;
    case types::cn_assisted_ran_tuning:
      c.init<cn_assisted_ran_tuning_s>();
      break;
    case types::srvcc_operation_possible:
      break;
    case types::enhanced_coverage_restrict:
      break;
    case types::extended_connected_time:
      break;
    case types::ue_diff_info:
      c.init<ue_diff_info_s>();
      break;
    case types::nr_v2x_services_authorized:
      c.init<nr_v2x_services_authorized_s>();
      break;
    case types::ltev2x_services_authorized:
      c.init<ltev2x_services_authorized_s>();
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.init<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.init<lte_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::pc5_qos_params:
      c.init<pc5_qos_params_s>();
      break;
    case types::ce_mode_brestricted:
      break;
    case types::ue_up_c_iot_support:
      break;
    case types::ue_radio_cap_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::management_based_mdt_plmn_list:
      c.init<mdt_plmn_list_l>();
      break;
    case types::time_sync_assist_info:
      c.init<time_sync_assist_info_s>();
      break;
    case types::five_g_pro_se_authorized:
      c.init<five_g_pro_se_authorized_s>();
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.init<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.init<five_g_pro_se_pc5_qos_params_s>();
      break;
    case types::management_based_mdt_plmn_mod_list:
      c.init<mdt_plmn_mod_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
  }
}
path_switch_request_ack_ies_o::value_c::value_c(const path_switch_request_ack_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ue_security_cap:
      c.init(other.c.get<ue_security_cap_s>());
      break;
    case types::security_context:
      c.init(other.c.get<security_context_s>());
      break;
    case types::new_security_context_ind:
      c.init(other.c.get<new_security_context_ind_e>());
      break;
    case types::pdu_session_res_switched_list:
      c.init(other.c.get<pdu_session_res_switched_list_l>());
      break;
    case types::pdu_session_res_released_list_ps_ack:
      c.init(other.c.get<pdu_session_res_released_list_ps_ack_l>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::core_network_assist_info_for_inactive:
      c.init(other.c.get<core_network_assist_info_for_inactive_s>());
      break;
    case types::rrc_inactive_transition_report_request:
      c.init(other.c.get<rrc_inactive_transition_report_request_e>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::redirection_voice_fallback:
      c.init(other.c.get<redirection_voice_fallback_e>());
      break;
    case types::cn_assisted_ran_tuning:
      c.init(other.c.get<cn_assisted_ran_tuning_s>());
      break;
    case types::srvcc_operation_possible:
      c.init(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.init(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::extended_connected_time:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      c.init(other.c.get<ue_diff_info_s>());
      break;
    case types::nr_v2x_services_authorized:
      c.init(other.c.get<nr_v2x_services_authorized_s>());
      break;
    case types::ltev2x_services_authorized:
      c.init(other.c.get<ltev2x_services_authorized_s>());
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.init(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.init(other.c.get<lte_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::pc5_qos_params:
      c.init(other.c.get<pc5_qos_params_s>());
      break;
    case types::ce_mode_brestricted:
      c.init(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_up_c_iot_support:
      c.init(other.c.get<ue_up_c_iot_support_e>());
      break;
    case types::ue_radio_cap_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::management_based_mdt_plmn_list:
      c.init(other.c.get<mdt_plmn_list_l>());
      break;
    case types::time_sync_assist_info:
      c.init(other.c.get<time_sync_assist_info_s>());
      break;
    case types::five_g_pro_se_authorized:
      c.init(other.c.get<five_g_pro_se_authorized_s>());
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.init(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.init(other.c.get<five_g_pro_se_pc5_qos_params_s>());
      break;
    case types::management_based_mdt_plmn_mod_list:
      c.init(other.c.get<mdt_plmn_mod_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
  }
}
path_switch_request_ack_ies_o::value_c&
path_switch_request_ack_ies_o::value_c::operator=(const path_switch_request_ack_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ue_security_cap:
      c.set(other.c.get<ue_security_cap_s>());
      break;
    case types::security_context:
      c.set(other.c.get<security_context_s>());
      break;
    case types::new_security_context_ind:
      c.set(other.c.get<new_security_context_ind_e>());
      break;
    case types::pdu_session_res_switched_list:
      c.set(other.c.get<pdu_session_res_switched_list_l>());
      break;
    case types::pdu_session_res_released_list_ps_ack:
      c.set(other.c.get<pdu_session_res_released_list_ps_ack_l>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::core_network_assist_info_for_inactive:
      c.set(other.c.get<core_network_assist_info_for_inactive_s>());
      break;
    case types::rrc_inactive_transition_report_request:
      c.set(other.c.get<rrc_inactive_transition_report_request_e>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::redirection_voice_fallback:
      c.set(other.c.get<redirection_voice_fallback_e>());
      break;
    case types::cn_assisted_ran_tuning:
      c.set(other.c.get<cn_assisted_ran_tuning_s>());
      break;
    case types::srvcc_operation_possible:
      c.set(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.set(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::extended_connected_time:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      c.set(other.c.get<ue_diff_info_s>());
      break;
    case types::nr_v2x_services_authorized:
      c.set(other.c.get<nr_v2x_services_authorized_s>());
      break;
    case types::ltev2x_services_authorized:
      c.set(other.c.get<ltev2x_services_authorized_s>());
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.set(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.set(other.c.get<lte_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::pc5_qos_params:
      c.set(other.c.get<pc5_qos_params_s>());
      break;
    case types::ce_mode_brestricted:
      c.set(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_up_c_iot_support:
      c.set(other.c.get<ue_up_c_iot_support_e>());
      break;
    case types::ue_radio_cap_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::management_based_mdt_plmn_list:
      c.set(other.c.get<mdt_plmn_list_l>());
      break;
    case types::time_sync_assist_info:
      c.set(other.c.get<time_sync_assist_info_s>());
      break;
    case types::five_g_pro_se_authorized:
      c.set(other.c.get<five_g_pro_se_authorized_s>());
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.set(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.set(other.c.get<five_g_pro_se_pc5_qos_params_s>());
      break;
    case types::management_based_mdt_plmn_mod_list:
      c.set(other.c.get<mdt_plmn_mod_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
  }

  return *this;
}
uint64_t& path_switch_request_ack_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& path_switch_request_ack_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
ue_security_cap_s& path_switch_request_ack_ies_o::value_c::ue_security_cap()
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
security_context_s& path_switch_request_ack_ies_o::value_c::security_context()
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
new_security_context_ind_e& path_switch_request_ack_ies_o::value_c::new_security_context_ind()
{
  assert_choice_type(types::new_security_context_ind, type_, "Value");
  return c.get<new_security_context_ind_e>();
}
pdu_session_res_switched_list_l& path_switch_request_ack_ies_o::value_c::pdu_session_res_switched_list()
{
  assert_choice_type(types::pdu_session_res_switched_list, type_, "Value");
  return c.get<pdu_session_res_switched_list_l>();
}
pdu_session_res_released_list_ps_ack_l& path_switch_request_ack_ies_o::value_c::pdu_session_res_released_list_ps_ack()
{
  assert_choice_type(types::pdu_session_res_released_list_ps_ack, type_, "Value");
  return c.get<pdu_session_res_released_list_ps_ack_l>();
}
allowed_nssai_l& path_switch_request_ack_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
core_network_assist_info_for_inactive_s& path_switch_request_ack_ies_o::value_c::core_network_assist_info_for_inactive()
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
rrc_inactive_transition_report_request_e&
path_switch_request_ack_ies_o::value_c::rrc_inactive_transition_report_request()
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
crit_diagnostics_s& path_switch_request_ack_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
redirection_voice_fallback_e& path_switch_request_ack_ies_o::value_c::redirection_voice_fallback()
{
  assert_choice_type(types::redirection_voice_fallback, type_, "Value");
  return c.get<redirection_voice_fallback_e>();
}
cn_assisted_ran_tuning_s& path_switch_request_ack_ies_o::value_c::cn_assisted_ran_tuning()
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
srvcc_operation_possible_e& path_switch_request_ack_ies_o::value_c::srvcc_operation_possible()
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
enhanced_coverage_restrict_e& path_switch_request_ack_ies_o::value_c::enhanced_coverage_restrict()
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
uint16_t& path_switch_request_ack_ies_o::value_c::extended_connected_time()
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
ue_diff_info_s& path_switch_request_ack_ies_o::value_c::ue_diff_info()
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
nr_v2x_services_authorized_s& path_switch_request_ack_ies_o::value_c::nr_v2x_services_authorized()
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
ltev2x_services_authorized_s& path_switch_request_ack_ies_o::value_c::ltev2x_services_authorized()
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& path_switch_request_ack_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
lte_ue_sidelink_aggr_max_bitrate_s& path_switch_request_ack_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
pc5_qos_params_s& path_switch_request_ack_ies_o::value_c::pc5_qos_params()
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
ce_mode_brestricted_e& path_switch_request_ack_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
ue_up_c_iot_support_e& path_switch_request_ack_ies_o::value_c::ue_up_c_iot_support()
{
  assert_choice_type(types::ue_up_c_iot_support, type_, "Value");
  return c.get<ue_up_c_iot_support_e>();
}
unbounded_octstring<true>& path_switch_request_ack_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
mdt_plmn_list_l& path_switch_request_ack_ies_o::value_c::management_based_mdt_plmn_list()
{
  assert_choice_type(types::management_based_mdt_plmn_list, type_, "Value");
  return c.get<mdt_plmn_list_l>();
}
time_sync_assist_info_s& path_switch_request_ack_ies_o::value_c::time_sync_assist_info()
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
five_g_pro_se_authorized_s& path_switch_request_ack_ies_o::value_c::five_g_pro_se_authorized()
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& path_switch_request_ack_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate()
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
five_g_pro_se_pc5_qos_params_s& path_switch_request_ack_ies_o::value_c::five_g_pro_se_pc5_qos_params()
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
mdt_plmn_mod_list_l& path_switch_request_ack_ies_o::value_c::management_based_mdt_plmn_mod_list()
{
  assert_choice_type(types::management_based_mdt_plmn_mod_list, type_, "Value");
  return c.get<mdt_plmn_mod_list_l>();
}
const uint64_t& path_switch_request_ack_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& path_switch_request_ack_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const ue_security_cap_s& path_switch_request_ack_ies_o::value_c::ue_security_cap() const
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
const security_context_s& path_switch_request_ack_ies_o::value_c::security_context() const
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
const new_security_context_ind_e& path_switch_request_ack_ies_o::value_c::new_security_context_ind() const
{
  assert_choice_type(types::new_security_context_ind, type_, "Value");
  return c.get<new_security_context_ind_e>();
}
const pdu_session_res_switched_list_l& path_switch_request_ack_ies_o::value_c::pdu_session_res_switched_list() const
{
  assert_choice_type(types::pdu_session_res_switched_list, type_, "Value");
  return c.get<pdu_session_res_switched_list_l>();
}
const pdu_session_res_released_list_ps_ack_l&
path_switch_request_ack_ies_o::value_c::pdu_session_res_released_list_ps_ack() const
{
  assert_choice_type(types::pdu_session_res_released_list_ps_ack, type_, "Value");
  return c.get<pdu_session_res_released_list_ps_ack_l>();
}
const allowed_nssai_l& path_switch_request_ack_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const core_network_assist_info_for_inactive_s&
path_switch_request_ack_ies_o::value_c::core_network_assist_info_for_inactive() const
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
const rrc_inactive_transition_report_request_e&
path_switch_request_ack_ies_o::value_c::rrc_inactive_transition_report_request() const
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
const crit_diagnostics_s& path_switch_request_ack_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const redirection_voice_fallback_e& path_switch_request_ack_ies_o::value_c::redirection_voice_fallback() const
{
  assert_choice_type(types::redirection_voice_fallback, type_, "Value");
  return c.get<redirection_voice_fallback_e>();
}
const cn_assisted_ran_tuning_s& path_switch_request_ack_ies_o::value_c::cn_assisted_ran_tuning() const
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
const srvcc_operation_possible_e& path_switch_request_ack_ies_o::value_c::srvcc_operation_possible() const
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
const enhanced_coverage_restrict_e& path_switch_request_ack_ies_o::value_c::enhanced_coverage_restrict() const
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
const uint16_t& path_switch_request_ack_ies_o::value_c::extended_connected_time() const
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
const ue_diff_info_s& path_switch_request_ack_ies_o::value_c::ue_diff_info() const
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
const nr_v2x_services_authorized_s& path_switch_request_ack_ies_o::value_c::nr_v2x_services_authorized() const
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
const ltev2x_services_authorized_s& path_switch_request_ack_ies_o::value_c::ltev2x_services_authorized() const
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s& path_switch_request_ack_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const lte_ue_sidelink_aggr_max_bitrate_s&
path_switch_request_ack_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
const pc5_qos_params_s& path_switch_request_ack_ies_o::value_c::pc5_qos_params() const
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
const ce_mode_brestricted_e& path_switch_request_ack_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const ue_up_c_iot_support_e& path_switch_request_ack_ies_o::value_c::ue_up_c_iot_support() const
{
  assert_choice_type(types::ue_up_c_iot_support, type_, "Value");
  return c.get<ue_up_c_iot_support_e>();
}
const unbounded_octstring<true>& path_switch_request_ack_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mdt_plmn_list_l& path_switch_request_ack_ies_o::value_c::management_based_mdt_plmn_list() const
{
  assert_choice_type(types::management_based_mdt_plmn_list, type_, "Value");
  return c.get<mdt_plmn_list_l>();
}
const time_sync_assist_info_s& path_switch_request_ack_ies_o::value_c::time_sync_assist_info() const
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
const five_g_pro_se_authorized_s& path_switch_request_ack_ies_o::value_c::five_g_pro_se_authorized() const
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s&
path_switch_request_ack_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate() const
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const five_g_pro_se_pc5_qos_params_s& path_switch_request_ack_ies_o::value_c::five_g_pro_se_pc5_qos_params() const
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
const mdt_plmn_mod_list_l& path_switch_request_ack_ies_o::value_c::management_based_mdt_plmn_mod_list() const
{
  assert_choice_type(types::management_based_mdt_plmn_mod_list, type_, "Value");
  return c.get<mdt_plmn_mod_list_l>();
}
void path_switch_request_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ue_security_cap:
      j.write_fieldname("UESecurityCapabilities");
      c.get<ue_security_cap_s>().to_json(j);
      break;
    case types::security_context:
      j.write_fieldname("SecurityContext");
      c.get<security_context_s>().to_json(j);
      break;
    case types::new_security_context_ind:
      j.write_str("NewSecurityContextInd", "true");
      break;
    case types::pdu_session_res_switched_list:
      j.start_array("PDUSessionResourceSwitchedList");
      for (const auto& e1 : c.get<pdu_session_res_switched_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_released_list_ps_ack:
      j.start_array("PDUSessionResourceReleasedListPSAck");
      for (const auto& e1 : c.get<pdu_session_res_released_list_ps_ack_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::core_network_assist_info_for_inactive:
      j.write_fieldname("CoreNetworkAssistanceInformationForInactive");
      c.get<core_network_assist_info_for_inactive_s>().to_json(j);
      break;
    case types::rrc_inactive_transition_report_request:
      j.write_str("RRCInactiveTransitionReportRequest", c.get<rrc_inactive_transition_report_request_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::redirection_voice_fallback:
      j.write_str("RedirectionVoiceFallback", c.get<redirection_voice_fallback_e>().to_string());
      break;
    case types::cn_assisted_ran_tuning:
      j.write_fieldname("CNAssistedRANTuning");
      c.get<cn_assisted_ran_tuning_s>().to_json(j);
      break;
    case types::srvcc_operation_possible:
      j.write_str("SRVCCOperationPossible", c.get<srvcc_operation_possible_e>().to_string());
      break;
    case types::enhanced_coverage_restrict:
      j.write_str("Enhanced-CoverageRestriction", "restricted");
      break;
    case types::extended_connected_time:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      j.write_fieldname("UE-DifferentiationInfo");
      c.get<ue_diff_info_s>().to_json(j);
      break;
    case types::nr_v2x_services_authorized:
      j.write_fieldname("NRV2XServicesAuthorized");
      c.get<nr_v2x_services_authorized_s>().to_json(j);
      break;
    case types::ltev2x_services_authorized:
      j.write_fieldname("LTEV2XServicesAuthorized");
      c.get<ltev2x_services_authorized_s>().to_json(j);
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("LTEUESidelinkAggregateMaximumBitrate");
      c.get<lte_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::pc5_qos_params:
      j.write_fieldname("PC5QoSParameters");
      c.get<pc5_qos_params_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CEmodeBrestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::ue_up_c_iot_support:
      j.write_str("UE-UP-CIoT-Support", "supported");
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::management_based_mdt_plmn_list:
      j.start_array("MDTPLMNList");
      for (const auto& e1 : c.get<mdt_plmn_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    case types::time_sync_assist_info:
      j.write_fieldname("TimeSyncAssistanceInfo");
      c.get<time_sync_assist_info_s>().to_json(j);
      break;
    case types::five_g_pro_se_authorized:
      j.write_fieldname("FiveG-ProSeAuthorized");
      c.get<five_g_pro_se_authorized_s>().to_json(j);
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::five_g_pro_se_pc5_qos_params:
      j.write_fieldname("FiveG-ProSePC5QoSParameters");
      c.get<five_g_pro_se_pc5_qos_params_s>().to_json(j);
      break;
    case types::management_based_mdt_plmn_mod_list:
      j.start_array("MDTPLMNModificationList");
      for (const auto& e1 : c.get<mdt_plmn_mod_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE path_switch_request_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().pack(bref));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().pack(bref));
      break;
    case types::new_security_context_ind:
      HANDLE_CODE(c.get<new_security_context_ind_e>().pack(bref));
      break;
    case types::pdu_session_res_switched_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_switched_list_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_released_list_ps_ack:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_released_list_ps_ack_l>(), 1, 256, true));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().pack(bref));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::redirection_voice_fallback:
      HANDLE_CODE(c.get<redirection_voice_fallback_e>().pack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().pack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().pack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().pack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().pack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().pack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().pack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::ue_up_c_iot_support:
      HANDLE_CODE(c.get<ue_up_c_iot_support_e>().pack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::management_based_mdt_plmn_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mdt_plmn_list_l>(), 1, 16, true));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().pack(bref));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().pack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().pack(bref));
      break;
    case types::management_based_mdt_plmn_mod_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mdt_plmn_mod_list_l>(), 0, 16, true));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().unpack(bref));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().unpack(bref));
      break;
    case types::new_security_context_ind:
      HANDLE_CODE(c.get<new_security_context_ind_e>().unpack(bref));
      break;
    case types::pdu_session_res_switched_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_switched_list_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_released_list_ps_ack:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_released_list_ps_ack_l>(), bref, 1, 256, true));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().unpack(bref));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::redirection_voice_fallback:
      HANDLE_CODE(c.get<redirection_voice_fallback_e>().unpack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().unpack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().unpack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().unpack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().unpack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().unpack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().unpack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::ue_up_c_iot_support:
      HANDLE_CODE(c.get<ue_up_c_iot_support_e>().unpack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::management_based_mdt_plmn_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mdt_plmn_list_l>(), bref, 1, 16, true));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().unpack(bref));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().unpack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().unpack(bref));
      break;
    case types::management_based_mdt_plmn_mod_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mdt_plmn_mod_list_l>(), bref, 0, 16, true));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PathSwitchRequestFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t path_switch_request_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 69, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool path_switch_request_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 69, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e path_switch_request_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 69:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
path_switch_request_fail_ies_o::value_c path_switch_request_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 69:
      ret.set(value_c::types::pdu_session_res_released_list_ps_fail);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e path_switch_request_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 69:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void path_switch_request_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_released_list_ps_fail:
      c.destroy<pdu_session_res_released_list_ps_fail_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void path_switch_request_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_released_list_ps_fail:
      c.init<pdu_session_res_released_list_ps_fail_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
  }
}
path_switch_request_fail_ies_o::value_c::value_c(const path_switch_request_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_released_list_ps_fail:
      c.init(other.c.get<pdu_session_res_released_list_ps_fail_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
  }
}
path_switch_request_fail_ies_o::value_c&
path_switch_request_fail_ies_o::value_c::operator=(const path_switch_request_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_released_list_ps_fail:
      c.set(other.c.get<pdu_session_res_released_list_ps_fail_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& path_switch_request_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& path_switch_request_fail_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_released_list_ps_fail_l&
path_switch_request_fail_ies_o::value_c::pdu_session_res_released_list_ps_fail()
{
  assert_choice_type(types::pdu_session_res_released_list_ps_fail, type_, "Value");
  return c.get<pdu_session_res_released_list_ps_fail_l>();
}
crit_diagnostics_s& path_switch_request_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& path_switch_request_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& path_switch_request_fail_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_released_list_ps_fail_l&
path_switch_request_fail_ies_o::value_c::pdu_session_res_released_list_ps_fail() const
{
  assert_choice_type(types::pdu_session_res_released_list_ps_fail, type_, "Value");
  return c.get<pdu_session_res_released_list_ps_fail_l>();
}
const crit_diagnostics_s& path_switch_request_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void path_switch_request_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_released_list_ps_fail:
      j.start_array("PDUSessionResourceReleasedListPSFail");
      for (const auto& e1 : c.get<pdu_session_res_released_list_ps_fail_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE path_switch_request_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_released_list_ps_fail:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_released_list_ps_fail_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_released_list_ps_fail:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_released_list_ps_fail_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PathSwitchRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t path_switch_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {85, 100, 121, 119, 76, 57, 237, 333};
  return map_enum_number(names, 8, idx, "id");
}
bool path_switch_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {85, 100, 121, 119, 76, 57, 237, 333};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e path_switch_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 85:
      return crit_e::reject;
    case 100:
      return crit_e::reject;
    case 121:
      return crit_e::ignore;
    case 119:
      return crit_e::ignore;
    case 76:
      return crit_e::reject;
    case 57:
      return crit_e::ignore;
    case 237:
      return crit_e::ignore;
    case 333:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
path_switch_request_ies_o::value_c path_switch_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 100:
      ret.set(value_c::types::source_amf_ue_ngap_id);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 119:
      ret.set(value_c::types::ue_security_cap);
      break;
    case 76:
      ret.set(value_c::types::pdu_session_res_to_be_switched_dl_list);
      break;
    case 57:
      ret.set(value_c::types::pdu_session_res_failed_to_setup_list_ps_req);
      break;
    case 237:
      ret.set(value_c::types::rrc_resume_cause);
      break;
    case 333:
      ret.set(value_c::types::red_cap_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e path_switch_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 85:
      return presence_e::mandatory;
    case 100:
      return presence_e::mandatory;
    case 121:
      return presence_e::mandatory;
    case 119:
      return presence_e::mandatory;
    case 76:
      return presence_e::mandatory;
    case 57:
      return presence_e::optional;
    case 237:
      return presence_e::optional;
    case 333:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void path_switch_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    case types::ue_security_cap:
      c.destroy<ue_security_cap_s>();
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      c.destroy<pdu_session_res_to_be_switched_dl_list_l>();
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      c.destroy<pdu_session_res_failed_to_setup_list_ps_req_l>();
      break;
    default:
      break;
  }
}
void path_switch_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ran_ue_ngap_id:
      break;
    case types::source_amf_ue_ngap_id:
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::ue_security_cap:
      c.init<ue_security_cap_s>();
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      c.init<pdu_session_res_to_be_switched_dl_list_l>();
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      c.init<pdu_session_res_failed_to_setup_list_ps_req_l>();
      break;
    case types::rrc_resume_cause:
      break;
    case types::red_cap_ind:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
  }
}
path_switch_request_ies_o::value_c::value_c(const path_switch_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::source_amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::ue_security_cap:
      c.init(other.c.get<ue_security_cap_s>());
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      c.init(other.c.get<pdu_session_res_to_be_switched_dl_list_l>());
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      c.init(other.c.get<pdu_session_res_failed_to_setup_list_ps_req_l>());
      break;
    case types::rrc_resume_cause:
      c.init(other.c.get<rrc_establishment_cause_e>());
      break;
    case types::red_cap_ind:
      c.init(other.c.get<red_cap_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
  }
}
path_switch_request_ies_o::value_c&
path_switch_request_ies_o::value_c::operator=(const path_switch_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::source_amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::ue_security_cap:
      c.set(other.c.get<ue_security_cap_s>());
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      c.set(other.c.get<pdu_session_res_to_be_switched_dl_list_l>());
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      c.set(other.c.get<pdu_session_res_failed_to_setup_list_ps_req_l>());
      break;
    case types::rrc_resume_cause:
      c.set(other.c.get<rrc_establishment_cause_e>());
      break;
    case types::red_cap_ind:
      c.set(other.c.get<red_cap_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& path_switch_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& path_switch_request_ies_o::value_c::source_amf_ue_ngap_id()
{
  assert_choice_type(types::source_amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
user_location_info_c& path_switch_request_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
ue_security_cap_s& path_switch_request_ies_o::value_c::ue_security_cap()
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
pdu_session_res_to_be_switched_dl_list_l& path_switch_request_ies_o::value_c::pdu_session_res_to_be_switched_dl_list()
{
  assert_choice_type(types::pdu_session_res_to_be_switched_dl_list, type_, "Value");
  return c.get<pdu_session_res_to_be_switched_dl_list_l>();
}
pdu_session_res_failed_to_setup_list_ps_req_l&
path_switch_request_ies_o::value_c::pdu_session_res_failed_to_setup_list_ps_req()
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_ps_req, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_ps_req_l>();
}
rrc_establishment_cause_e& path_switch_request_ies_o::value_c::rrc_resume_cause()
{
  assert_choice_type(types::rrc_resume_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
red_cap_ind_e& path_switch_request_ies_o::value_c::red_cap_ind()
{
  assert_choice_type(types::red_cap_ind, type_, "Value");
  return c.get<red_cap_ind_e>();
}
const uint64_t& path_switch_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& path_switch_request_ies_o::value_c::source_amf_ue_ngap_id() const
{
  assert_choice_type(types::source_amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const user_location_info_c& path_switch_request_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const ue_security_cap_s& path_switch_request_ies_o::value_c::ue_security_cap() const
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
const pdu_session_res_to_be_switched_dl_list_l&
path_switch_request_ies_o::value_c::pdu_session_res_to_be_switched_dl_list() const
{
  assert_choice_type(types::pdu_session_res_to_be_switched_dl_list, type_, "Value");
  return c.get<pdu_session_res_to_be_switched_dl_list_l>();
}
const pdu_session_res_failed_to_setup_list_ps_req_l&
path_switch_request_ies_o::value_c::pdu_session_res_failed_to_setup_list_ps_req() const
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_ps_req, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_ps_req_l>();
}
const rrc_establishment_cause_e& path_switch_request_ies_o::value_c::rrc_resume_cause() const
{
  assert_choice_type(types::rrc_resume_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
const red_cap_ind_e& path_switch_request_ies_o::value_c::red_cap_ind() const
{
  assert_choice_type(types::red_cap_ind, type_, "Value");
  return c.get<red_cap_ind_e>();
}
void path_switch_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::source_amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::ue_security_cap:
      j.write_fieldname("UESecurityCapabilities");
      c.get<ue_security_cap_s>().to_json(j);
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      j.start_array("PDUSessionResourceToBeSwitchedDLList");
      for (const auto& e1 : c.get<pdu_session_res_to_be_switched_dl_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      j.start_array("PDUSessionResourceFailedToSetupListPSReq");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_setup_list_ps_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::rrc_resume_cause:
      j.write_str("RRCEstablishmentCause", c.get<rrc_establishment_cause_e>().to_string());
      break;
    case types::red_cap_ind:
      j.write_str("RedCapIndication", "redcap");
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE path_switch_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::source_amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().pack(bref));
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_to_be_switched_dl_list_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_setup_list_ps_req_l>(), 1, 256, true));
      break;
    case types::rrc_resume_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().pack(bref));
      break;
    case types::red_cap_ind:
      HANDLE_CODE(c.get<red_cap_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::source_amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().unpack(bref));
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_to_be_switched_dl_list_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_setup_list_ps_req_l>(), bref, 1, 256, true));
      break;
    case types::rrc_resume_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().unpack(bref));
      break;
    case types::red_cap_ind:
      HANDLE_CODE(c.get<red_cap_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// RANCPRelocationIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ran_cp_relocation_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {85, 26, 25, 213, 211};
  return map_enum_number(names, 5, idx, "id");
}
bool ran_cp_relocation_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {85, 26, 25, 213, 211};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ran_cp_relocation_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 85:
      return crit_e::reject;
    case 26:
      return crit_e::reject;
    case 25:
      return crit_e::ignore;
    case 213:
      return crit_e::ignore;
    case 211:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ran_cp_relocation_ind_ies_o::value_c ran_cp_relocation_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 26:
      ret.set(value_c::types::five_g_s_tmsi);
      break;
    case 25:
      ret.set(value_c::types::eutra_cgi);
      break;
    case 213:
      ret.set(value_c::types::tai);
      break;
    case 211:
      ret.set(value_c::types::ul_cp_security_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ran_cp_relocation_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 85:
      return presence_e::mandatory;
    case 26:
      return presence_e::mandatory;
    case 25:
      return presence_e::mandatory;
    case 213:
      return presence_e::mandatory;
    case 211:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ran_cp_relocation_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::five_g_s_tmsi:
      c.destroy<five_g_s_tmsi_s>();
      break;
    case types::eutra_cgi:
      c.destroy<eutra_cgi_s>();
      break;
    case types::tai:
      c.destroy<tai_s>();
      break;
    case types::ul_cp_security_info:
      c.destroy<ul_cp_security_info_s>();
      break;
    default:
      break;
  }
}
void ran_cp_relocation_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ran_ue_ngap_id:
      break;
    case types::five_g_s_tmsi:
      c.init<five_g_s_tmsi_s>();
      break;
    case types::eutra_cgi:
      c.init<eutra_cgi_s>();
      break;
    case types::tai:
      c.init<tai_s>();
      break;
    case types::ul_cp_security_info:
      c.init<ul_cp_security_info_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cp_relocation_ind_ies_o::value_c");
  }
}
ran_cp_relocation_ind_ies_o::value_c::value_c(const ran_cp_relocation_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::five_g_s_tmsi:
      c.init(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::eutra_cgi:
      c.init(other.c.get<eutra_cgi_s>());
      break;
    case types::tai:
      c.init(other.c.get<tai_s>());
      break;
    case types::ul_cp_security_info:
      c.init(other.c.get<ul_cp_security_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cp_relocation_ind_ies_o::value_c");
  }
}
ran_cp_relocation_ind_ies_o::value_c&
ran_cp_relocation_ind_ies_o::value_c::operator=(const ran_cp_relocation_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::five_g_s_tmsi:
      c.set(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::eutra_cgi:
      c.set(other.c.get<eutra_cgi_s>());
      break;
    case types::tai:
      c.set(other.c.get<tai_s>());
      break;
    case types::ul_cp_security_info:
      c.set(other.c.get<ul_cp_security_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cp_relocation_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& ran_cp_relocation_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
five_g_s_tmsi_s& ran_cp_relocation_ind_ies_o::value_c::five_g_s_tmsi()
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
eutra_cgi_s& ran_cp_relocation_ind_ies_o::value_c::eutra_cgi()
{
  assert_choice_type(types::eutra_cgi, type_, "Value");
  return c.get<eutra_cgi_s>();
}
tai_s& ran_cp_relocation_ind_ies_o::value_c::tai()
{
  assert_choice_type(types::tai, type_, "Value");
  return c.get<tai_s>();
}
ul_cp_security_info_s& ran_cp_relocation_ind_ies_o::value_c::ul_cp_security_info()
{
  assert_choice_type(types::ul_cp_security_info, type_, "Value");
  return c.get<ul_cp_security_info_s>();
}
const uint64_t& ran_cp_relocation_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const five_g_s_tmsi_s& ran_cp_relocation_ind_ies_o::value_c::five_g_s_tmsi() const
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
const eutra_cgi_s& ran_cp_relocation_ind_ies_o::value_c::eutra_cgi() const
{
  assert_choice_type(types::eutra_cgi, type_, "Value");
  return c.get<eutra_cgi_s>();
}
const tai_s& ran_cp_relocation_ind_ies_o::value_c::tai() const
{
  assert_choice_type(types::tai, type_, "Value");
  return c.get<tai_s>();
}
const ul_cp_security_info_s& ran_cp_relocation_ind_ies_o::value_c::ul_cp_security_info() const
{
  assert_choice_type(types::ul_cp_security_info, type_, "Value");
  return c.get<ul_cp_security_info_s>();
}
void ran_cp_relocation_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::five_g_s_tmsi:
      j.write_fieldname("FiveG-S-TMSI");
      c.get<five_g_s_tmsi_s>().to_json(j);
      break;
    case types::eutra_cgi:
      j.write_fieldname("EUTRA-CGI");
      c.get<eutra_cgi_s>().to_json(j);
      break;
    case types::tai:
      j.write_fieldname("TAI");
      c.get<tai_s>().to_json(j);
      break;
    case types::ul_cp_security_info:
      j.write_fieldname("UL-CP-SecurityInformation");
      c.get<ul_cp_security_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ran_cp_relocation_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ran_cp_relocation_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().pack(bref));
      break;
    case types::eutra_cgi:
      HANDLE_CODE(c.get<eutra_cgi_s>().pack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().pack(bref));
      break;
    case types::ul_cp_security_info:
      HANDLE_CODE(c.get<ul_cp_security_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_cp_relocation_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cp_relocation_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().unpack(bref));
      break;
    case types::eutra_cgi:
      HANDLE_CODE(c.get<eutra_cgi_s>().unpack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().unpack(bref));
      break;
    case types::ul_cp_security_info:
      HANDLE_CODE(c.get<ul_cp_security_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_cp_relocation_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// RANConfigurationUpdateAcknowledgeIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ran_cfg_upd_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {19};
  return map_enum_number(names, 1, idx, "id");
}
bool ran_cfg_upd_ack_ies_o::is_id_valid(const uint32_t& id)
{
  return 19 == id;
}
crit_e ran_cfg_upd_ack_ies_o::get_crit(const uint32_t& id)
{
  if (id == 19) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
ran_cfg_upd_ack_ies_o::value_c ran_cfg_upd_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 19) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ran_cfg_upd_ack_ies_o::get_presence(const uint32_t& id)
{
  if (id == 19) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void ran_cfg_upd_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("CriticalityDiagnostics");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE ran_cfg_upd_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cfg_upd_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// RANConfigurationUpdateFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ran_cfg_upd_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {15, 107, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool ran_cfg_upd_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {15, 107, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ran_cfg_upd_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 15:
      return crit_e::ignore;
    case 107:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ran_cfg_upd_fail_ies_o::value_c ran_cfg_upd_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 107:
      ret.set(value_c::types::time_to_wait);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ran_cfg_upd_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 15:
      return presence_e::mandatory;
    case 107:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ran_cfg_upd_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ran_cfg_upd_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cause:
      c.init<cause_c>();
      break;
    case types::time_to_wait:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_fail_ies_o::value_c");
  }
}
ran_cfg_upd_fail_ies_o::value_c::value_c(const ran_cfg_upd_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::time_to_wait:
      c.init(other.c.get<time_to_wait_e>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_fail_ies_o::value_c");
  }
}
ran_cfg_upd_fail_ies_o::value_c&
ran_cfg_upd_fail_ies_o::value_c::operator=(const ran_cfg_upd_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::time_to_wait:
      c.set(other.c.get<time_to_wait_e>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_fail_ies_o::value_c");
  }

  return *this;
}
cause_c& ran_cfg_upd_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
time_to_wait_e& ran_cfg_upd_fail_ies_o::value_c::time_to_wait()
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
crit_diagnostics_s& ran_cfg_upd_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const cause_c& ran_cfg_upd_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const time_to_wait_e& ran_cfg_upd_fail_ies_o::value_c::time_to_wait() const
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
const crit_diagnostics_s& ran_cfg_upd_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ran_cfg_upd_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::time_to_wait:
      j.write_str("TimeToWait", c.get<time_to_wait_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ran_cfg_upd_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cfg_upd_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// RANConfigurationUpdateIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ran_cfg_upd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {82, 102, 21, 27, 167, 204, 273};
  return map_enum_number(names, 7, idx, "id");
}
bool ran_cfg_upd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {82, 102, 21, 27, 167, 204, 273};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ran_cfg_upd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 82:
      return crit_e::ignore;
    case 102:
      return crit_e::reject;
    case 21:
      return crit_e::ignore;
    case 27:
      return crit_e::ignore;
    case 167:
      return crit_e::reject;
    case 204:
      return crit_e::ignore;
    case 273:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ran_cfg_upd_ies_o::value_c ran_cfg_upd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 82:
      ret.set(value_c::types::ran_node_name);
      break;
    case 102:
      ret.set(value_c::types::supported_ta_list);
      break;
    case 21:
      ret.set(value_c::types::default_paging_drx);
      break;
    case 27:
      ret.set(value_c::types::global_ran_node_id);
      break;
    case 167:
      ret.set(value_c::types::ngran_tnl_assoc_to_rem_list);
      break;
    case 204:
      ret.set(value_c::types::nb_iot_default_paging_drx);
      break;
    case 273:
      ret.set(value_c::types::extended_ran_node_name);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ran_cfg_upd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 82:
      return presence_e::optional;
    case 102:
      return presence_e::optional;
    case 21:
      return presence_e::optional;
    case 27:
      return presence_e::optional;
    case 167:
      return presence_e::optional;
    case 204:
      return presence_e::optional;
    case 273:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ran_cfg_upd_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ran_node_name:
      c.destroy<printable_string<1, 150, true, true>>();
      break;
    case types::supported_ta_list:
      c.destroy<supported_ta_list_l>();
      break;
    case types::global_ran_node_id:
      c.destroy<global_ran_node_id_c>();
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      c.destroy<ngran_tnl_assoc_to_rem_list_l>();
      break;
    case types::extended_ran_node_name:
      c.destroy<extended_ran_node_name_s>();
      break;
    default:
      break;
  }
}
void ran_cfg_upd_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ran_node_name:
      c.init<printable_string<1, 150, true, true>>();
      break;
    case types::supported_ta_list:
      c.init<supported_ta_list_l>();
      break;
    case types::default_paging_drx:
      break;
    case types::global_ran_node_id:
      c.init<global_ran_node_id_c>();
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      c.init<ngran_tnl_assoc_to_rem_list_l>();
      break;
    case types::nb_iot_default_paging_drx:
      break;
    case types::extended_ran_node_name:
      c.init<extended_ran_node_name_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_ies_o::value_c");
  }
}
ran_cfg_upd_ies_o::value_c::value_c(const ran_cfg_upd_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ran_node_name:
      c.init(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::supported_ta_list:
      c.init(other.c.get<supported_ta_list_l>());
      break;
    case types::default_paging_drx:
      c.init(other.c.get<paging_drx_e>());
      break;
    case types::global_ran_node_id:
      c.init(other.c.get<global_ran_node_id_c>());
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      c.init(other.c.get<ngran_tnl_assoc_to_rem_list_l>());
      break;
    case types::nb_iot_default_paging_drx:
      c.init(other.c.get<nb_iot_default_paging_drx_e>());
      break;
    case types::extended_ran_node_name:
      c.init(other.c.get<extended_ran_node_name_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_ies_o::value_c");
  }
}
ran_cfg_upd_ies_o::value_c& ran_cfg_upd_ies_o::value_c::operator=(const ran_cfg_upd_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ran_node_name:
      c.set(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::supported_ta_list:
      c.set(other.c.get<supported_ta_list_l>());
      break;
    case types::default_paging_drx:
      c.set(other.c.get<paging_drx_e>());
      break;
    case types::global_ran_node_id:
      c.set(other.c.get<global_ran_node_id_c>());
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      c.set(other.c.get<ngran_tnl_assoc_to_rem_list_l>());
      break;
    case types::nb_iot_default_paging_drx:
      c.set(other.c.get<nb_iot_default_paging_drx_e>());
      break;
    case types::extended_ran_node_name:
      c.set(other.c.get<extended_ran_node_name_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_ies_o::value_c");
  }

  return *this;
}
printable_string<1, 150, true, true>& ran_cfg_upd_ies_o::value_c::ran_node_name()
{
  assert_choice_type(types::ran_node_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
supported_ta_list_l& ran_cfg_upd_ies_o::value_c::supported_ta_list()
{
  assert_choice_type(types::supported_ta_list, type_, "Value");
  return c.get<supported_ta_list_l>();
}
paging_drx_e& ran_cfg_upd_ies_o::value_c::default_paging_drx()
{
  assert_choice_type(types::default_paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
global_ran_node_id_c& ran_cfg_upd_ies_o::value_c::global_ran_node_id()
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
ngran_tnl_assoc_to_rem_list_l& ran_cfg_upd_ies_o::value_c::ngran_tnl_assoc_to_rem_list()
{
  assert_choice_type(types::ngran_tnl_assoc_to_rem_list, type_, "Value");
  return c.get<ngran_tnl_assoc_to_rem_list_l>();
}
nb_iot_default_paging_drx_e& ran_cfg_upd_ies_o::value_c::nb_iot_default_paging_drx()
{
  assert_choice_type(types::nb_iot_default_paging_drx, type_, "Value");
  return c.get<nb_iot_default_paging_drx_e>();
}
extended_ran_node_name_s& ran_cfg_upd_ies_o::value_c::extended_ran_node_name()
{
  assert_choice_type(types::extended_ran_node_name, type_, "Value");
  return c.get<extended_ran_node_name_s>();
}
const printable_string<1, 150, true, true>& ran_cfg_upd_ies_o::value_c::ran_node_name() const
{
  assert_choice_type(types::ran_node_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
const supported_ta_list_l& ran_cfg_upd_ies_o::value_c::supported_ta_list() const
{
  assert_choice_type(types::supported_ta_list, type_, "Value");
  return c.get<supported_ta_list_l>();
}
const paging_drx_e& ran_cfg_upd_ies_o::value_c::default_paging_drx() const
{
  assert_choice_type(types::default_paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
const global_ran_node_id_c& ran_cfg_upd_ies_o::value_c::global_ran_node_id() const
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
const ngran_tnl_assoc_to_rem_list_l& ran_cfg_upd_ies_o::value_c::ngran_tnl_assoc_to_rem_list() const
{
  assert_choice_type(types::ngran_tnl_assoc_to_rem_list, type_, "Value");
  return c.get<ngran_tnl_assoc_to_rem_list_l>();
}
const nb_iot_default_paging_drx_e& ran_cfg_upd_ies_o::value_c::nb_iot_default_paging_drx() const
{
  assert_choice_type(types::nb_iot_default_paging_drx, type_, "Value");
  return c.get<nb_iot_default_paging_drx_e>();
}
const extended_ran_node_name_s& ran_cfg_upd_ies_o::value_c::extended_ran_node_name() const
{
  assert_choice_type(types::extended_ran_node_name, type_, "Value");
  return c.get<extended_ran_node_name_s>();
}
void ran_cfg_upd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ran_node_name:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true>>().to_string());
      break;
    case types::supported_ta_list:
      j.start_array("SupportedTAList");
      for (const auto& e1 : c.get<supported_ta_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::default_paging_drx:
      j.write_str("PagingDRX", c.get<paging_drx_e>().to_string());
      break;
    case types::global_ran_node_id:
      j.write_fieldname("GlobalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      j.start_array("NGRAN-TNLAssociationToRemoveList");
      for (const auto& e1 : c.get<ngran_tnl_assoc_to_rem_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::nb_iot_default_paging_drx:
      j.write_str("NB-IoT-DefaultPagingDRX", c.get<nb_iot_default_paging_drx_e>().to_string());
      break;
    case types::extended_ran_node_name:
      j.write_fieldname("Extended-RANNodeName");
      c.get<extended_ran_node_name_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ran_cfg_upd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_node_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().pack(bref)));
      break;
    case types::supported_ta_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<supported_ta_list_l>(), 1, 256, true));
      break;
    case types::default_paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().pack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ngran_tnl_assoc_to_rem_list_l>(), 1, 32, true));
      break;
    case types::nb_iot_default_paging_drx:
      HANDLE_CODE(c.get<nb_iot_default_paging_drx_e>().pack(bref));
      break;
    case types::extended_ran_node_name:
      HANDLE_CODE(c.get<extended_ran_node_name_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cfg_upd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_node_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().unpack(bref)));
      break;
    case types::supported_ta_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<supported_ta_list_l>(), bref, 1, 256, true));
      break;
    case types::default_paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().unpack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ngran_tnl_assoc_to_rem_list_l>(), bref, 1, 32, true));
      break;
    case types::nb_iot_default_paging_drx:
      HANDLE_CODE(c.get<nb_iot_default_paging_drx_e>().unpack(bref));
      break;
    case types::extended_ran_node_name:
      HANDLE_CODE(c.get<extended_ran_node_name_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// RRCInactiveTransitionReportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t rrc_inactive_transition_report_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 92, 121};
  return map_enum_number(names, 4, idx, "id");
}
bool rrc_inactive_transition_report_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 92, 121};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e rrc_inactive_transition_report_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 92:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
rrc_inactive_transition_report_ies_o::value_c rrc_inactive_transition_report_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 92:
      ret.set(value_c::types::rrc_state);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e rrc_inactive_transition_report_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 92:
      return presence_e::mandatory;
    case 121:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void rrc_inactive_transition_report_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    default:
      break;
  }
}
void rrc_inactive_transition_report_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::rrc_state:
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rrc_inactive_transition_report_ies_o::value_c");
  }
}
rrc_inactive_transition_report_ies_o::value_c::value_c(const rrc_inactive_transition_report_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::rrc_state:
      c.init(other.c.get<rrc_state_e>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rrc_inactive_transition_report_ies_o::value_c");
  }
}
rrc_inactive_transition_report_ies_o::value_c&
rrc_inactive_transition_report_ies_o::value_c::operator=(const rrc_inactive_transition_report_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::rrc_state:
      c.set(other.c.get<rrc_state_e>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rrc_inactive_transition_report_ies_o::value_c");
  }

  return *this;
}
uint64_t& rrc_inactive_transition_report_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& rrc_inactive_transition_report_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
rrc_state_e& rrc_inactive_transition_report_ies_o::value_c::rrc_state()
{
  assert_choice_type(types::rrc_state, type_, "Value");
  return c.get<rrc_state_e>();
}
user_location_info_c& rrc_inactive_transition_report_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const uint64_t& rrc_inactive_transition_report_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& rrc_inactive_transition_report_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const rrc_state_e& rrc_inactive_transition_report_ies_o::value_c::rrc_state() const
{
  assert_choice_type(types::rrc_state, type_, "Value");
  return c.get<rrc_state_e>();
}
const user_location_info_c& rrc_inactive_transition_report_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
void rrc_inactive_transition_report_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::rrc_state:
      j.write_str("RRCState", c.get<rrc_state_e>().to_string());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "rrc_inactive_transition_report_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE rrc_inactive_transition_report_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::rrc_state:
      HANDLE_CODE(c.get<rrc_state_e>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "rrc_inactive_transition_report_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE rrc_inactive_transition_report_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::rrc_state:
      HANDLE_CODE(c.get<rrc_state_e>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "rrc_inactive_transition_report_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// RerouteNASRequest-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t reroute_nas_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {85, 10, 42, 3, 0, 171};
  return map_enum_number(names, 6, idx, "id");
}
bool reroute_nas_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {85, 10, 42, 3, 0, 171};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e reroute_nas_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 85:
      return crit_e::reject;
    case 10:
      return crit_e::ignore;
    case 42:
      return crit_e::reject;
    case 3:
      return crit_e::reject;
    case 0:
      return crit_e::reject;
    case 171:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
reroute_nas_request_ies_o::value_c reroute_nas_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 42:
      ret.set(value_c::types::ngap_msg);
      break;
    case 3:
      ret.set(value_c::types::amf_set_id);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 171:
      ret.set(value_c::types::source_to_target_amf_info_reroute);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e reroute_nas_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 85:
      return presence_e::mandatory;
    case 10:
      return presence_e::optional;
    case 42:
      return presence_e::mandatory;
    case 3:
      return presence_e::mandatory;
    case 0:
      return presence_e::optional;
    case 171:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void reroute_nas_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ngap_msg:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::amf_set_id:
      c.destroy<fixed_bitstring<10, false, true>>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    case types::source_to_target_amf_info_reroute:
      c.destroy<source_to_target_amf_info_reroute_s>();
      break;
    default:
      break;
  }
}
void reroute_nas_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ran_ue_ngap_id:
      break;
    case types::amf_ue_ngap_id:
      break;
    case types::ngap_msg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::amf_set_id:
      c.init<fixed_bitstring<10, false, true>>();
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::source_to_target_amf_info_reroute:
      c.init<source_to_target_amf_info_reroute_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
  }
}
reroute_nas_request_ies_o::value_c::value_c(const reroute_nas_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ngap_msg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::amf_set_id:
      c.init(other.c.get<fixed_bitstring<10, false, true>>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::source_to_target_amf_info_reroute:
      c.init(other.c.get<source_to_target_amf_info_reroute_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
  }
}
reroute_nas_request_ies_o::value_c&
reroute_nas_request_ies_o::value_c::operator=(const reroute_nas_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ngap_msg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::amf_set_id:
      c.set(other.c.get<fixed_bitstring<10, false, true>>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::source_to_target_amf_info_reroute:
      c.set(other.c.get<source_to_target_amf_info_reroute_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& reroute_nas_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& reroute_nas_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& reroute_nas_request_ies_o::value_c::ngap_msg()
{
  assert_choice_type(types::ngap_msg, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
fixed_bitstring<10, false, true>& reroute_nas_request_ies_o::value_c::amf_set_id()
{
  assert_choice_type(types::amf_set_id, type_, "Value");
  return c.get<fixed_bitstring<10, false, true>>();
}
allowed_nssai_l& reroute_nas_request_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
source_to_target_amf_info_reroute_s& reroute_nas_request_ies_o::value_c::source_to_target_amf_info_reroute()
{
  assert_choice_type(types::source_to_target_amf_info_reroute, type_, "Value");
  return c.get<source_to_target_amf_info_reroute_s>();
}
const uint64_t& reroute_nas_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& reroute_nas_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& reroute_nas_request_ies_o::value_c::ngap_msg() const
{
  assert_choice_type(types::ngap_msg, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const fixed_bitstring<10, false, true>& reroute_nas_request_ies_o::value_c::amf_set_id() const
{
  assert_choice_type(types::amf_set_id, type_, "Value");
  return c.get<fixed_bitstring<10, false, true>>();
}
const allowed_nssai_l& reroute_nas_request_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const source_to_target_amf_info_reroute_s& reroute_nas_request_ies_o::value_c::source_to_target_amf_info_reroute() const
{
  assert_choice_type(types::source_to_target_amf_info_reroute, type_, "Value");
  return c.get<source_to_target_amf_info_reroute_s>();
}
void reroute_nas_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ngap_msg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::amf_set_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<10, false, true>>().to_string());
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::source_to_target_amf_info_reroute:
      j.write_fieldname("SourceToTarget-AMFInformationReroute");
      c.get<source_to_target_amf_info_reroute_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE reroute_nas_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ngap_msg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::amf_set_id:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().pack(bref)));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::source_to_target_amf_info_reroute:
      HANDLE_CODE(c.get<source_to_target_amf_info_reroute_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE reroute_nas_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ngap_msg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::amf_set_id:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().unpack(bref)));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::source_to_target_amf_info_reroute:
      HANDLE_CODE(c.get<source_to_target_amf_info_reroute_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// RetrieveUEInformationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t retrieve_ue_info_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {26};
  return map_enum_number(names, 1, idx, "id");
}
bool retrieve_ue_info_ies_o::is_id_valid(const uint32_t& id)
{
  return 26 == id;
}
crit_e retrieve_ue_info_ies_o::get_crit(const uint32_t& id)
{
  if (id == 26) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
retrieve_ue_info_ies_o::value_c retrieve_ue_info_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 26) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e retrieve_ue_info_ies_o::get_presence(const uint32_t& id)
{
  if (id == 26) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void retrieve_ue_info_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("FiveG-S-TMSI");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE retrieve_ue_info_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE retrieve_ue_info_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// SecondaryRATDataUsageReportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t secondary_rat_data_usage_report_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 142, 143, 121};
  return map_enum_number(names, 5, idx, "id");
}
bool secondary_rat_data_usage_report_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 142, 143, 121};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e secondary_rat_data_usage_report_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 142:
      return crit_e::ignore;
    case 143:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
secondary_rat_data_usage_report_ies_o::value_c secondary_rat_data_usage_report_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 142:
      ret.set(value_c::types::pdu_session_res_secondary_rat_usage_list);
      break;
    case 143:
      ret.set(value_c::types::ho_flag);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e secondary_rat_data_usage_report_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 142:
      return presence_e::mandatory;
    case 143:
      return presence_e::optional;
    case 121:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void secondary_rat_data_usage_report_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_secondary_rat_usage_list:
      c.destroy<pdu_session_res_secondary_rat_usage_list_l>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    default:
      break;
  }
}
void secondary_rat_data_usage_report_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_secondary_rat_usage_list:
      c.init<pdu_session_res_secondary_rat_usage_list_l>();
      break;
    case types::ho_flag:
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
  }
}
secondary_rat_data_usage_report_ies_o::value_c::value_c(const secondary_rat_data_usage_report_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_secondary_rat_usage_list:
      c.init(other.c.get<pdu_session_res_secondary_rat_usage_list_l>());
      break;
    case types::ho_flag:
      c.init(other.c.get<ho_flag_e>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
  }
}
secondary_rat_data_usage_report_ies_o::value_c&
secondary_rat_data_usage_report_ies_o::value_c::operator=(const secondary_rat_data_usage_report_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_secondary_rat_usage_list:
      c.set(other.c.get<pdu_session_res_secondary_rat_usage_list_l>());
      break;
    case types::ho_flag:
      c.set(other.c.get<ho_flag_e>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
  }

  return *this;
}
uint64_t& secondary_rat_data_usage_report_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& secondary_rat_data_usage_report_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_secondary_rat_usage_list_l&
secondary_rat_data_usage_report_ies_o::value_c::pdu_session_res_secondary_rat_usage_list()
{
  assert_choice_type(types::pdu_session_res_secondary_rat_usage_list, type_, "Value");
  return c.get<pdu_session_res_secondary_rat_usage_list_l>();
}
ho_flag_e& secondary_rat_data_usage_report_ies_o::value_c::ho_flag()
{
  assert_choice_type(types::ho_flag, type_, "Value");
  return c.get<ho_flag_e>();
}
user_location_info_c& secondary_rat_data_usage_report_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const uint64_t& secondary_rat_data_usage_report_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& secondary_rat_data_usage_report_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_secondary_rat_usage_list_l&
secondary_rat_data_usage_report_ies_o::value_c::pdu_session_res_secondary_rat_usage_list() const
{
  assert_choice_type(types::pdu_session_res_secondary_rat_usage_list, type_, "Value");
  return c.get<pdu_session_res_secondary_rat_usage_list_l>();
}
const ho_flag_e& secondary_rat_data_usage_report_ies_o::value_c::ho_flag() const
{
  assert_choice_type(types::ho_flag, type_, "Value");
  return c.get<ho_flag_e>();
}
const user_location_info_c& secondary_rat_data_usage_report_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
void secondary_rat_data_usage_report_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_secondary_rat_usage_list:
      j.start_array("PDUSessionResourceSecondaryRATUsageList");
      for (const auto& e1 : c.get<pdu_session_res_secondary_rat_usage_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ho_flag:
      j.write_str("HandoverFlag", "handover-preparation");
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE secondary_rat_data_usage_report_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_secondary_rat_usage_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_secondary_rat_usage_list_l>(), 1, 256, true));
      break;
    case types::ho_flag:
      HANDLE_CODE(c.get<ho_flag_e>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE secondary_rat_data_usage_report_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_secondary_rat_usage_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_secondary_rat_usage_list_l>(), bref, 1, 256, true));
      break;
    case types::ho_flag:
      HANDLE_CODE(c.get<ho_flag_e>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// TraceFailureIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t trace_fail_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 44, 15};
  return map_enum_number(names, 4, idx, "id");
}
bool trace_fail_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 44, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e trace_fail_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 44:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
trace_fail_ind_ies_o::value_c trace_fail_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 44:
      ret.set(value_c::types::ngran_trace_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e trace_fail_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 44:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void trace_fail_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ngran_trace_id:
      c.destroy<fixed_octstring<8, true>>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void trace_fail_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ngran_trace_id:
      c.init<fixed_octstring<8, true>>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
  }
}
trace_fail_ind_ies_o::value_c::value_c(const trace_fail_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      c.init(other.c.get<fixed_octstring<8, true>>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
  }
}
trace_fail_ind_ies_o::value_c& trace_fail_ind_ies_o::value_c::operator=(const trace_fail_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      c.set(other.c.get<fixed_octstring<8, true>>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& trace_fail_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& trace_fail_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
fixed_octstring<8, true>& trace_fail_ind_ies_o::value_c::ngran_trace_id()
{
  assert_choice_type(types::ngran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true>>();
}
cause_c& trace_fail_ind_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const uint64_t& trace_fail_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& trace_fail_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const fixed_octstring<8, true>& trace_fail_ind_ies_o::value_c::ngran_trace_id() const
{
  assert_choice_type(types::ngran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true>>();
}
const cause_c& trace_fail_ind_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void trace_fail_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<8, true>>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE trace_fail_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ngran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().pack(bref)));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_fail_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ngran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().unpack(bref)));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// TraceStartIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t trace_start_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 108};
  return map_enum_number(names, 3, idx, "id");
}
bool trace_start_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 108};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e trace_start_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 108:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
trace_start_ies_o::value_c trace_start_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 108:
      ret.set(value_c::types::trace_activation);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e trace_start_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 108:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void trace_start_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::trace_activation:
      c.destroy<trace_activation_s>();
      break;
    default:
      break;
  }
}
void trace_start_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::trace_activation:
      c.init<trace_activation_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
  }
}
trace_start_ies_o::value_c::value_c(const trace_start_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::trace_activation:
      c.init(other.c.get<trace_activation_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
  }
}
trace_start_ies_o::value_c& trace_start_ies_o::value_c::operator=(const trace_start_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::trace_activation:
      c.set(other.c.get<trace_activation_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
  }

  return *this;
}
uint64_t& trace_start_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& trace_start_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
trace_activation_s& trace_start_ies_o::value_c::trace_activation()
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
const uint64_t& trace_start_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& trace_start_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const trace_activation_s& trace_start_ies_o::value_c::trace_activation() const
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
void trace_start_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::trace_activation:
      j.write_fieldname("TraceActivation");
      c.get<trace_activation_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE trace_start_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_start_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEContextModificationFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_mod_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_context_mod_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_mod_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_mod_fail_ies_o::value_c ue_context_mod_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_mod_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_mod_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_context_mod_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
  }
}
ue_context_mod_fail_ies_o::value_c::value_c(const ue_context_mod_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
  }
}
ue_context_mod_fail_ies_o::value_c&
ue_context_mod_fail_ies_o::value_c::operator=(const ue_context_mod_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_mod_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_mod_fail_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ue_context_mod_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& ue_context_mod_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_mod_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_mod_fail_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ue_context_mod_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& ue_context_mod_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_mod_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_mod_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEContextModificationRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_mod_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10,  85,  83,  94,  31,  110, 119, 18,  24,  40,  91,  162, 165, 177, 199,
                                   216, 215, 218, 217, 219, 264, 238, 326, 328, 329, 335, 359, 345, 346, 347};
  return map_enum_number(names, 30, idx, "id");
}
bool ue_context_mod_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10,  85,  83,  94,  31,  110, 119, 18,  24,  40,  91,  162, 165, 177, 199,
                                   216, 215, 218, 217, 219, 264, 238, 326, 328, 329, 335, 359, 345, 346, 347};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_mod_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 83:
      return crit_e::ignore;
    case 94:
      return crit_e::reject;
    case 31:
      return crit_e::ignore;
    case 110:
      return crit_e::ignore;
    case 119:
      return crit_e::reject;
    case 18:
      return crit_e::ignore;
    case 24:
      return crit_e::reject;
    case 40:
      return crit_e::reject;
    case 91:
      return crit_e::ignore;
    case 162:
      return crit_e::reject;
    case 165:
      return crit_e::ignore;
    case 177:
      return crit_e::ignore;
    case 199:
      return crit_e::ignore;
    case 216:
      return crit_e::ignore;
    case 215:
      return crit_e::ignore;
    case 218:
      return crit_e::ignore;
    case 217:
      return crit_e::ignore;
    case 219:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    case 238:
      return crit_e::ignore;
    case 326:
      return crit_e::ignore;
    case 328:
      return crit_e::ignore;
    case 329:
      return crit_e::ignore;
    case 335:
      return crit_e::ignore;
    case 359:
      return crit_e::ignore;
    case 345:
      return crit_e::ignore;
    case 346:
      return crit_e::ignore;
    case 347:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_mod_request_ies_o::value_c ue_context_mod_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 83:
      ret.set(value_c::types::ran_paging_prio);
      break;
    case 94:
      ret.set(value_c::types::security_key);
      break;
    case 31:
      ret.set(value_c::types::idx_to_rfsp);
      break;
    case 110:
      ret.set(value_c::types::ue_aggr_max_bit_rate);
      break;
    case 119:
      ret.set(value_c::types::ue_security_cap);
      break;
    case 18:
      ret.set(value_c::types::core_network_assist_info_for_inactive);
      break;
    case 24:
      ret.set(value_c::types::emergency_fallback_ind);
      break;
    case 40:
      ret.set(value_c::types::new_amf_ue_ngap_id);
      break;
    case 91:
      ret.set(value_c::types::rrc_inactive_transition_report_request);
      break;
    case 162:
      ret.set(value_c::types::new_guami);
      break;
    case 165:
      ret.set(value_c::types::cn_assisted_ran_tuning);
      break;
    case 177:
      ret.set(value_c::types::srvcc_operation_possible);
      break;
    case 199:
      ret.set(value_c::types::iab_authorized);
      break;
    case 216:
      ret.set(value_c::types::nr_v2x_services_authorized);
      break;
    case 215:
      ret.set(value_c::types::ltev2x_services_authorized);
      break;
    case 218:
      ret.set(value_c::types::nr_ue_sidelink_aggr_max_bitrate);
      break;
    case 217:
      ret.set(value_c::types::lte_ue_sidelink_aggr_max_bitrate);
      break;
    case 219:
      ret.set(value_c::types::pc5_qos_params);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 238:
      ret.set(value_c::types::rg_level_wireline_access_characteristics);
      break;
    case 326:
      ret.set(value_c::types::time_sync_assist_info);
      break;
    case 328:
      ret.set(value_c::types::q_mcc_onfig_info);
      break;
    case 329:
      ret.set(value_c::types::qmc_deactivation);
      break;
    case 335:
      ret.set(value_c::types::ue_slice_max_bit_rate_list);
      break;
    case 359:
      ret.set(value_c::types::management_based_mdt_plmn_mod_list);
      break;
    case 345:
      ret.set(value_c::types::five_g_pro_se_authorized);
      break;
    case 346:
      ret.set(value_c::types::five_g_pro_se_ue_pc5_aggr_max_bit_rate);
      break;
    case 347:
      ret.set(value_c::types::five_g_pro_se_pc5_qos_params);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_mod_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 83:
      return presence_e::optional;
    case 94:
      return presence_e::optional;
    case 31:
      return presence_e::optional;
    case 110:
      return presence_e::optional;
    case 119:
      return presence_e::optional;
    case 18:
      return presence_e::optional;
    case 24:
      return presence_e::optional;
    case 40:
      return presence_e::optional;
    case 91:
      return presence_e::optional;
    case 162:
      return presence_e::optional;
    case 165:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 199:
      return presence_e::optional;
    case 216:
      return presence_e::optional;
    case 215:
      return presence_e::optional;
    case 218:
      return presence_e::optional;
    case 217:
      return presence_e::optional;
    case 219:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 238:
      return presence_e::optional;
    case 326:
      return presence_e::optional;
    case 328:
      return presence_e::optional;
    case 329:
      return presence_e::optional;
    case 335:
      return presence_e::optional;
    case 359:
      return presence_e::optional;
    case 345:
      return presence_e::optional;
    case 346:
      return presence_e::optional;
    case 347:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_mod_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::security_key:
      c.destroy<fixed_bitstring<256, false, true>>();
      break;
    case types::ue_aggr_max_bit_rate:
      c.destroy<ue_aggr_max_bit_rate_s>();
      break;
    case types::ue_security_cap:
      c.destroy<ue_security_cap_s>();
      break;
    case types::core_network_assist_info_for_inactive:
      c.destroy<core_network_assist_info_for_inactive_s>();
      break;
    case types::emergency_fallback_ind:
      c.destroy<emergency_fallback_ind_s>();
      break;
    case types::new_guami:
      c.destroy<guami_s>();
      break;
    case types::cn_assisted_ran_tuning:
      c.destroy<cn_assisted_ran_tuning_s>();
      break;
    case types::nr_v2x_services_authorized:
      c.destroy<nr_v2x_services_authorized_s>();
      break;
    case types::ltev2x_services_authorized:
      c.destroy<ltev2x_services_authorized_s>();
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.destroy<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.destroy<lte_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::pc5_qos_params:
      c.destroy<pc5_qos_params_s>();
      break;
    case types::ue_radio_cap_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::rg_level_wireline_access_characteristics:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::time_sync_assist_info:
      c.destroy<time_sync_assist_info_s>();
      break;
    case types::q_mcc_onfig_info:
      c.destroy<q_mcc_onfig_info_s>();
      break;
    case types::qmc_deactivation:
      c.destroy<qmc_deactivation_s>();
      break;
    case types::ue_slice_max_bit_rate_list:
      c.destroy<ue_slice_max_bit_rate_list_l>();
      break;
    case types::management_based_mdt_plmn_mod_list:
      c.destroy<mdt_plmn_mod_list_l>();
      break;
    case types::five_g_pro_se_authorized:
      c.destroy<five_g_pro_se_authorized_s>();
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.destroy<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.destroy<five_g_pro_se_pc5_qos_params_s>();
      break;
    default:
      break;
  }
}
void ue_context_mod_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ran_paging_prio:
      break;
    case types::security_key:
      c.init<fixed_bitstring<256, false, true>>();
      break;
    case types::idx_to_rfsp:
      break;
    case types::ue_aggr_max_bit_rate:
      c.init<ue_aggr_max_bit_rate_s>();
      break;
    case types::ue_security_cap:
      c.init<ue_security_cap_s>();
      break;
    case types::core_network_assist_info_for_inactive:
      c.init<core_network_assist_info_for_inactive_s>();
      break;
    case types::emergency_fallback_ind:
      c.init<emergency_fallback_ind_s>();
      break;
    case types::new_amf_ue_ngap_id:
      break;
    case types::rrc_inactive_transition_report_request:
      break;
    case types::new_guami:
      c.init<guami_s>();
      break;
    case types::cn_assisted_ran_tuning:
      c.init<cn_assisted_ran_tuning_s>();
      break;
    case types::srvcc_operation_possible:
      break;
    case types::iab_authorized:
      break;
    case types::nr_v2x_services_authorized:
      c.init<nr_v2x_services_authorized_s>();
      break;
    case types::ltev2x_services_authorized:
      c.init<ltev2x_services_authorized_s>();
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.init<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.init<lte_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::pc5_qos_params:
      c.init<pc5_qos_params_s>();
      break;
    case types::ue_radio_cap_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::rg_level_wireline_access_characteristics:
      c.init<unbounded_octstring<true>>();
      break;
    case types::time_sync_assist_info:
      c.init<time_sync_assist_info_s>();
      break;
    case types::q_mcc_onfig_info:
      c.init<q_mcc_onfig_info_s>();
      break;
    case types::qmc_deactivation:
      c.init<qmc_deactivation_s>();
      break;
    case types::ue_slice_max_bit_rate_list:
      c.init<ue_slice_max_bit_rate_list_l>();
      break;
    case types::management_based_mdt_plmn_mod_list:
      c.init<mdt_plmn_mod_list_l>();
      break;
    case types::five_g_pro_se_authorized:
      c.init<five_g_pro_se_authorized_s>();
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.init<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.init<five_g_pro_se_pc5_qos_params_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
  }
}
ue_context_mod_request_ies_o::value_c::value_c(const ue_context_mod_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      c.init(other.c.get<uint16_t>());
      break;
    case types::security_key:
      c.init(other.c.get<fixed_bitstring<256, false, true>>());
      break;
    case types::idx_to_rfsp:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.init(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::ue_security_cap:
      c.init(other.c.get<ue_security_cap_s>());
      break;
    case types::core_network_assist_info_for_inactive:
      c.init(other.c.get<core_network_assist_info_for_inactive_s>());
      break;
    case types::emergency_fallback_ind:
      c.init(other.c.get<emergency_fallback_ind_s>());
      break;
    case types::new_amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::rrc_inactive_transition_report_request:
      c.init(other.c.get<rrc_inactive_transition_report_request_e>());
      break;
    case types::new_guami:
      c.init(other.c.get<guami_s>());
      break;
    case types::cn_assisted_ran_tuning:
      c.init(other.c.get<cn_assisted_ran_tuning_s>());
      break;
    case types::srvcc_operation_possible:
      c.init(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::iab_authorized:
      c.init(other.c.get<iab_authorized_e>());
      break;
    case types::nr_v2x_services_authorized:
      c.init(other.c.get<nr_v2x_services_authorized_s>());
      break;
    case types::ltev2x_services_authorized:
      c.init(other.c.get<ltev2x_services_authorized_s>());
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.init(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.init(other.c.get<lte_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::pc5_qos_params:
      c.init(other.c.get<pc5_qos_params_s>());
      break;
    case types::ue_radio_cap_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::rg_level_wireline_access_characteristics:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::time_sync_assist_info:
      c.init(other.c.get<time_sync_assist_info_s>());
      break;
    case types::q_mcc_onfig_info:
      c.init(other.c.get<q_mcc_onfig_info_s>());
      break;
    case types::qmc_deactivation:
      c.init(other.c.get<qmc_deactivation_s>());
      break;
    case types::ue_slice_max_bit_rate_list:
      c.init(other.c.get<ue_slice_max_bit_rate_list_l>());
      break;
    case types::management_based_mdt_plmn_mod_list:
      c.init(other.c.get<mdt_plmn_mod_list_l>());
      break;
    case types::five_g_pro_se_authorized:
      c.init(other.c.get<five_g_pro_se_authorized_s>());
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.init(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.init(other.c.get<five_g_pro_se_pc5_qos_params_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
  }
}
ue_context_mod_request_ies_o::value_c&
ue_context_mod_request_ies_o::value_c::operator=(const ue_context_mod_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      c.set(other.c.get<uint16_t>());
      break;
    case types::security_key:
      c.set(other.c.get<fixed_bitstring<256, false, true>>());
      break;
    case types::idx_to_rfsp:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.set(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::ue_security_cap:
      c.set(other.c.get<ue_security_cap_s>());
      break;
    case types::core_network_assist_info_for_inactive:
      c.set(other.c.get<core_network_assist_info_for_inactive_s>());
      break;
    case types::emergency_fallback_ind:
      c.set(other.c.get<emergency_fallback_ind_s>());
      break;
    case types::new_amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::rrc_inactive_transition_report_request:
      c.set(other.c.get<rrc_inactive_transition_report_request_e>());
      break;
    case types::new_guami:
      c.set(other.c.get<guami_s>());
      break;
    case types::cn_assisted_ran_tuning:
      c.set(other.c.get<cn_assisted_ran_tuning_s>());
      break;
    case types::srvcc_operation_possible:
      c.set(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::iab_authorized:
      c.set(other.c.get<iab_authorized_e>());
      break;
    case types::nr_v2x_services_authorized:
      c.set(other.c.get<nr_v2x_services_authorized_s>());
      break;
    case types::ltev2x_services_authorized:
      c.set(other.c.get<ltev2x_services_authorized_s>());
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.set(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.set(other.c.get<lte_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::pc5_qos_params:
      c.set(other.c.get<pc5_qos_params_s>());
      break;
    case types::ue_radio_cap_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::rg_level_wireline_access_characteristics:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::time_sync_assist_info:
      c.set(other.c.get<time_sync_assist_info_s>());
      break;
    case types::q_mcc_onfig_info:
      c.set(other.c.get<q_mcc_onfig_info_s>());
      break;
    case types::qmc_deactivation:
      c.set(other.c.get<qmc_deactivation_s>());
      break;
    case types::ue_slice_max_bit_rate_list:
      c.set(other.c.get<ue_slice_max_bit_rate_list_l>());
      break;
    case types::management_based_mdt_plmn_mod_list:
      c.set(other.c.get<mdt_plmn_mod_list_l>());
      break;
    case types::five_g_pro_se_authorized:
      c.set(other.c.get<five_g_pro_se_authorized_s>());
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.set(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.set(other.c.get<five_g_pro_se_pc5_qos_params_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_mod_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_mod_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint16_t& ue_context_mod_request_ies_o::value_c::ran_paging_prio()
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
fixed_bitstring<256, false, true>& ue_context_mod_request_ies_o::value_c::security_key()
{
  assert_choice_type(types::security_key, type_, "Value");
  return c.get<fixed_bitstring<256, false, true>>();
}
uint16_t& ue_context_mod_request_ies_o::value_c::idx_to_rfsp()
{
  assert_choice_type(types::idx_to_rfsp, type_, "Value");
  return c.get<uint16_t>();
}
ue_aggr_max_bit_rate_s& ue_context_mod_request_ies_o::value_c::ue_aggr_max_bit_rate()
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
ue_security_cap_s& ue_context_mod_request_ies_o::value_c::ue_security_cap()
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
core_network_assist_info_for_inactive_s& ue_context_mod_request_ies_o::value_c::core_network_assist_info_for_inactive()
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
emergency_fallback_ind_s& ue_context_mod_request_ies_o::value_c::emergency_fallback_ind()
{
  assert_choice_type(types::emergency_fallback_ind, type_, "Value");
  return c.get<emergency_fallback_ind_s>();
}
uint64_t& ue_context_mod_request_ies_o::value_c::new_amf_ue_ngap_id()
{
  assert_choice_type(types::new_amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
rrc_inactive_transition_report_request_e&
ue_context_mod_request_ies_o::value_c::rrc_inactive_transition_report_request()
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
guami_s& ue_context_mod_request_ies_o::value_c::new_guami()
{
  assert_choice_type(types::new_guami, type_, "Value");
  return c.get<guami_s>();
}
cn_assisted_ran_tuning_s& ue_context_mod_request_ies_o::value_c::cn_assisted_ran_tuning()
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
srvcc_operation_possible_e& ue_context_mod_request_ies_o::value_c::srvcc_operation_possible()
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
iab_authorized_e& ue_context_mod_request_ies_o::value_c::iab_authorized()
{
  assert_choice_type(types::iab_authorized, type_, "Value");
  return c.get<iab_authorized_e>();
}
nr_v2x_services_authorized_s& ue_context_mod_request_ies_o::value_c::nr_v2x_services_authorized()
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
ltev2x_services_authorized_s& ue_context_mod_request_ies_o::value_c::ltev2x_services_authorized()
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& ue_context_mod_request_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
lte_ue_sidelink_aggr_max_bitrate_s& ue_context_mod_request_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
pc5_qos_params_s& ue_context_mod_request_ies_o::value_c::pc5_qos_params()
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
unbounded_octstring<true>& ue_context_mod_request_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ue_context_mod_request_ies_o::value_c::rg_level_wireline_access_characteristics()
{
  assert_choice_type(types::rg_level_wireline_access_characteristics, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
time_sync_assist_info_s& ue_context_mod_request_ies_o::value_c::time_sync_assist_info()
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
q_mcc_onfig_info_s& ue_context_mod_request_ies_o::value_c::q_mcc_onfig_info()
{
  assert_choice_type(types::q_mcc_onfig_info, type_, "Value");
  return c.get<q_mcc_onfig_info_s>();
}
qmc_deactivation_s& ue_context_mod_request_ies_o::value_c::qmc_deactivation()
{
  assert_choice_type(types::qmc_deactivation, type_, "Value");
  return c.get<qmc_deactivation_s>();
}
ue_slice_max_bit_rate_list_l& ue_context_mod_request_ies_o::value_c::ue_slice_max_bit_rate_list()
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
mdt_plmn_mod_list_l& ue_context_mod_request_ies_o::value_c::management_based_mdt_plmn_mod_list()
{
  assert_choice_type(types::management_based_mdt_plmn_mod_list, type_, "Value");
  return c.get<mdt_plmn_mod_list_l>();
}
five_g_pro_se_authorized_s& ue_context_mod_request_ies_o::value_c::five_g_pro_se_authorized()
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& ue_context_mod_request_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate()
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
five_g_pro_se_pc5_qos_params_s& ue_context_mod_request_ies_o::value_c::five_g_pro_se_pc5_qos_params()
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
const uint64_t& ue_context_mod_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_mod_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint16_t& ue_context_mod_request_ies_o::value_c::ran_paging_prio() const
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
const fixed_bitstring<256, false, true>& ue_context_mod_request_ies_o::value_c::security_key() const
{
  assert_choice_type(types::security_key, type_, "Value");
  return c.get<fixed_bitstring<256, false, true>>();
}
const uint16_t& ue_context_mod_request_ies_o::value_c::idx_to_rfsp() const
{
  assert_choice_type(types::idx_to_rfsp, type_, "Value");
  return c.get<uint16_t>();
}
const ue_aggr_max_bit_rate_s& ue_context_mod_request_ies_o::value_c::ue_aggr_max_bit_rate() const
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
const ue_security_cap_s& ue_context_mod_request_ies_o::value_c::ue_security_cap() const
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
const core_network_assist_info_for_inactive_s&
ue_context_mod_request_ies_o::value_c::core_network_assist_info_for_inactive() const
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
const emergency_fallback_ind_s& ue_context_mod_request_ies_o::value_c::emergency_fallback_ind() const
{
  assert_choice_type(types::emergency_fallback_ind, type_, "Value");
  return c.get<emergency_fallback_ind_s>();
}
const uint64_t& ue_context_mod_request_ies_o::value_c::new_amf_ue_ngap_id() const
{
  assert_choice_type(types::new_amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const rrc_inactive_transition_report_request_e&
ue_context_mod_request_ies_o::value_c::rrc_inactive_transition_report_request() const
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
const guami_s& ue_context_mod_request_ies_o::value_c::new_guami() const
{
  assert_choice_type(types::new_guami, type_, "Value");
  return c.get<guami_s>();
}
const cn_assisted_ran_tuning_s& ue_context_mod_request_ies_o::value_c::cn_assisted_ran_tuning() const
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
const srvcc_operation_possible_e& ue_context_mod_request_ies_o::value_c::srvcc_operation_possible() const
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
const iab_authorized_e& ue_context_mod_request_ies_o::value_c::iab_authorized() const
{
  assert_choice_type(types::iab_authorized, type_, "Value");
  return c.get<iab_authorized_e>();
}
const nr_v2x_services_authorized_s& ue_context_mod_request_ies_o::value_c::nr_v2x_services_authorized() const
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
const ltev2x_services_authorized_s& ue_context_mod_request_ies_o::value_c::ltev2x_services_authorized() const
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s& ue_context_mod_request_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const lte_ue_sidelink_aggr_max_bitrate_s&
ue_context_mod_request_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
const pc5_qos_params_s& ue_context_mod_request_ies_o::value_c::pc5_qos_params() const
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
const unbounded_octstring<true>& ue_context_mod_request_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ue_context_mod_request_ies_o::value_c::rg_level_wireline_access_characteristics() const
{
  assert_choice_type(types::rg_level_wireline_access_characteristics, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const time_sync_assist_info_s& ue_context_mod_request_ies_o::value_c::time_sync_assist_info() const
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
const q_mcc_onfig_info_s& ue_context_mod_request_ies_o::value_c::q_mcc_onfig_info() const
{
  assert_choice_type(types::q_mcc_onfig_info, type_, "Value");
  return c.get<q_mcc_onfig_info_s>();
}
const qmc_deactivation_s& ue_context_mod_request_ies_o::value_c::qmc_deactivation() const
{
  assert_choice_type(types::qmc_deactivation, type_, "Value");
  return c.get<qmc_deactivation_s>();
}
const ue_slice_max_bit_rate_list_l& ue_context_mod_request_ies_o::value_c::ue_slice_max_bit_rate_list() const
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
const mdt_plmn_mod_list_l& ue_context_mod_request_ies_o::value_c::management_based_mdt_plmn_mod_list() const
{
  assert_choice_type(types::management_based_mdt_plmn_mod_list, type_, "Value");
  return c.get<mdt_plmn_mod_list_l>();
}
const five_g_pro_se_authorized_s& ue_context_mod_request_ies_o::value_c::five_g_pro_se_authorized() const
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s&
ue_context_mod_request_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate() const
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const five_g_pro_se_pc5_qos_params_s& ue_context_mod_request_ies_o::value_c::five_g_pro_se_pc5_qos_params() const
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
void ue_context_mod_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      j.write_int("INTEGER (1..256)", c.get<uint16_t>());
      break;
    case types::security_key:
      j.write_str("BIT STRING", c.get<fixed_bitstring<256, false, true>>().to_string());
      break;
    case types::idx_to_rfsp:
      j.write_int("INTEGER (1..256,...)", c.get<uint16_t>());
      break;
    case types::ue_aggr_max_bit_rate:
      j.write_fieldname("UEAggregateMaximumBitRate");
      c.get<ue_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::ue_security_cap:
      j.write_fieldname("UESecurityCapabilities");
      c.get<ue_security_cap_s>().to_json(j);
      break;
    case types::core_network_assist_info_for_inactive:
      j.write_fieldname("CoreNetworkAssistanceInformationForInactive");
      c.get<core_network_assist_info_for_inactive_s>().to_json(j);
      break;
    case types::emergency_fallback_ind:
      j.write_fieldname("EmergencyFallbackIndicator");
      c.get<emergency_fallback_ind_s>().to_json(j);
      break;
    case types::new_amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::rrc_inactive_transition_report_request:
      j.write_str("RRCInactiveTransitionReportRequest", c.get<rrc_inactive_transition_report_request_e>().to_string());
      break;
    case types::new_guami:
      j.write_fieldname("GUAMI");
      c.get<guami_s>().to_json(j);
      break;
    case types::cn_assisted_ran_tuning:
      j.write_fieldname("CNAssistedRANTuning");
      c.get<cn_assisted_ran_tuning_s>().to_json(j);
      break;
    case types::srvcc_operation_possible:
      j.write_str("SRVCCOperationPossible", c.get<srvcc_operation_possible_e>().to_string());
      break;
    case types::iab_authorized:
      j.write_str("IAB-Authorized", c.get<iab_authorized_e>().to_string());
      break;
    case types::nr_v2x_services_authorized:
      j.write_fieldname("NRV2XServicesAuthorized");
      c.get<nr_v2x_services_authorized_s>().to_json(j);
      break;
    case types::ltev2x_services_authorized:
      j.write_fieldname("LTEV2XServicesAuthorized");
      c.get<ltev2x_services_authorized_s>().to_json(j);
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("LTEUESidelinkAggregateMaximumBitrate");
      c.get<lte_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::pc5_qos_params:
      j.write_fieldname("PC5QoSParameters");
      c.get<pc5_qos_params_s>().to_json(j);
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::rg_level_wireline_access_characteristics:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::time_sync_assist_info:
      j.write_fieldname("TimeSyncAssistanceInfo");
      c.get<time_sync_assist_info_s>().to_json(j);
      break;
    case types::q_mcc_onfig_info:
      j.write_fieldname("QMCConfigInfo");
      c.get<q_mcc_onfig_info_s>().to_json(j);
      break;
    case types::qmc_deactivation:
      j.write_fieldname("QMCDeactivation");
      c.get<qmc_deactivation_s>().to_json(j);
      break;
    case types::ue_slice_max_bit_rate_list:
      j.start_array("UESliceMaximumBitRateList");
      for (const auto& e1 : c.get<ue_slice_max_bit_rate_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::management_based_mdt_plmn_mod_list:
      j.start_array("MDTPLMNModificationList");
      for (const auto& e1 : c.get<mdt_plmn_mod_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    case types::five_g_pro_se_authorized:
      j.write_fieldname("FiveG-ProSeAuthorized");
      c.get<five_g_pro_se_authorized_s>().to_json(j);
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::five_g_pro_se_pc5_qos_params:
      j.write_fieldname("FiveG-ProSePC5QoSParameters");
      c.get<five_g_pro_se_pc5_qos_params_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_mod_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::security_key:
      HANDLE_CODE((c.get<fixed_bitstring<256, false, true>>().pack(bref)));
      break;
    case types::idx_to_rfsp:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().pack(bref));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().pack(bref));
      break;
    case types::emergency_fallback_ind:
      HANDLE_CODE(c.get<emergency_fallback_ind_s>().pack(bref));
      break;
    case types::new_amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().pack(bref));
      break;
    case types::new_guami:
      HANDLE_CODE(c.get<guami_s>().pack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().pack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().pack(bref));
      break;
    case types::iab_authorized:
      HANDLE_CODE(c.get<iab_authorized_e>().pack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().pack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().pack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().pack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::rg_level_wireline_access_characteristics:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().pack(bref));
      break;
    case types::q_mcc_onfig_info:
      HANDLE_CODE(c.get<q_mcc_onfig_info_s>().pack(bref));
      break;
    case types::qmc_deactivation:
      HANDLE_CODE(c.get<qmc_deactivation_s>().pack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_slice_max_bit_rate_list_l>(), 1, 8, true));
      break;
    case types::management_based_mdt_plmn_mod_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mdt_plmn_mod_list_l>(), 0, 16, true));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().pack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::security_key:
      HANDLE_CODE((c.get<fixed_bitstring<256, false, true>>().unpack(bref)));
      break;
    case types::idx_to_rfsp:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().unpack(bref));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().unpack(bref));
      break;
    case types::emergency_fallback_ind:
      HANDLE_CODE(c.get<emergency_fallback_ind_s>().unpack(bref));
      break;
    case types::new_amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().unpack(bref));
      break;
    case types::new_guami:
      HANDLE_CODE(c.get<guami_s>().unpack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().unpack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().unpack(bref));
      break;
    case types::iab_authorized:
      HANDLE_CODE(c.get<iab_authorized_e>().unpack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().unpack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().unpack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().unpack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::rg_level_wireline_access_characteristics:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().unpack(bref));
      break;
    case types::q_mcc_onfig_info:
      HANDLE_CODE(c.get<q_mcc_onfig_info_s>().unpack(bref));
      break;
    case types::qmc_deactivation:
      HANDLE_CODE(c.get<qmc_deactivation_s>().unpack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_slice_max_bit_rate_list_l>(), bref, 1, 8, true));
      break;
    case types::management_based_mdt_plmn_mod_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mdt_plmn_mod_list_l>(), bref, 0, 16, true));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().unpack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEContextModificationResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_mod_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 92, 121, 19};
  return map_enum_number(names, 5, idx, "id");
}
bool ue_context_mod_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 92, 121, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_mod_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 92:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_mod_resp_ies_o::value_c ue_context_mod_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 92:
      ret.set(value_c::types::rrc_state);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_mod_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 92:
      return presence_e::optional;
    case 121:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_mod_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_context_mod_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::rrc_state:
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
  }
}
ue_context_mod_resp_ies_o::value_c::value_c(const ue_context_mod_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::rrc_state:
      c.init(other.c.get<rrc_state_e>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
  }
}
ue_context_mod_resp_ies_o::value_c&
ue_context_mod_resp_ies_o::value_c::operator=(const ue_context_mod_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::rrc_state:
      c.set(other.c.get<rrc_state_e>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_mod_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_mod_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
rrc_state_e& ue_context_mod_resp_ies_o::value_c::rrc_state()
{
  assert_choice_type(types::rrc_state, type_, "Value");
  return c.get<rrc_state_e>();
}
user_location_info_c& ue_context_mod_resp_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
crit_diagnostics_s& ue_context_mod_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_mod_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_mod_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const rrc_state_e& ue_context_mod_resp_ies_o::value_c::rrc_state() const
{
  assert_choice_type(types::rrc_state, type_, "Value");
  return c.get<rrc_state_e>();
}
const user_location_info_c& ue_context_mod_resp_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const crit_diagnostics_s& ue_context_mod_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_mod_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::rrc_state:
      j.write_str("RRCState", c.get<rrc_state_e>().to_string());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_mod_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::rrc_state:
      HANDLE_CODE(c.get<rrc_state_e>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::rrc_state:
      HANDLE_CODE(c.get<rrc_state_e>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEContextReleaseCommand-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_release_cmd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {114, 15};
  return map_enum_number(names, 2, idx, "id");
}
bool ue_context_release_cmd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {114, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_release_cmd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 114:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_release_cmd_ies_o::value_c ue_context_release_cmd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 114:
      ret.set(value_c::types::ue_ngap_ids);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_release_cmd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 114:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_release_cmd_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_ngap_ids:
      c.destroy<ue_ngap_ids_c>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void ue_context_release_cmd_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ue_ngap_ids:
      c.init<ue_ngap_ids_c>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
  }
}
ue_context_release_cmd_ies_o::value_c::value_c(const ue_context_release_cmd_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ue_ngap_ids:
      c.init(other.c.get<ue_ngap_ids_c>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
  }
}
ue_context_release_cmd_ies_o::value_c&
ue_context_release_cmd_ies_o::value_c::operator=(const ue_context_release_cmd_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ue_ngap_ids:
      c.set(other.c.get<ue_ngap_ids_c>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
  }

  return *this;
}
ue_ngap_ids_c& ue_context_release_cmd_ies_o::value_c::ue_ngap_ids()
{
  assert_choice_type(types::ue_ngap_ids, type_, "Value");
  return c.get<ue_ngap_ids_c>();
}
cause_c& ue_context_release_cmd_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const ue_ngap_ids_c& ue_context_release_cmd_ies_o::value_c::ue_ngap_ids() const
{
  assert_choice_type(types::ue_ngap_ids, type_, "Value");
  return c.get<ue_ngap_ids_c>();
}
const cause_c& ue_context_release_cmd_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void ue_context_release_cmd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ue_ngap_ids:
      j.write_fieldname("UE-NGAP-IDs");
      c.get<ue_ngap_ids_c>().to_json(j);
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_release_cmd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_ngap_ids:
      HANDLE_CODE(c.get<ue_ngap_ids_c>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_cmd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_ngap_ids:
      HANDLE_CODE(c.get<ue_ngap_ids_c>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEContextReleaseComplete-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_release_complete_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 121, 32, 60, 19, 207};
  return map_enum_number(names, 7, idx, "id");
}
bool ue_context_release_complete_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 121, 32, 60, 19, 207};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_release_complete_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    case 32:
      return crit_e::ignore;
    case 60:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    case 207:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_release_complete_ies_o::value_c ue_context_release_complete_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 32:
      ret.set(value_c::types::info_on_recommended_cells_and_ran_nodes_for_paging);
      break;
    case 60:
      ret.set(value_c::types::pdu_session_res_list_cxt_rel_cpl);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 207:
      ret.set(value_c::types::paging_assis_datafor_c_ecapab_ue);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_release_complete_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 121:
      return presence_e::optional;
    case 32:
      return presence_e::optional;
    case 60:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    case 207:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_release_complete_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.destroy<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      c.destroy<pdu_session_res_list_cxt_rel_cpl_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.destroy<paging_assis_datafor_c_ecapab_ue_s>();
      break;
    default:
      break;
  }
}
void ue_context_release_complete_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.init<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      c.init<pdu_session_res_list_cxt_rel_cpl_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.init<paging_assis_datafor_c_ecapab_ue_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
  }
}
ue_context_release_complete_ies_o::value_c::value_c(const ue_context_release_complete_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.init(other.c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>());
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      c.init(other.c.get<pdu_session_res_list_cxt_rel_cpl_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.init(other.c.get<paging_assis_datafor_c_ecapab_ue_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
  }
}
ue_context_release_complete_ies_o::value_c&
ue_context_release_complete_ies_o::value_c::operator=(const ue_context_release_complete_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.set(other.c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>());
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      c.set(other.c.get<pdu_session_res_list_cxt_rel_cpl_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.set(other.c.get<paging_assis_datafor_c_ecapab_ue_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_release_complete_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_release_complete_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
user_location_info_c& ue_context_release_complete_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
info_on_recommended_cells_and_ran_nodes_for_paging_s&
ue_context_release_complete_ies_o::value_c::info_on_recommended_cells_and_ran_nodes_for_paging()
{
  assert_choice_type(types::info_on_recommended_cells_and_ran_nodes_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
}
pdu_session_res_list_cxt_rel_cpl_l& ue_context_release_complete_ies_o::value_c::pdu_session_res_list_cxt_rel_cpl()
{
  assert_choice_type(types::pdu_session_res_list_cxt_rel_cpl, type_, "Value");
  return c.get<pdu_session_res_list_cxt_rel_cpl_l>();
}
crit_diagnostics_s& ue_context_release_complete_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
paging_assis_datafor_c_ecapab_ue_s& ue_context_release_complete_ies_o::value_c::paging_assis_datafor_c_ecapab_ue()
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Value");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
const uint64_t& ue_context_release_complete_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_release_complete_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const user_location_info_c& ue_context_release_complete_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const info_on_recommended_cells_and_ran_nodes_for_paging_s&
ue_context_release_complete_ies_o::value_c::info_on_recommended_cells_and_ran_nodes_for_paging() const
{
  assert_choice_type(types::info_on_recommended_cells_and_ran_nodes_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
}
const pdu_session_res_list_cxt_rel_cpl_l&
ue_context_release_complete_ies_o::value_c::pdu_session_res_list_cxt_rel_cpl() const
{
  assert_choice_type(types::pdu_session_res_list_cxt_rel_cpl, type_, "Value");
  return c.get<pdu_session_res_list_cxt_rel_cpl_l>();
}
const crit_diagnostics_s& ue_context_release_complete_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const paging_assis_datafor_c_ecapab_ue_s&
ue_context_release_complete_ies_o::value_c::paging_assis_datafor_c_ecapab_ue() const
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Value");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
void ue_context_release_complete_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      j.write_fieldname("InfoOnRecommendedCellsAndRANNodesForPaging");
      c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().to_json(j);
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      j.start_array("PDUSessionResourceListCxtRelCpl");
      for (const auto& e1 : c.get<pdu_session_res_list_cxt_rel_cpl_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      j.write_fieldname("PagingAssisDataforCEcapabUE");
      c.get<paging_assis_datafor_c_ecapab_ue_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_release_complete_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().pack(bref));
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_list_cxt_rel_cpl_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_complete_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().unpack(bref));
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_list_cxt_rel_cpl_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEContextReleaseRequest-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_release_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 133, 15};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_context_release_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 133, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_release_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 133:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_release_request_ies_o::value_c ue_context_release_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 133:
      ret.set(value_c::types::pdu_session_res_list_cxt_rel_req);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_release_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 133:
      return presence_e::optional;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_release_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_list_cxt_rel_req:
      c.destroy<pdu_session_res_list_cxt_rel_req_l>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void ue_context_release_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_list_cxt_rel_req:
      c.init<pdu_session_res_list_cxt_rel_req_l>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
  }
}
ue_context_release_request_ies_o::value_c::value_c(const ue_context_release_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_list_cxt_rel_req:
      c.init(other.c.get<pdu_session_res_list_cxt_rel_req_l>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
  }
}
ue_context_release_request_ies_o::value_c&
ue_context_release_request_ies_o::value_c::operator=(const ue_context_release_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_list_cxt_rel_req:
      c.set(other.c.get<pdu_session_res_list_cxt_rel_req_l>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_release_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_release_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_list_cxt_rel_req_l& ue_context_release_request_ies_o::value_c::pdu_session_res_list_cxt_rel_req()
{
  assert_choice_type(types::pdu_session_res_list_cxt_rel_req, type_, "Value");
  return c.get<pdu_session_res_list_cxt_rel_req_l>();
}
cause_c& ue_context_release_request_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const uint64_t& ue_context_release_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_release_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_list_cxt_rel_req_l&
ue_context_release_request_ies_o::value_c::pdu_session_res_list_cxt_rel_req() const
{
  assert_choice_type(types::pdu_session_res_list_cxt_rel_req, type_, "Value");
  return c.get<pdu_session_res_list_cxt_rel_req_l>();
}
const cause_c& ue_context_release_request_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void ue_context_release_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_list_cxt_rel_req:
      j.start_array("PDUSessionResourceListCxtRelReq");
      for (const auto& e1 : c.get<pdu_session_res_list_cxt_rel_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_release_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_list_cxt_rel_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_list_cxt_rel_req_l>(), 1, 256, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_list_cxt_rel_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_list_cxt_rel_req_l>(), bref, 1, 256, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEContextResumeFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_resume_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_context_resume_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_resume_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_resume_fail_ies_o::value_c ue_context_resume_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_resume_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_resume_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_context_resume_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
  }
}
ue_context_resume_fail_ies_o::value_c::value_c(const ue_context_resume_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
  }
}
ue_context_resume_fail_ies_o::value_c&
ue_context_resume_fail_ies_o::value_c::operator=(const ue_context_resume_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_resume_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_resume_fail_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ue_context_resume_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& ue_context_resume_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_resume_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_resume_fail_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ue_context_resume_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& ue_context_resume_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_resume_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_resume_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEContextResumeRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_resume_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 237, 232, 229, 235, 32, 207};
  return map_enum_number(names, 8, idx, "id");
}
bool ue_context_resume_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 237, 232, 229, 235, 32, 207};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_resume_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 237:
      return crit_e::ignore;
    case 232:
      return crit_e::reject;
    case 229:
      return crit_e::reject;
    case 235:
      return crit_e::ignore;
    case 32:
      return crit_e::ignore;
    case 207:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_resume_request_ies_o::value_c ue_context_resume_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 237:
      ret.set(value_c::types::rrc_resume_cause);
      break;
    case 232:
      ret.set(value_c::types::pdu_session_res_resume_list_res_req);
      break;
    case 229:
      ret.set(value_c::types::pdu_session_res_failed_to_resume_list_res_req);
      break;
    case 235:
      ret.set(value_c::types::suspend_request_ind);
      break;
    case 32:
      ret.set(value_c::types::info_on_recommended_cells_and_ran_nodes_for_paging);
      break;
    case 207:
      ret.set(value_c::types::paging_assis_datafor_c_ecapab_ue);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_resume_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 237:
      return presence_e::mandatory;
    case 232:
      return presence_e::optional;
    case 229:
      return presence_e::optional;
    case 235:
      return presence_e::optional;
    case 32:
      return presence_e::optional;
    case 207:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_resume_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_resume_list_res_req:
      c.destroy<pdu_session_res_resume_list_res_req_l>();
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      c.destroy<pdu_session_res_failed_to_resume_list_res_req_l>();
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.destroy<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.destroy<paging_assis_datafor_c_ecapab_ue_s>();
      break;
    default:
      break;
  }
}
void ue_context_resume_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::rrc_resume_cause:
      break;
    case types::pdu_session_res_resume_list_res_req:
      c.init<pdu_session_res_resume_list_res_req_l>();
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      c.init<pdu_session_res_failed_to_resume_list_res_req_l>();
      break;
    case types::suspend_request_ind:
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.init<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.init<paging_assis_datafor_c_ecapab_ue_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
  }
}
ue_context_resume_request_ies_o::value_c::value_c(const ue_context_resume_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::rrc_resume_cause:
      c.init(other.c.get<rrc_establishment_cause_e>());
      break;
    case types::pdu_session_res_resume_list_res_req:
      c.init(other.c.get<pdu_session_res_resume_list_res_req_l>());
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      c.init(other.c.get<pdu_session_res_failed_to_resume_list_res_req_l>());
      break;
    case types::suspend_request_ind:
      c.init(other.c.get<suspend_request_ind_e>());
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.init(other.c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>());
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.init(other.c.get<paging_assis_datafor_c_ecapab_ue_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
  }
}
ue_context_resume_request_ies_o::value_c&
ue_context_resume_request_ies_o::value_c::operator=(const ue_context_resume_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::rrc_resume_cause:
      c.set(other.c.get<rrc_establishment_cause_e>());
      break;
    case types::pdu_session_res_resume_list_res_req:
      c.set(other.c.get<pdu_session_res_resume_list_res_req_l>());
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      c.set(other.c.get<pdu_session_res_failed_to_resume_list_res_req_l>());
      break;
    case types::suspend_request_ind:
      c.set(other.c.get<suspend_request_ind_e>());
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.set(other.c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>());
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.set(other.c.get<paging_assis_datafor_c_ecapab_ue_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_resume_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_resume_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
rrc_establishment_cause_e& ue_context_resume_request_ies_o::value_c::rrc_resume_cause()
{
  assert_choice_type(types::rrc_resume_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
pdu_session_res_resume_list_res_req_l& ue_context_resume_request_ies_o::value_c::pdu_session_res_resume_list_res_req()
{
  assert_choice_type(types::pdu_session_res_resume_list_res_req, type_, "Value");
  return c.get<pdu_session_res_resume_list_res_req_l>();
}
pdu_session_res_failed_to_resume_list_res_req_l&
ue_context_resume_request_ies_o::value_c::pdu_session_res_failed_to_resume_list_res_req()
{
  assert_choice_type(types::pdu_session_res_failed_to_resume_list_res_req, type_, "Value");
  return c.get<pdu_session_res_failed_to_resume_list_res_req_l>();
}
suspend_request_ind_e& ue_context_resume_request_ies_o::value_c::suspend_request_ind()
{
  assert_choice_type(types::suspend_request_ind, type_, "Value");
  return c.get<suspend_request_ind_e>();
}
info_on_recommended_cells_and_ran_nodes_for_paging_s&
ue_context_resume_request_ies_o::value_c::info_on_recommended_cells_and_ran_nodes_for_paging()
{
  assert_choice_type(types::info_on_recommended_cells_and_ran_nodes_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
}
paging_assis_datafor_c_ecapab_ue_s& ue_context_resume_request_ies_o::value_c::paging_assis_datafor_c_ecapab_ue()
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Value");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
const uint64_t& ue_context_resume_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_resume_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const rrc_establishment_cause_e& ue_context_resume_request_ies_o::value_c::rrc_resume_cause() const
{
  assert_choice_type(types::rrc_resume_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
const pdu_session_res_resume_list_res_req_l&
ue_context_resume_request_ies_o::value_c::pdu_session_res_resume_list_res_req() const
{
  assert_choice_type(types::pdu_session_res_resume_list_res_req, type_, "Value");
  return c.get<pdu_session_res_resume_list_res_req_l>();
}
const pdu_session_res_failed_to_resume_list_res_req_l&
ue_context_resume_request_ies_o::value_c::pdu_session_res_failed_to_resume_list_res_req() const
{
  assert_choice_type(types::pdu_session_res_failed_to_resume_list_res_req, type_, "Value");
  return c.get<pdu_session_res_failed_to_resume_list_res_req_l>();
}
const suspend_request_ind_e& ue_context_resume_request_ies_o::value_c::suspend_request_ind() const
{
  assert_choice_type(types::suspend_request_ind, type_, "Value");
  return c.get<suspend_request_ind_e>();
}
const info_on_recommended_cells_and_ran_nodes_for_paging_s&
ue_context_resume_request_ies_o::value_c::info_on_recommended_cells_and_ran_nodes_for_paging() const
{
  assert_choice_type(types::info_on_recommended_cells_and_ran_nodes_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
}
const paging_assis_datafor_c_ecapab_ue_s&
ue_context_resume_request_ies_o::value_c::paging_assis_datafor_c_ecapab_ue() const
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Value");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
void ue_context_resume_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::rrc_resume_cause:
      j.write_str("RRCEstablishmentCause", c.get<rrc_establishment_cause_e>().to_string());
      break;
    case types::pdu_session_res_resume_list_res_req:
      j.start_array("PDUSessionResourceResumeListRESReq");
      for (const auto& e1 : c.get<pdu_session_res_resume_list_res_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      j.start_array("PDUSessionResourceFailedToResumeListRESReq");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_resume_list_res_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::suspend_request_ind:
      j.write_str("Suspend-Request-Indication", "suspend-requested");
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      j.write_fieldname("InfoOnRecommendedCellsAndRANNodesForPaging");
      c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().to_json(j);
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      j.write_fieldname("PagingAssisDataforCEcapabUE");
      c.get<paging_assis_datafor_c_ecapab_ue_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_resume_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::rrc_resume_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().pack(bref));
      break;
    case types::pdu_session_res_resume_list_res_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_resume_list_res_req_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_resume_list_res_req_l>(), 1, 256, true));
      break;
    case types::suspend_request_ind:
      HANDLE_CODE(c.get<suspend_request_ind_e>().pack(bref));
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().pack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::rrc_resume_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().unpack(bref));
      break;
    case types::pdu_session_res_resume_list_res_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_resume_list_res_req_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_resume_list_res_req_l>(), bref, 1, 256, true));
      break;
    case types::suspend_request_ind:
      HANDLE_CODE(c.get<suspend_request_ind_e>().unpack(bref));
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().unpack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEContextResumeResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_resume_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 233, 230, 93, 236, 206, 19};
  return map_enum_number(names, 8, idx, "id");
}
bool ue_context_resume_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 233, 230, 93, 236, 206, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_resume_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 233:
      return crit_e::reject;
    case 230:
      return crit_e::reject;
    case 93:
      return crit_e::reject;
    case 236:
      return crit_e::ignore;
    case 206:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_resume_resp_ies_o::value_c ue_context_resume_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 233:
      ret.set(value_c::types::pdu_session_res_resume_list_res_res);
      break;
    case 230:
      ret.set(value_c::types::pdu_session_res_failed_to_resume_list_res_res);
      break;
    case 93:
      ret.set(value_c::types::security_context);
      break;
    case 236:
      ret.set(value_c::types::suspend_resp_ind);
      break;
    case 206:
      ret.set(value_c::types::extended_connected_time);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_resume_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 233:
      return presence_e::optional;
    case 230:
      return presence_e::optional;
    case 93:
      return presence_e::optional;
    case 236:
      return presence_e::optional;
    case 206:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_resume_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_resume_list_res_res:
      c.destroy<pdu_session_res_resume_list_res_res_l>();
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      c.destroy<pdu_session_res_failed_to_resume_list_res_res_l>();
      break;
    case types::security_context:
      c.destroy<security_context_s>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_context_resume_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_resume_list_res_res:
      c.init<pdu_session_res_resume_list_res_res_l>();
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      c.init<pdu_session_res_failed_to_resume_list_res_res_l>();
      break;
    case types::security_context:
      c.init<security_context_s>();
      break;
    case types::suspend_resp_ind:
      break;
    case types::extended_connected_time:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
  }
}
ue_context_resume_resp_ies_o::value_c::value_c(const ue_context_resume_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_resume_list_res_res:
      c.init(other.c.get<pdu_session_res_resume_list_res_res_l>());
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      c.init(other.c.get<pdu_session_res_failed_to_resume_list_res_res_l>());
      break;
    case types::security_context:
      c.init(other.c.get<security_context_s>());
      break;
    case types::suspend_resp_ind:
      c.init(other.c.get<suspend_resp_ind_e>());
      break;
    case types::extended_connected_time:
      c.init(other.c.get<uint16_t>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
  }
}
ue_context_resume_resp_ies_o::value_c&
ue_context_resume_resp_ies_o::value_c::operator=(const ue_context_resume_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_resume_list_res_res:
      c.set(other.c.get<pdu_session_res_resume_list_res_res_l>());
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      c.set(other.c.get<pdu_session_res_failed_to_resume_list_res_res_l>());
      break;
    case types::security_context:
      c.set(other.c.get<security_context_s>());
      break;
    case types::suspend_resp_ind:
      c.set(other.c.get<suspend_resp_ind_e>());
      break;
    case types::extended_connected_time:
      c.set(other.c.get<uint16_t>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_resume_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_resume_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_resume_list_res_res_l& ue_context_resume_resp_ies_o::value_c::pdu_session_res_resume_list_res_res()
{
  assert_choice_type(types::pdu_session_res_resume_list_res_res, type_, "Value");
  return c.get<pdu_session_res_resume_list_res_res_l>();
}
pdu_session_res_failed_to_resume_list_res_res_l&
ue_context_resume_resp_ies_o::value_c::pdu_session_res_failed_to_resume_list_res_res()
{
  assert_choice_type(types::pdu_session_res_failed_to_resume_list_res_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_resume_list_res_res_l>();
}
security_context_s& ue_context_resume_resp_ies_o::value_c::security_context()
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
suspend_resp_ind_e& ue_context_resume_resp_ies_o::value_c::suspend_resp_ind()
{
  assert_choice_type(types::suspend_resp_ind, type_, "Value");
  return c.get<suspend_resp_ind_e>();
}
uint16_t& ue_context_resume_resp_ies_o::value_c::extended_connected_time()
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
crit_diagnostics_s& ue_context_resume_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_resume_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_resume_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_resume_list_res_res_l&
ue_context_resume_resp_ies_o::value_c::pdu_session_res_resume_list_res_res() const
{
  assert_choice_type(types::pdu_session_res_resume_list_res_res, type_, "Value");
  return c.get<pdu_session_res_resume_list_res_res_l>();
}
const pdu_session_res_failed_to_resume_list_res_res_l&
ue_context_resume_resp_ies_o::value_c::pdu_session_res_failed_to_resume_list_res_res() const
{
  assert_choice_type(types::pdu_session_res_failed_to_resume_list_res_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_resume_list_res_res_l>();
}
const security_context_s& ue_context_resume_resp_ies_o::value_c::security_context() const
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
const suspend_resp_ind_e& ue_context_resume_resp_ies_o::value_c::suspend_resp_ind() const
{
  assert_choice_type(types::suspend_resp_ind, type_, "Value");
  return c.get<suspend_resp_ind_e>();
}
const uint16_t& ue_context_resume_resp_ies_o::value_c::extended_connected_time() const
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
const crit_diagnostics_s& ue_context_resume_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_resume_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_resume_list_res_res:
      j.start_array("PDUSessionResourceResumeListRESRes");
      for (const auto& e1 : c.get<pdu_session_res_resume_list_res_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      j.start_array("PDUSessionResourceFailedToResumeListRESRes");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_resume_list_res_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::security_context:
      j.write_fieldname("SecurityContext");
      c.get<security_context_s>().to_json(j);
      break;
    case types::suspend_resp_ind:
      j.write_str("Suspend-Response-Indication", "suspend-indicated");
      break;
    case types::extended_connected_time:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_resume_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_resume_list_res_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_resume_list_res_res_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_resume_list_res_res_l>(), 1, 256, true));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().pack(bref));
      break;
    case types::suspend_resp_ind:
      HANDLE_CODE(c.get<suspend_resp_ind_e>().pack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_resume_list_res_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_resume_list_res_res_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_resume_list_res_res_l>(), bref, 1, 256, true));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().unpack(bref));
      break;
    case types::suspend_resp_ind:
      HANDLE_CODE(c.get<suspend_resp_ind_e>().unpack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEContextSuspendFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_suspend_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_context_suspend_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_suspend_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_suspend_fail_ies_o::value_c ue_context_suspend_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_suspend_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_suspend_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_context_suspend_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_fail_ies_o::value_c");
  }
}
ue_context_suspend_fail_ies_o::value_c::value_c(const ue_context_suspend_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_fail_ies_o::value_c");
  }
}
ue_context_suspend_fail_ies_o::value_c&
ue_context_suspend_fail_ies_o::value_c::operator=(const ue_context_suspend_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_suspend_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_suspend_fail_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ue_context_suspend_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& ue_context_suspend_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_suspend_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_suspend_fail_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ue_context_suspend_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& ue_context_suspend_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_suspend_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_suspend_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEContextSuspendRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_suspend_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 32, 207, 231};
  return map_enum_number(names, 5, idx, "id");
}
bool ue_context_suspend_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 32, 207, 231};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_suspend_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 32:
      return crit_e::ignore;
    case 207:
      return crit_e::ignore;
    case 231:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_suspend_request_ies_o::value_c ue_context_suspend_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 32:
      ret.set(value_c::types::info_on_recommended_cells_and_ran_nodes_for_paging);
      break;
    case 207:
      ret.set(value_c::types::paging_assis_datafor_c_ecapab_ue);
      break;
    case 231:
      ret.set(value_c::types::pdu_session_res_suspend_list_sus_req);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_suspend_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 32:
      return presence_e::optional;
    case 207:
      return presence_e::optional;
    case 231:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_suspend_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.destroy<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.destroy<paging_assis_datafor_c_ecapab_ue_s>();
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      c.destroy<pdu_session_res_suspend_list_sus_req_l>();
      break;
    default:
      break;
  }
}
void ue_context_suspend_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.init<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.init<paging_assis_datafor_c_ecapab_ue_s>();
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      c.init<pdu_session_res_suspend_list_sus_req_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
  }
}
ue_context_suspend_request_ies_o::value_c::value_c(const ue_context_suspend_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.init(other.c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>());
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.init(other.c.get<paging_assis_datafor_c_ecapab_ue_s>());
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      c.init(other.c.get<pdu_session_res_suspend_list_sus_req_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
  }
}
ue_context_suspend_request_ies_o::value_c&
ue_context_suspend_request_ies_o::value_c::operator=(const ue_context_suspend_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.set(other.c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>());
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.set(other.c.get<paging_assis_datafor_c_ecapab_ue_s>());
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      c.set(other.c.get<pdu_session_res_suspend_list_sus_req_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_suspend_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_suspend_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
info_on_recommended_cells_and_ran_nodes_for_paging_s&
ue_context_suspend_request_ies_o::value_c::info_on_recommended_cells_and_ran_nodes_for_paging()
{
  assert_choice_type(types::info_on_recommended_cells_and_ran_nodes_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
}
paging_assis_datafor_c_ecapab_ue_s& ue_context_suspend_request_ies_o::value_c::paging_assis_datafor_c_ecapab_ue()
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Value");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
pdu_session_res_suspend_list_sus_req_l&
ue_context_suspend_request_ies_o::value_c::pdu_session_res_suspend_list_sus_req()
{
  assert_choice_type(types::pdu_session_res_suspend_list_sus_req, type_, "Value");
  return c.get<pdu_session_res_suspend_list_sus_req_l>();
}
const uint64_t& ue_context_suspend_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_suspend_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const info_on_recommended_cells_and_ran_nodes_for_paging_s&
ue_context_suspend_request_ies_o::value_c::info_on_recommended_cells_and_ran_nodes_for_paging() const
{
  assert_choice_type(types::info_on_recommended_cells_and_ran_nodes_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
}
const paging_assis_datafor_c_ecapab_ue_s&
ue_context_suspend_request_ies_o::value_c::paging_assis_datafor_c_ecapab_ue() const
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Value");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
const pdu_session_res_suspend_list_sus_req_l&
ue_context_suspend_request_ies_o::value_c::pdu_session_res_suspend_list_sus_req() const
{
  assert_choice_type(types::pdu_session_res_suspend_list_sus_req, type_, "Value");
  return c.get<pdu_session_res_suspend_list_sus_req_l>();
}
void ue_context_suspend_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      j.write_fieldname("InfoOnRecommendedCellsAndRANNodesForPaging");
      c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().to_json(j);
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      j.write_fieldname("PagingAssisDataforCEcapabUE");
      c.get<paging_assis_datafor_c_ecapab_ue_s>().to_json(j);
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      j.start_array("PDUSessionResourceSuspendListSUSReq");
      for (const auto& e1 : c.get<pdu_session_res_suspend_list_sus_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_suspend_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().pack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().pack(bref));
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_suspend_list_sus_req_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().unpack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().unpack(bref));
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_suspend_list_sus_req_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEContextSuspendResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_suspend_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 93, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_context_suspend_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 93, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_suspend_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 93:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_suspend_resp_ies_o::value_c ue_context_suspend_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 93:
      ret.set(value_c::types::security_context);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_suspend_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 93:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_suspend_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::security_context:
      c.destroy<security_context_s>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_context_suspend_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::security_context:
      c.init<security_context_s>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
  }
}
ue_context_suspend_resp_ies_o::value_c::value_c(const ue_context_suspend_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::security_context:
      c.init(other.c.get<security_context_s>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
  }
}
ue_context_suspend_resp_ies_o::value_c&
ue_context_suspend_resp_ies_o::value_c::operator=(const ue_context_suspend_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::security_context:
      c.set(other.c.get<security_context_s>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_suspend_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_suspend_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
security_context_s& ue_context_suspend_resp_ies_o::value_c::security_context()
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
crit_diagnostics_s& ue_context_suspend_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_suspend_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_suspend_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const security_context_s& ue_context_suspend_resp_ies_o::value_c::security_context() const
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
const crit_diagnostics_s& ue_context_suspend_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_suspend_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::security_context:
      j.write_fieldname("SecurityContext");
      c.get<security_context_s>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_suspend_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEInformationTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_info_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {26, 210, 117, 148, 0, 209, 34};
  return map_enum_number(names, 7, idx, "id");
}
bool ue_info_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {26, 210, 117, 148, 0, 209, 34};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_info_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 26:
      return crit_e::reject;
    case 210:
      return crit_e::ignore;
    case 117:
      return crit_e::ignore;
    case 148:
      return crit_e::ignore;
    case 0:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 34:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_info_transfer_ies_o::value_c ue_info_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 26:
      ret.set(value_c::types::five_g_s_tmsi);
      break;
    case 210:
      ret.set(value_c::types::nb_iot_ue_prio);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 148:
      ret.set(value_c::types::s_nssai);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 209:
      ret.set(value_c::types::ue_diff_info);
      break;
    case 34:
      ret.set(value_c::types::masked_imeisv);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_info_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 26:
      return presence_e::mandatory;
    case 210:
      return presence_e::optional;
    case 117:
      return presence_e::optional;
    case 148:
      return presence_e::optional;
    case 0:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 34:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_info_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::five_g_s_tmsi:
      c.destroy<five_g_s_tmsi_s>();
      break;
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::s_nssai:
      c.destroy<s_nssai_s>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    case types::ue_diff_info:
      c.destroy<ue_diff_info_s>();
      break;
    case types::masked_imeisv:
      c.destroy<fixed_bitstring<64, false, true>>();
      break;
    default:
      break;
  }
}
void ue_info_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::five_g_s_tmsi:
      c.init<five_g_s_tmsi_s>();
      break;
    case types::nb_iot_ue_prio:
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true>>();
      break;
    case types::s_nssai:
      c.init<s_nssai_s>();
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::ue_diff_info:
      c.init<ue_diff_info_s>();
      break;
    case types::masked_imeisv:
      c.init<fixed_bitstring<64, false, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
  }
}
ue_info_transfer_ies_o::value_c::value_c(const ue_info_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::five_g_s_tmsi:
      c.init(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::nb_iot_ue_prio:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::s_nssai:
      c.init(other.c.get<s_nssai_s>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::ue_diff_info:
      c.init(other.c.get<ue_diff_info_s>());
      break;
    case types::masked_imeisv:
      c.init(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
  }
}
ue_info_transfer_ies_o::value_c&
ue_info_transfer_ies_o::value_c::operator=(const ue_info_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::five_g_s_tmsi:
      c.set(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::nb_iot_ue_prio:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::s_nssai:
      c.set(other.c.get<s_nssai_s>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::ue_diff_info:
      c.set(other.c.get<ue_diff_info_s>());
      break;
    case types::masked_imeisv:
      c.set(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
  }

  return *this;
}
five_g_s_tmsi_s& ue_info_transfer_ies_o::value_c::five_g_s_tmsi()
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
uint16_t& ue_info_transfer_ies_o::value_c::nb_iot_ue_prio()
{
  assert_choice_type(types::nb_iot_ue_prio, type_, "Value");
  return c.get<uint16_t>();
}
unbounded_octstring<true>& ue_info_transfer_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
s_nssai_s& ue_info_transfer_ies_o::value_c::s_nssai()
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
allowed_nssai_l& ue_info_transfer_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
ue_diff_info_s& ue_info_transfer_ies_o::value_c::ue_diff_info()
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
fixed_bitstring<64, false, true>& ue_info_transfer_ies_o::value_c::masked_imeisv()
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
const five_g_s_tmsi_s& ue_info_transfer_ies_o::value_c::five_g_s_tmsi() const
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
const uint16_t& ue_info_transfer_ies_o::value_c::nb_iot_ue_prio() const
{
  assert_choice_type(types::nb_iot_ue_prio, type_, "Value");
  return c.get<uint16_t>();
}
const unbounded_octstring<true>& ue_info_transfer_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const s_nssai_s& ue_info_transfer_ies_o::value_c::s_nssai() const
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
const allowed_nssai_l& ue_info_transfer_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const ue_diff_info_s& ue_info_transfer_ies_o::value_c::ue_diff_info() const
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
const fixed_bitstring<64, false, true>& ue_info_transfer_ies_o::value_c::masked_imeisv() const
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
void ue_info_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::five_g_s_tmsi:
      j.write_fieldname("FiveG-S-TMSI");
      c.get<five_g_s_tmsi_s>().to_json(j);
      break;
    case types::nb_iot_ue_prio:
      j.write_int("INTEGER (0..255,...)", c.get<uint16_t>());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::s_nssai:
      j.write_fieldname("S-NSSAI");
      c.get<s_nssai_s>().to_json(j);
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ue_diff_info:
      j.write_fieldname("UE-DifferentiationInfo");
      c.get<ue_diff_info_s>().to_json(j);
      break;
    case types::masked_imeisv:
      j.write_str("BIT STRING", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_info_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().pack(bref));
      break;
    case types::nb_iot_ue_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, true, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().pack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().pack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_info_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().unpack(bref));
      break;
    case types::nb_iot_ue_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, true, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().unpack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().unpack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UERadioCapabilityCheckRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_radio_cap_check_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 117, 264};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_radio_cap_check_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 117, 264};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_radio_cap_check_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 117:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_radio_cap_check_request_ies_o::value_c ue_radio_cap_check_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_radio_cap_check_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 117:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_radio_cap_check_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::ue_radio_cap_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void ue_radio_cap_check_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true>>();
      break;
    case types::ue_radio_cap_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_request_ies_o::value_c");
  }
}
ue_radio_cap_check_request_ies_o::value_c::value_c(const ue_radio_cap_check_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_radio_cap_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_request_ies_o::value_c");
  }
}
ue_radio_cap_check_request_ies_o::value_c&
ue_radio_cap_check_request_ies_o::value_c::operator=(const ue_radio_cap_check_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_radio_cap_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_radio_cap_check_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_radio_cap_check_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& ue_radio_cap_check_request_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ue_radio_cap_check_request_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ue_radio_cap_check_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_radio_cap_check_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& ue_radio_cap_check_request_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ue_radio_cap_check_request_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ue_radio_cap_check_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_radio_cap_check_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_check_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UERadioCapabilityCheckResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_radio_cap_check_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 30, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_radio_cap_check_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 30, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_radio_cap_check_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 30:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_radio_cap_check_resp_ies_o::value_c ue_radio_cap_check_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 30:
      ret.set(value_c::types::ims_voice_support_ind);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_radio_cap_check_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 30:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_radio_cap_check_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_radio_cap_check_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ims_voice_support_ind:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_resp_ies_o::value_c");
  }
}
ue_radio_cap_check_resp_ies_o::value_c::value_c(const ue_radio_cap_check_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ims_voice_support_ind:
      c.init(other.c.get<ims_voice_support_ind_e>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_resp_ies_o::value_c");
  }
}
ue_radio_cap_check_resp_ies_o::value_c&
ue_radio_cap_check_resp_ies_o::value_c::operator=(const ue_radio_cap_check_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ims_voice_support_ind:
      c.set(other.c.get<ims_voice_support_ind_e>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_radio_cap_check_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_radio_cap_check_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
ims_voice_support_ind_e& ue_radio_cap_check_resp_ies_o::value_c::ims_voice_support_ind()
{
  assert_choice_type(types::ims_voice_support_ind, type_, "Value");
  return c.get<ims_voice_support_ind_e>();
}
crit_diagnostics_s& ue_radio_cap_check_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_radio_cap_check_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_radio_cap_check_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const ims_voice_support_ind_e& ue_radio_cap_check_resp_ies_o::value_c::ims_voice_support_ind() const
{
  assert_choice_type(types::ims_voice_support_ind, type_, "Value");
  return c.get<ims_voice_support_ind_e>();
}
const crit_diagnostics_s& ue_radio_cap_check_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_radio_cap_check_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ims_voice_support_ind:
      j.write_str("IMSVoiceSupportIndicator", c.get<ims_voice_support_ind_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_radio_cap_check_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ims_voice_support_ind:
      HANDLE_CODE(c.get<ims_voice_support_ind_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_check_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ims_voice_support_ind:
      HANDLE_CODE(c.get<ims_voice_support_ind_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UERadioCapabilityIDMappingRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_radio_cap_id_map_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {264};
  return map_enum_number(names, 1, idx, "id");
}
bool ue_radio_cap_id_map_request_ies_o::is_id_valid(const uint32_t& id)
{
  return 264 == id;
}
crit_e ue_radio_cap_id_map_request_ies_o::get_crit(const uint32_t& id)
{
  if (id == 264) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
ue_radio_cap_id_map_request_ies_o::value_c ue_radio_cap_id_map_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 264) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_radio_cap_id_map_request_ies_o::get_presence(const uint32_t& id)
{
  if (id == 264) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void ue_radio_cap_id_map_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("OCTET STRING", c.to_string());
  j.end_obj();
}
SRSASN_CODE ue_radio_cap_id_map_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_id_map_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// UERadioCapabilityIDMappingResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_radio_cap_id_map_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {264, 117, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool ue_radio_cap_id_map_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {264, 117, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_radio_cap_id_map_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 264:
      return crit_e::reject;
    case 117:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_radio_cap_id_map_resp_ies_o::value_c ue_radio_cap_id_map_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_radio_cap_id_map_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 264:
      return presence_e::mandatory;
    case 117:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_radio_cap_id_map_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_radio_cap_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_radio_cap_id_map_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ue_radio_cap_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_id_map_resp_ies_o::value_c");
  }
}
ue_radio_cap_id_map_resp_ies_o::value_c::value_c(const ue_radio_cap_id_map_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ue_radio_cap_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_id_map_resp_ies_o::value_c");
  }
}
ue_radio_cap_id_map_resp_ies_o::value_c&
ue_radio_cap_id_map_resp_ies_o::value_c::operator=(const ue_radio_cap_id_map_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ue_radio_cap_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_id_map_resp_ies_o::value_c");
  }

  return *this;
}
unbounded_octstring<true>& ue_radio_cap_id_map_resp_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ue_radio_cap_id_map_resp_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& ue_radio_cap_id_map_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const unbounded_octstring<true>& ue_radio_cap_id_map_resp_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ue_radio_cap_id_map_resp_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& ue_radio_cap_id_map_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_radio_cap_id_map_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_id_map_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_radio_cap_id_map_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_id_map_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_id_map_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_id_map_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UERadioCapabilityInfoIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_radio_cap_info_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 117, 118, 265};
  return map_enum_number(names, 5, idx, "id");
}
bool ue_radio_cap_info_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 117, 118, 265};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_radio_cap_info_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 117:
      return crit_e::ignore;
    case 118:
      return crit_e::ignore;
    case 265:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_radio_cap_info_ind_ies_o::value_c ue_radio_cap_info_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 118:
      ret.set(value_c::types::ue_radio_cap_for_paging);
      break;
    case 265:
      ret.set(value_c::types::ue_radio_cap_eutra_format);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_radio_cap_info_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 117:
      return presence_e::mandatory;
    case 118:
      return presence_e::optional;
    case 265:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_radio_cap_info_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::ue_radio_cap_for_paging:
      c.destroy<ue_radio_cap_for_paging_s>();
      break;
    case types::ue_radio_cap_eutra_format:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void ue_radio_cap_info_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true>>();
      break;
    case types::ue_radio_cap_for_paging:
      c.init<ue_radio_cap_for_paging_s>();
      break;
    case types::ue_radio_cap_eutra_format:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_info_ind_ies_o::value_c");
  }
}
ue_radio_cap_info_ind_ies_o::value_c::value_c(const ue_radio_cap_info_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_radio_cap_for_paging:
      c.init(other.c.get<ue_radio_cap_for_paging_s>());
      break;
    case types::ue_radio_cap_eutra_format:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_info_ind_ies_o::value_c");
  }
}
ue_radio_cap_info_ind_ies_o::value_c&
ue_radio_cap_info_ind_ies_o::value_c::operator=(const ue_radio_cap_info_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_radio_cap_for_paging:
      c.set(other.c.get<ue_radio_cap_for_paging_s>());
      break;
    case types::ue_radio_cap_eutra_format:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_info_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_radio_cap_info_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_radio_cap_info_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& ue_radio_cap_info_ind_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
ue_radio_cap_for_paging_s& ue_radio_cap_info_ind_ies_o::value_c::ue_radio_cap_for_paging()
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<ue_radio_cap_for_paging_s>();
}
unbounded_octstring<true>& ue_radio_cap_info_ind_ies_o::value_c::ue_radio_cap_eutra_format()
{
  assert_choice_type(types::ue_radio_cap_eutra_format, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ue_radio_cap_info_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_radio_cap_info_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& ue_radio_cap_info_ind_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const ue_radio_cap_for_paging_s& ue_radio_cap_info_ind_ies_o::value_c::ue_radio_cap_for_paging() const
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<ue_radio_cap_for_paging_s>();
}
const unbounded_octstring<true>& ue_radio_cap_info_ind_ies_o::value_c::ue_radio_cap_eutra_format() const
{
  assert_choice_type(types::ue_radio_cap_eutra_format, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ue_radio_cap_info_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::ue_radio_cap_for_paging:
      j.write_fieldname("UERadioCapabilityForPaging");
      c.get<ue_radio_cap_for_paging_s>().to_json(j);
      break;
    case types::ue_radio_cap_eutra_format:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_info_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_radio_cap_info_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().pack(bref));
      break;
    case types::ue_radio_cap_eutra_format:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_info_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_info_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().unpack(bref));
      break;
    case types::ue_radio_cap_eutra_format:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_info_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UETNLABindingReleaseRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_tnla_binding_release_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85};
  return map_enum_number(names, 2, idx, "id");
}
bool ue_tnla_binding_release_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_tnla_binding_release_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_tnla_binding_release_request_ies_o::value_c ue_tnla_binding_release_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_tnla_binding_release_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_tnla_binding_release_request_ies_o::value_c::destroy_() {}
void ue_tnla_binding_release_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
ue_tnla_binding_release_request_ies_o::value_c::value_c(const ue_tnla_binding_release_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_tnla_binding_release_request_ies_o::value_c");
  }
}
ue_tnla_binding_release_request_ies_o::value_c&
ue_tnla_binding_release_request_ies_o::value_c::operator=(const ue_tnla_binding_release_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_tnla_binding_release_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_tnla_binding_release_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_tnla_binding_release_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_tnla_binding_release_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_tnla_binding_release_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
void ue_tnla_binding_release_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    default:
      log_invalid_choice_id(type_, "ue_tnla_binding_release_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_tnla_binding_release_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "ue_tnla_binding_release_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_tnla_binding_release_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "ue_tnla_binding_release_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UplinkNASTransport-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_nas_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 38, 121, 239, 246, 247};
  return map_enum_number(names, 7, idx, "id");
}
bool ul_nas_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 38, 121, 239, 246, 247};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_nas_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 38:
      return crit_e::reject;
    case 121:
      return crit_e::ignore;
    case 239:
      return crit_e::reject;
    case 246:
      return crit_e::reject;
    case 247:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_nas_transport_ies_o::value_c ul_nas_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 239:
      ret.set(value_c::types::w_agf_id_info);
      break;
    case 246:
      ret.set(value_c::types::tngf_id_info);
      break;
    case 247:
      ret.set(value_c::types::twif_id_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_nas_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 38:
      return presence_e::mandatory;
    case 121:
      return presence_e::mandatory;
    case 239:
      return presence_e::optional;
    case 246:
      return presence_e::optional;
    case 247:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_nas_transport_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    case types::w_agf_id_info:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::tngf_id_info:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::twif_id_info:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void ul_nas_transport_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::w_agf_id_info:
      c.init<unbounded_octstring<true>>();
      break;
    case types::tngf_id_info:
      c.init<unbounded_octstring<true>>();
      break;
    case types::twif_id_info:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
  }
}
ul_nas_transport_ies_o::value_c::value_c(const ul_nas_transport_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::w_agf_id_info:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::tngf_id_info:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::twif_id_info:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
  }
}
ul_nas_transport_ies_o::value_c&
ul_nas_transport_ies_o::value_c::operator=(const ul_nas_transport_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::w_agf_id_info:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::tngf_id_info:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::twif_id_info:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
  }

  return *this;
}
uint64_t& ul_nas_transport_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ul_nas_transport_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
user_location_info_c& ul_nas_transport_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::w_agf_id_info()
{
  assert_choice_type(types::w_agf_id_info, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::tngf_id_info()
{
  assert_choice_type(types::tngf_id_info, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::twif_id_info()
{
  assert_choice_type(types::twif_id_info, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ul_nas_transport_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ul_nas_transport_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const user_location_info_c& ul_nas_transport_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::w_agf_id_info() const
{
  assert_choice_type(types::w_agf_id_info, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::tngf_id_info() const
{
  assert_choice_type(types::tngf_id_info, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::twif_id_info() const
{
  assert_choice_type(types::twif_id_info, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ul_nas_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::w_agf_id_info:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::tngf_id_info:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::twif_id_info:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_nas_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::w_agf_id_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::tngf_id_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::twif_id_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_nas_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::w_agf_id_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::tngf_id_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::twif_id_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UplinkNonUEAssociatedNRPPaTransportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_non_ue_associated_nrppa_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {89, 46};
  return map_enum_number(names, 2, idx, "id");
}
bool ul_non_ue_associated_nrppa_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {89, 46};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_non_ue_associated_nrppa_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 89:
      return crit_e::reject;
    case 46:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_non_ue_associated_nrppa_transport_ies_o::value_c
ul_non_ue_associated_nrppa_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 89:
      ret.set(value_c::types::routing_id);
      break;
    case 46:
      ret.set(value_c::types::nrppa_pdu);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_non_ue_associated_nrppa_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 89:
      return presence_e::mandatory;
    case 46:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_non_ue_associated_nrppa_transport_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::routing_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::nrppa_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void ul_non_ue_associated_nrppa_transport_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::routing_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nrppa_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
ul_non_ue_associated_nrppa_transport_ies_o::value_c::value_c(
    const ul_non_ue_associated_nrppa_transport_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::routing_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nrppa_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
ul_non_ue_associated_nrppa_transport_ies_o::value_c& ul_non_ue_associated_nrppa_transport_ies_o::value_c::operator=(
    const ul_non_ue_associated_nrppa_transport_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::routing_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nrppa_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ue_associated_nrppa_transport_ies_o::value_c");
  }

  return *this;
}
unbounded_octstring<true>& ul_non_ue_associated_nrppa_transport_ies_o::value_c::routing_id()
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ul_non_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu()
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ul_non_ue_associated_nrppa_transport_ies_o::value_c::routing_id() const
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ul_non_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu() const
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ul_non_ue_associated_nrppa_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::routing_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::nrppa_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ue_associated_nrppa_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_non_ue_associated_nrppa_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_non_ue_associated_nrppa_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UplinkRANConfigurationTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_ran_cfg_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {99, 158, 251};
  return map_enum_number(names, 3, idx, "id");
}
bool ul_ran_cfg_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {99, 158, 251};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_ran_cfg_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 99:
      return crit_e::ignore;
    case 158:
      return crit_e::ignore;
    case 251:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_ran_cfg_transfer_ies_o::value_c ul_ran_cfg_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 99:
      ret.set(value_c::types::son_cfg_transfer_ul);
      break;
    case 158:
      ret.set(value_c::types::endc_son_cfg_transfer_ul);
      break;
    case 251:
      ret.set(value_c::types::intersys_son_cfg_transfer_ul);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_ran_cfg_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 99:
      return presence_e::optional;
    case 158:
      return presence_e::optional;
    case 251:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_ran_cfg_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::son_cfg_transfer_ul:
      c.destroy<son_cfg_transfer_s>();
      break;
    case types::endc_son_cfg_transfer_ul:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::intersys_son_cfg_transfer_ul:
      c.destroy<intersys_son_cfg_transfer_s>();
      break;
    default:
      break;
  }
}
void ul_ran_cfg_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::son_cfg_transfer_ul:
      c.init<son_cfg_transfer_s>();
      break;
    case types::endc_son_cfg_transfer_ul:
      c.init<unbounded_octstring<true>>();
      break;
    case types::intersys_son_cfg_transfer_ul:
      c.init<intersys_son_cfg_transfer_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_cfg_transfer_ies_o::value_c");
  }
}
ul_ran_cfg_transfer_ies_o::value_c::value_c(const ul_ran_cfg_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::son_cfg_transfer_ul:
      c.init(other.c.get<son_cfg_transfer_s>());
      break;
    case types::endc_son_cfg_transfer_ul:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::intersys_son_cfg_transfer_ul:
      c.init(other.c.get<intersys_son_cfg_transfer_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_cfg_transfer_ies_o::value_c");
  }
}
ul_ran_cfg_transfer_ies_o::value_c&
ul_ran_cfg_transfer_ies_o::value_c::operator=(const ul_ran_cfg_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::son_cfg_transfer_ul:
      c.set(other.c.get<son_cfg_transfer_s>());
      break;
    case types::endc_son_cfg_transfer_ul:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::intersys_son_cfg_transfer_ul:
      c.set(other.c.get<intersys_son_cfg_transfer_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_cfg_transfer_ies_o::value_c");
  }

  return *this;
}
son_cfg_transfer_s& ul_ran_cfg_transfer_ies_o::value_c::son_cfg_transfer_ul()
{
  assert_choice_type(types::son_cfg_transfer_ul, type_, "Value");
  return c.get<son_cfg_transfer_s>();
}
unbounded_octstring<true>& ul_ran_cfg_transfer_ies_o::value_c::endc_son_cfg_transfer_ul()
{
  assert_choice_type(types::endc_son_cfg_transfer_ul, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
intersys_son_cfg_transfer_s& ul_ran_cfg_transfer_ies_o::value_c::intersys_son_cfg_transfer_ul()
{
  assert_choice_type(types::intersys_son_cfg_transfer_ul, type_, "Value");
  return c.get<intersys_son_cfg_transfer_s>();
}
const son_cfg_transfer_s& ul_ran_cfg_transfer_ies_o::value_c::son_cfg_transfer_ul() const
{
  assert_choice_type(types::son_cfg_transfer_ul, type_, "Value");
  return c.get<son_cfg_transfer_s>();
}
const unbounded_octstring<true>& ul_ran_cfg_transfer_ies_o::value_c::endc_son_cfg_transfer_ul() const
{
  assert_choice_type(types::endc_son_cfg_transfer_ul, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const intersys_son_cfg_transfer_s& ul_ran_cfg_transfer_ies_o::value_c::intersys_son_cfg_transfer_ul() const
{
  assert_choice_type(types::intersys_son_cfg_transfer_ul, type_, "Value");
  return c.get<intersys_son_cfg_transfer_s>();
}
void ul_ran_cfg_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::son_cfg_transfer_ul:
      j.write_fieldname("SONConfigurationTransfer");
      c.get<son_cfg_transfer_s>().to_json(j);
      break;
    case types::endc_son_cfg_transfer_ul:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::intersys_son_cfg_transfer_ul:
      j.write_fieldname("IntersystemSONConfigurationTransfer");
      c.get<intersys_son_cfg_transfer_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_cfg_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_ran_cfg_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::son_cfg_transfer_ul:
      HANDLE_CODE(c.get<son_cfg_transfer_s>().pack(bref));
      break;
    case types::endc_son_cfg_transfer_ul:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::intersys_son_cfg_transfer_ul:
      HANDLE_CODE(c.get<intersys_son_cfg_transfer_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_cfg_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ran_cfg_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::son_cfg_transfer_ul:
      HANDLE_CODE(c.get<son_cfg_transfer_s>().unpack(bref));
      break;
    case types::endc_son_cfg_transfer_ul:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::intersys_son_cfg_transfer_ul:
      HANDLE_CODE(c.get<intersys_son_cfg_transfer_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_cfg_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UplinkRANEarlyStatusTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_ran_early_status_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 268};
  return map_enum_number(names, 3, idx, "id");
}
bool ul_ran_early_status_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 268};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_ran_early_status_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 268:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_ran_early_status_transfer_ies_o::value_c ul_ran_early_status_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 268:
      ret.set(value_c::types::early_status_transfer_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_ran_early_status_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 268:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_ran_early_status_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::early_status_transfer_transparent_container:
      c.destroy<early_status_transfer_transparent_container_s>();
      break;
    default:
      break;
  }
}
void ul_ran_early_status_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::early_status_transfer_transparent_container:
      c.init<early_status_transfer_transparent_container_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_early_status_transfer_ies_o::value_c");
  }
}
ul_ran_early_status_transfer_ies_o::value_c::value_c(const ul_ran_early_status_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::early_status_transfer_transparent_container:
      c.init(other.c.get<early_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_early_status_transfer_ies_o::value_c");
  }
}
ul_ran_early_status_transfer_ies_o::value_c&
ul_ran_early_status_transfer_ies_o::value_c::operator=(const ul_ran_early_status_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::early_status_transfer_transparent_container:
      c.set(other.c.get<early_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_early_status_transfer_ies_o::value_c");
  }

  return *this;
}
uint64_t& ul_ran_early_status_transfer_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ul_ran_early_status_transfer_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
early_status_transfer_transparent_container_s&
ul_ran_early_status_transfer_ies_o::value_c::early_status_transfer_transparent_container()
{
  assert_choice_type(types::early_status_transfer_transparent_container, type_, "Value");
  return c.get<early_status_transfer_transparent_container_s>();
}
const uint64_t& ul_ran_early_status_transfer_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ul_ran_early_status_transfer_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const early_status_transfer_transparent_container_s&
ul_ran_early_status_transfer_ies_o::value_c::early_status_transfer_transparent_container() const
{
  assert_choice_type(types::early_status_transfer_transparent_container, type_, "Value");
  return c.get<early_status_transfer_transparent_container_s>();
}
void ul_ran_early_status_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::early_status_transfer_transparent_container:
      j.write_fieldname("EarlyStatusTransfer-TransparentContainer");
      c.get<early_status_transfer_transparent_container_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_early_status_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_ran_early_status_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::early_status_transfer_transparent_container:
      HANDLE_CODE(c.get<early_status_transfer_transparent_container_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_early_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ran_early_status_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::early_status_transfer_transparent_container:
      HANDLE_CODE(c.get<early_status_transfer_transparent_container_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_early_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UplinkRANStatusTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_ran_status_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 84};
  return map_enum_number(names, 3, idx, "id");
}
bool ul_ran_status_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 84};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_ran_status_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 84:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_ran_status_transfer_ies_o::value_c ul_ran_status_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 84:
      ret.set(value_c::types::ran_status_transfer_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_ran_status_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 84:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_ran_status_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ran_status_transfer_transparent_container:
      c.destroy<ran_status_transfer_transparent_container_s>();
      break;
    default:
      break;
  }
}
void ul_ran_status_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ran_status_transfer_transparent_container:
      c.init<ran_status_transfer_transparent_container_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_status_transfer_ies_o::value_c");
  }
}
ul_ran_status_transfer_ies_o::value_c::value_c(const ul_ran_status_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_status_transfer_transparent_container:
      c.init(other.c.get<ran_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_status_transfer_ies_o::value_c");
  }
}
ul_ran_status_transfer_ies_o::value_c&
ul_ran_status_transfer_ies_o::value_c::operator=(const ul_ran_status_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_status_transfer_transparent_container:
      c.set(other.c.get<ran_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_status_transfer_ies_o::value_c");
  }

  return *this;
}
uint64_t& ul_ran_status_transfer_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ul_ran_status_transfer_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
ran_status_transfer_transparent_container_s&
ul_ran_status_transfer_ies_o::value_c::ran_status_transfer_transparent_container()
{
  assert_choice_type(types::ran_status_transfer_transparent_container, type_, "Value");
  return c.get<ran_status_transfer_transparent_container_s>();
}
const uint64_t& ul_ran_status_transfer_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ul_ran_status_transfer_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const ran_status_transfer_transparent_container_s&
ul_ran_status_transfer_ies_o::value_c::ran_status_transfer_transparent_container() const
{
  assert_choice_type(types::ran_status_transfer_transparent_container, type_, "Value");
  return c.get<ran_status_transfer_transparent_container_s>();
}
void ul_ran_status_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ran_status_transfer_transparent_container:
      j.write_fieldname("RANStatusTransfer-TransparentContainer");
      c.get<ran_status_transfer_transparent_container_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_status_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_ran_status_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_status_transfer_transparent_container:
      HANDLE_CODE(c.get<ran_status_transfer_transparent_container_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ran_status_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_status_transfer_transparent_container:
      HANDLE_CODE(c.get<ran_status_transfer_transparent_container_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UplinkRIMInformationTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_rim_info_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {175};
  return map_enum_number(names, 1, idx, "id");
}
bool ul_rim_info_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  return 175 == id;
}
crit_e ul_rim_info_transfer_ies_o::get_crit(const uint32_t& id)
{
  if (id == 175) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
ul_rim_info_transfer_ies_o::value_c ul_rim_info_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 175) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_rim_info_transfer_ies_o::get_presence(const uint32_t& id)
{
  if (id == 175) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void ul_rim_info_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("RIMInformationTransfer");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE ul_rim_info_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_rim_info_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// UplinkUEAssociatedNRPPaTransportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_ue_associated_nrppa_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 89, 46};
  return map_enum_number(names, 4, idx, "id");
}
bool ul_ue_associated_nrppa_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 89, 46};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_ue_associated_nrppa_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 89:
      return crit_e::reject;
    case 46:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_ue_associated_nrppa_transport_ies_o::value_c ul_ue_associated_nrppa_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 89:
      ret.set(value_c::types::routing_id);
      break;
    case 46:
      ret.set(value_c::types::nrppa_pdu);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_ue_associated_nrppa_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 89:
      return presence_e::mandatory;
    case 46:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_ue_associated_nrppa_transport_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::routing_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::nrppa_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void ul_ue_associated_nrppa_transport_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::routing_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nrppa_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
ul_ue_associated_nrppa_transport_ies_o::value_c::value_c(const ul_ue_associated_nrppa_transport_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::routing_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nrppa_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
ul_ue_associated_nrppa_transport_ies_o::value_c&
ul_ue_associated_nrppa_transport_ies_o::value_c::operator=(const ul_ue_associated_nrppa_transport_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::routing_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nrppa_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ue_associated_nrppa_transport_ies_o::value_c");
  }

  return *this;
}
uint64_t& ul_ue_associated_nrppa_transport_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ul_ue_associated_nrppa_transport_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& ul_ue_associated_nrppa_transport_ies_o::value_c::routing_id()
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ul_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu()
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ul_ue_associated_nrppa_transport_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ul_ue_associated_nrppa_transport_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& ul_ue_associated_nrppa_transport_ies_o::value_c::routing_id() const
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ul_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu() const
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ul_ue_associated_nrppa_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::routing_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::nrppa_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ul_ue_associated_nrppa_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_ue_associated_nrppa_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ue_associated_nrppa_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// WriteReplaceWarningRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t write_replace_warning_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {35, 95, 122, 87, 47, 125, 124, 20, 123, 17, 141};
  return map_enum_number(names, 11, idx, "id");
}
bool write_replace_warning_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {35, 95, 122, 87, 47, 125, 124, 20, 123, 17, 141};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e write_replace_warning_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 35:
      return crit_e::reject;
    case 95:
      return crit_e::reject;
    case 122:
      return crit_e::ignore;
    case 87:
      return crit_e::reject;
    case 47:
      return crit_e::reject;
    case 125:
      return crit_e::ignore;
    case 124:
      return crit_e::ignore;
    case 20:
      return crit_e::ignore;
    case 123:
      return crit_e::ignore;
    case 17:
      return crit_e::reject;
    case 141:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
write_replace_warning_request_ies_o::value_c write_replace_warning_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 35:
      ret.set(value_c::types::msg_id);
      break;
    case 95:
      ret.set(value_c::types::serial_num);
      break;
    case 122:
      ret.set(value_c::types::warning_area_list);
      break;
    case 87:
      ret.set(value_c::types::repeat_period);
      break;
    case 47:
      ret.set(value_c::types::nof_broadcasts_requested);
      break;
    case 125:
      ret.set(value_c::types::warning_type);
      break;
    case 124:
      ret.set(value_c::types::warning_security_info);
      break;
    case 20:
      ret.set(value_c::types::data_coding_scheme);
      break;
    case 123:
      ret.set(value_c::types::warning_msg_contents);
      break;
    case 17:
      ret.set(value_c::types::concurrent_warning_msg_ind);
      break;
    case 141:
      ret.set(value_c::types::warning_area_coordinates);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e write_replace_warning_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 35:
      return presence_e::mandatory;
    case 95:
      return presence_e::mandatory;
    case 122:
      return presence_e::optional;
    case 87:
      return presence_e::mandatory;
    case 47:
      return presence_e::mandatory;
    case 125:
      return presence_e::optional;
    case 124:
      return presence_e::optional;
    case 20:
      return presence_e::optional;
    case 123:
      return presence_e::optional;
    case 17:
      return presence_e::optional;
    case 141:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void write_replace_warning_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::msg_id:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::serial_num:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::warning_area_list:
      c.destroy<warning_area_list_c>();
      break;
    case types::warning_type:
      c.destroy<fixed_octstring<2, true>>();
      break;
    case types::warning_security_info:
      c.destroy<fixed_octstring<50, true>>();
      break;
    case types::data_coding_scheme:
      c.destroy<fixed_bitstring<8, false, true>>();
      break;
    case types::warning_msg_contents:
      c.destroy<bounded_octstring<1, 9600, true>>();
      break;
    case types::warning_area_coordinates:
      c.destroy<bounded_octstring<1, 1024, true>>();
      break;
    default:
      break;
  }
}
void write_replace_warning_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::msg_id:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::serial_num:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::warning_area_list:
      c.init<warning_area_list_c>();
      break;
    case types::repeat_period:
      break;
    case types::nof_broadcasts_requested:
      break;
    case types::warning_type:
      c.init<fixed_octstring<2, true>>();
      break;
    case types::warning_security_info:
      c.init<fixed_octstring<50, true>>();
      break;
    case types::data_coding_scheme:
      c.init<fixed_bitstring<8, false, true>>();
      break;
    case types::warning_msg_contents:
      c.init<bounded_octstring<1, 9600, true>>();
      break;
    case types::concurrent_warning_msg_ind:
      break;
    case types::warning_area_coordinates:
      c.init<bounded_octstring<1, 1024, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
  }
}
write_replace_warning_request_ies_o::value_c::value_c(const write_replace_warning_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::msg_id:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::serial_num:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::warning_area_list:
      c.init(other.c.get<warning_area_list_c>());
      break;
    case types::repeat_period:
      c.init(other.c.get<uint32_t>());
      break;
    case types::nof_broadcasts_requested:
      c.init(other.c.get<uint32_t>());
      break;
    case types::warning_type:
      c.init(other.c.get<fixed_octstring<2, true>>());
      break;
    case types::warning_security_info:
      c.init(other.c.get<fixed_octstring<50, true>>());
      break;
    case types::data_coding_scheme:
      c.init(other.c.get<fixed_bitstring<8, false, true>>());
      break;
    case types::warning_msg_contents:
      c.init(other.c.get<bounded_octstring<1, 9600, true>>());
      break;
    case types::concurrent_warning_msg_ind:
      c.init(other.c.get<concurrent_warning_msg_ind_e>());
      break;
    case types::warning_area_coordinates:
      c.init(other.c.get<bounded_octstring<1, 1024, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
  }
}
write_replace_warning_request_ies_o::value_c&
write_replace_warning_request_ies_o::value_c::operator=(const write_replace_warning_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::msg_id:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::serial_num:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::warning_area_list:
      c.set(other.c.get<warning_area_list_c>());
      break;
    case types::repeat_period:
      c.set(other.c.get<uint32_t>());
      break;
    case types::nof_broadcasts_requested:
      c.set(other.c.get<uint32_t>());
      break;
    case types::warning_type:
      c.set(other.c.get<fixed_octstring<2, true>>());
      break;
    case types::warning_security_info:
      c.set(other.c.get<fixed_octstring<50, true>>());
      break;
    case types::data_coding_scheme:
      c.set(other.c.get<fixed_bitstring<8, false, true>>());
      break;
    case types::warning_msg_contents:
      c.set(other.c.get<bounded_octstring<1, 9600, true>>());
      break;
    case types::concurrent_warning_msg_ind:
      c.set(other.c.get<concurrent_warning_msg_ind_e>());
      break;
    case types::warning_area_coordinates:
      c.set(other.c.get<bounded_octstring<1, 1024, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
  }

  return *this;
}
fixed_bitstring<16, false, true>& write_replace_warning_request_ies_o::value_c::msg_id()
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
fixed_bitstring<16, false, true>& write_replace_warning_request_ies_o::value_c::serial_num()
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
warning_area_list_c& write_replace_warning_request_ies_o::value_c::warning_area_list()
{
  assert_choice_type(types::warning_area_list, type_, "Value");
  return c.get<warning_area_list_c>();
}
uint32_t& write_replace_warning_request_ies_o::value_c::repeat_period()
{
  assert_choice_type(types::repeat_period, type_, "Value");
  return c.get<uint32_t>();
}
uint32_t& write_replace_warning_request_ies_o::value_c::nof_broadcasts_requested()
{
  assert_choice_type(types::nof_broadcasts_requested, type_, "Value");
  return c.get<uint32_t>();
}
fixed_octstring<2, true>& write_replace_warning_request_ies_o::value_c::warning_type()
{
  assert_choice_type(types::warning_type, type_, "Value");
  return c.get<fixed_octstring<2, true>>();
}
fixed_octstring<50, true>& write_replace_warning_request_ies_o::value_c::warning_security_info()
{
  assert_choice_type(types::warning_security_info, type_, "Value");
  return c.get<fixed_octstring<50, true>>();
}
fixed_bitstring<8, false, true>& write_replace_warning_request_ies_o::value_c::data_coding_scheme()
{
  assert_choice_type(types::data_coding_scheme, type_, "Value");
  return c.get<fixed_bitstring<8, false, true>>();
}
bounded_octstring<1, 9600, true>& write_replace_warning_request_ies_o::value_c::warning_msg_contents()
{
  assert_choice_type(types::warning_msg_contents, type_, "Value");
  return c.get<bounded_octstring<1, 9600, true>>();
}
concurrent_warning_msg_ind_e& write_replace_warning_request_ies_o::value_c::concurrent_warning_msg_ind()
{
  assert_choice_type(types::concurrent_warning_msg_ind, type_, "Value");
  return c.get<concurrent_warning_msg_ind_e>();
}
bounded_octstring<1, 1024, true>& write_replace_warning_request_ies_o::value_c::warning_area_coordinates()
{
  assert_choice_type(types::warning_area_coordinates, type_, "Value");
  return c.get<bounded_octstring<1, 1024, true>>();
}
const fixed_bitstring<16, false, true>& write_replace_warning_request_ies_o::value_c::msg_id() const
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const fixed_bitstring<16, false, true>& write_replace_warning_request_ies_o::value_c::serial_num() const
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const warning_area_list_c& write_replace_warning_request_ies_o::value_c::warning_area_list() const
{
  assert_choice_type(types::warning_area_list, type_, "Value");
  return c.get<warning_area_list_c>();
}
const uint32_t& write_replace_warning_request_ies_o::value_c::repeat_period() const
{
  assert_choice_type(types::repeat_period, type_, "Value");
  return c.get<uint32_t>();
}
const uint32_t& write_replace_warning_request_ies_o::value_c::nof_broadcasts_requested() const
{
  assert_choice_type(types::nof_broadcasts_requested, type_, "Value");
  return c.get<uint32_t>();
}
const fixed_octstring<2, true>& write_replace_warning_request_ies_o::value_c::warning_type() const
{
  assert_choice_type(types::warning_type, type_, "Value");
  return c.get<fixed_octstring<2, true>>();
}
const fixed_octstring<50, true>& write_replace_warning_request_ies_o::value_c::warning_security_info() const
{
  assert_choice_type(types::warning_security_info, type_, "Value");
  return c.get<fixed_octstring<50, true>>();
}
const fixed_bitstring<8, false, true>& write_replace_warning_request_ies_o::value_c::data_coding_scheme() const
{
  assert_choice_type(types::data_coding_scheme, type_, "Value");
  return c.get<fixed_bitstring<8, false, true>>();
}
const bounded_octstring<1, 9600, true>& write_replace_warning_request_ies_o::value_c::warning_msg_contents() const
{
  assert_choice_type(types::warning_msg_contents, type_, "Value");
  return c.get<bounded_octstring<1, 9600, true>>();
}
const concurrent_warning_msg_ind_e& write_replace_warning_request_ies_o::value_c::concurrent_warning_msg_ind() const
{
  assert_choice_type(types::concurrent_warning_msg_ind, type_, "Value");
  return c.get<concurrent_warning_msg_ind_e>();
}
const bounded_octstring<1, 1024, true>& write_replace_warning_request_ies_o::value_c::warning_area_coordinates() const
{
  assert_choice_type(types::warning_area_coordinates, type_, "Value");
  return c.get<bounded_octstring<1, 1024, true>>();
}
void write_replace_warning_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::msg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::serial_num:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::warning_area_list:
      j.write_fieldname("WarningAreaList");
      c.get<warning_area_list_c>().to_json(j);
      break;
    case types::repeat_period:
      j.write_int("INTEGER (0..131071)", c.get<uint32_t>());
      break;
    case types::nof_broadcasts_requested:
      j.write_int("INTEGER (0..65535)", c.get<uint32_t>());
      break;
    case types::warning_type:
      j.write_str("OCTET STRING", c.get<fixed_octstring<2, true>>().to_string());
      break;
    case types::warning_security_info:
      j.write_str("OCTET STRING", c.get<fixed_octstring<50, true>>().to_string());
      break;
    case types::data_coding_scheme:
      j.write_str("BIT STRING", c.get<fixed_bitstring<8, false, true>>().to_string());
      break;
    case types::warning_msg_contents:
      j.write_str("OCTET STRING", c.get<bounded_octstring<1, 9600, true>>().to_string());
      break;
    case types::concurrent_warning_msg_ind:
      j.write_str("ConcurrentWarningMessageInd", "true");
      break;
    case types::warning_area_coordinates:
      j.write_str("OCTET STRING", c.get<bounded_octstring<1, 1024, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE write_replace_warning_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::warning_area_list:
      HANDLE_CODE(c.get<warning_area_list_c>().pack(bref));
      break;
    case types::repeat_period:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)131071u, false, true));
      break;
    case types::nof_broadcasts_requested:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, false, true));
      break;
    case types::warning_type:
      HANDLE_CODE((c.get<fixed_octstring<2, true>>().pack(bref)));
      break;
    case types::warning_security_info:
      HANDLE_CODE((c.get<fixed_octstring<50, true>>().pack(bref)));
      break;
    case types::data_coding_scheme:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true>>().pack(bref)));
      break;
    case types::warning_msg_contents:
      HANDLE_CODE((c.get<bounded_octstring<1, 9600, true>>().pack(bref)));
      break;
    case types::concurrent_warning_msg_ind:
      HANDLE_CODE(c.get<concurrent_warning_msg_ind_e>().pack(bref));
      break;
    case types::warning_area_coordinates:
      HANDLE_CODE((c.get<bounded_octstring<1, 1024, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE write_replace_warning_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::warning_area_list:
      HANDLE_CODE(c.get<warning_area_list_c>().unpack(bref));
      break;
    case types::repeat_period:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)131071u, false, true));
      break;
    case types::nof_broadcasts_requested:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, false, true));
      break;
    case types::warning_type:
      HANDLE_CODE((c.get<fixed_octstring<2, true>>().unpack(bref)));
      break;
    case types::warning_security_info:
      HANDLE_CODE((c.get<fixed_octstring<50, true>>().unpack(bref)));
      break;
    case types::data_coding_scheme:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true>>().unpack(bref)));
      break;
    case types::warning_msg_contents:
      HANDLE_CODE((c.get<bounded_octstring<1, 9600, true>>().unpack(bref)));
      break;
    case types::concurrent_warning_msg_ind:
      HANDLE_CODE(c.get<concurrent_warning_msg_ind_e>().unpack(bref));
      break;
    case types::warning_area_coordinates:
      HANDLE_CODE((c.get<bounded_octstring<1, 1024, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// WriteReplaceWarningResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t write_replace_warning_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {35, 95, 13, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool write_replace_warning_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {35, 95, 13, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e write_replace_warning_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 35:
      return crit_e::reject;
    case 95:
      return crit_e::reject;
    case 13:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
write_replace_warning_resp_ies_o::value_c write_replace_warning_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 35:
      ret.set(value_c::types::msg_id);
      break;
    case 95:
      ret.set(value_c::types::serial_num);
      break;
    case 13:
      ret.set(value_c::types::broadcast_completed_area_list);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e write_replace_warning_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 35:
      return presence_e::mandatory;
    case 95:
      return presence_e::mandatory;
    case 13:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void write_replace_warning_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::msg_id:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::serial_num:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::broadcast_completed_area_list:
      c.destroy<broadcast_completed_area_list_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void write_replace_warning_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::msg_id:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::serial_num:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::broadcast_completed_area_list:
      c.init<broadcast_completed_area_list_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
  }
}
write_replace_warning_resp_ies_o::value_c::value_c(const write_replace_warning_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::msg_id:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::serial_num:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::broadcast_completed_area_list:
      c.init(other.c.get<broadcast_completed_area_list_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
  }
}
write_replace_warning_resp_ies_o::value_c&
write_replace_warning_resp_ies_o::value_c::operator=(const write_replace_warning_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::msg_id:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::serial_num:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::broadcast_completed_area_list:
      c.set(other.c.get<broadcast_completed_area_list_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
  }

  return *this;
}
fixed_bitstring<16, false, true>& write_replace_warning_resp_ies_o::value_c::msg_id()
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
fixed_bitstring<16, false, true>& write_replace_warning_resp_ies_o::value_c::serial_num()
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
broadcast_completed_area_list_c& write_replace_warning_resp_ies_o::value_c::broadcast_completed_area_list()
{
  assert_choice_type(types::broadcast_completed_area_list, type_, "Value");
  return c.get<broadcast_completed_area_list_c>();
}
crit_diagnostics_s& write_replace_warning_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const fixed_bitstring<16, false, true>& write_replace_warning_resp_ies_o::value_c::msg_id() const
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const fixed_bitstring<16, false, true>& write_replace_warning_resp_ies_o::value_c::serial_num() const
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const broadcast_completed_area_list_c& write_replace_warning_resp_ies_o::value_c::broadcast_completed_area_list() const
{
  assert_choice_type(types::broadcast_completed_area_list, type_, "Value");
  return c.get<broadcast_completed_area_list_c>();
}
const crit_diagnostics_s& write_replace_warning_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void write_replace_warning_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::msg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::serial_num:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::broadcast_completed_area_list:
      j.write_fieldname("BroadcastCompletedAreaList");
      c.get<broadcast_completed_area_list_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE write_replace_warning_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::broadcast_completed_area_list:
      HANDLE_CODE(c.get<broadcast_completed_area_list_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE write_replace_warning_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::broadcast_completed_area_list:
      HANDLE_CODE(c.get<broadcast_completed_area_list_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

location_report_ies_container::location_report_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  user_location_info(121, crit_e::ignore),
  ue_presence_in_area_of_interest_list(116, crit_e::ignore),
  location_report_request_type(33, crit_e::ignore)
{
}
SRSASN_CODE location_report_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += ue_presence_in_area_of_interest_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(user_location_info.pack(bref));
  if (ue_presence_in_area_of_interest_list_present) {
    HANDLE_CODE(ue_presence_in_area_of_interest_list.pack(bref));
  }
  HANDLE_CODE(location_report_request_type.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 121: {
        nof_mandatory_ies--;
        user_location_info.id = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      case 116: {
        ue_presence_in_area_of_interest_list_present = true;
        ue_presence_in_area_of_interest_list.id      = id;
        HANDLE_CODE(ue_presence_in_area_of_interest_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_presence_in_area_of_interest_list.value.unpack(bref));
        break;
      }
      case 33: {
        nof_mandatory_ies--;
        location_report_request_type.id = id;
        HANDLE_CODE(location_report_request_type.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(location_report_request_type.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void location_report_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  user_location_info.to_json(j);
  if (ue_presence_in_area_of_interest_list_present) {
    j.write_fieldname("");
    ue_presence_in_area_of_interest_list.to_json(j);
  }
  j.write_fieldname("");
  location_report_request_type.to_json(j);
  j.end_obj();
}

location_report_ctrl_ies_container::location_report_ctrl_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  location_report_request_type(33, crit_e::ignore)
{
}
SRSASN_CODE location_report_ctrl_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(location_report_request_type.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_ctrl_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 33: {
        nof_mandatory_ies--;
        location_report_request_type.id = id;
        HANDLE_CODE(location_report_request_type.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(location_report_request_type.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void location_report_ctrl_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  location_report_request_type.to_json(j);
  j.end_obj();
}

location_report_fail_ind_ies_container::location_report_fail_ind_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject), ran_ue_ngap_id(85, crit_e::reject), cause(15, crit_e::ignore)
{
}
SRSASN_CODE location_report_fail_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_fail_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void location_report_fail_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.end_obj();
}

multicast_group_paging_ies_container::multicast_group_paging_ies_container() :
  mbs_session_id(299, crit_e::ignore),
  mbs_service_area(298, crit_e::ignore),
  multicast_group_paging_area_list(307, crit_e::ignore)
{
}
SRSASN_CODE multicast_group_paging_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_service_area_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_service_area_present) {
    HANDLE_CODE(mbs_service_area.pack(bref));
  }
  HANDLE_CODE(multicast_group_paging_area_list.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_group_paging_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 298: {
        mbs_service_area_present = true;
        mbs_service_area.id      = id;
        HANDLE_CODE(mbs_service_area.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_service_area.value.unpack(bref));
        break;
      }
      case 307: {
        nof_mandatory_ies--;
        multicast_group_paging_area_list.id = id;
        HANDLE_CODE(multicast_group_paging_area_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(multicast_group_paging_area_list.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_group_paging_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_service_area_present) {
    j.write_fieldname("");
    mbs_service_area.to_json(j);
  }
  j.write_fieldname("");
  multicast_group_paging_area_list.to_json(j);
  j.end_obj();
}

multicast_session_activation_fail_ies_container::multicast_session_activation_fail_ies_container() :
  mbs_session_id(299, crit_e::reject), cause(15, crit_e::ignore), crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE multicast_session_activation_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_activation_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

multicast_session_activation_request_ies_container::multicast_session_activation_request_ies_container() :
  mbs_session_id(299, crit_e::reject), multicast_session_activation_request_transfer(304, crit_e::reject)
{
}
SRSASN_CODE multicast_session_activation_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  HANDLE_CODE(multicast_session_activation_request_transfer.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 304: {
        nof_mandatory_ies--;
        multicast_session_activation_request_transfer.id = id;
        HANDLE_CODE(multicast_session_activation_request_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(multicast_session_activation_request_transfer.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_activation_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  j.write_fieldname("");
  multicast_session_activation_request_transfer.to_json(j);
  j.end_obj();
}

multicast_session_activation_resp_ies_container::multicast_session_activation_resp_ies_container() :
  mbs_session_id(299, crit_e::reject), crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE multicast_session_activation_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_activation_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

multicast_session_deactivation_request_ies_container::multicast_session_deactivation_request_ies_container() :
  mbs_session_id(299, crit_e::reject), multicast_session_deactivation_request_transfer(305, crit_e::reject)
{
}
SRSASN_CODE multicast_session_deactivation_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  HANDLE_CODE(multicast_session_deactivation_request_transfer.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_deactivation_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 305: {
        nof_mandatory_ies--;
        multicast_session_deactivation_request_transfer.id = id;
        HANDLE_CODE(multicast_session_deactivation_request_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(multicast_session_deactivation_request_transfer.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_deactivation_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  j.write_fieldname("");
  multicast_session_deactivation_request_transfer.to_json(j);
  j.end_obj();
}

multicast_session_deactivation_resp_ies_container::multicast_session_deactivation_resp_ies_container() :
  mbs_session_id(299, crit_e::reject), crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE multicast_session_deactivation_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_deactivation_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_deactivation_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

multicast_session_upd_fail_ies_container::multicast_session_upd_fail_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_area_session_id(295, crit_e::reject),
  cause(15, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE multicast_session_upd_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(mbs_area_session_id.pack(bref));
  }
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        mbs_area_session_id.id      = id;
        HANDLE_CODE(mbs_area_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_area_session_id.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_upd_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_fieldname("");
    mbs_area_session_id.to_json(j);
  }
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

multicast_session_upd_request_ies_container::multicast_session_upd_request_ies_container() :
  mbs_session_id(299, crit_e::reject),
  mbs_area_session_id(295, crit_e::reject),
  multicast_session_upd_request_transfer(306, crit_e::reject)
{
}
SRSASN_CODE multicast_session_upd_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(mbs_area_session_id.pack(bref));
  }
  HANDLE_CODE(multicast_session_upd_request_transfer.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        mbs_area_session_id.id      = id;
        HANDLE_CODE(mbs_area_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_area_session_id.value.unpack(bref));
        break;
      }
      case 306: {
        nof_mandatory_ies--;
        multicast_session_upd_request_transfer.id = id;
        HANDLE_CODE(multicast_session_upd_request_transfer.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(multicast_session_upd_request_transfer.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_upd_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_fieldname("");
    mbs_area_session_id.to_json(j);
  }
  j.write_fieldname("");
  multicast_session_upd_request_transfer.to_json(j);
  j.end_obj();
}

multicast_session_upd_resp_ies_container::multicast_session_upd_resp_ies_container() :
  mbs_session_id(299, crit_e::reject), mbs_area_session_id(295, crit_e::reject), crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE multicast_session_upd_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (mbs_area_session_id_present) {
    HANDLE_CODE(mbs_area_session_id.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        mbs_session_id.id = id;
        HANDLE_CODE(mbs_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.value.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        mbs_area_session_id.id      = id;
        HANDLE_CODE(mbs_area_session_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_area_session_id.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_upd_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_fieldname("");
    mbs_area_session_id.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

nas_non_delivery_ind_ies_container::nas_non_delivery_ind_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  nas_pdu(38, crit_e::ignore),
  cause(15, crit_e::ignore)
{
}
SRSASN_CODE nas_non_delivery_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(nas_pdu.pack(bref));
  HANDLE_CODE(cause.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE nas_non_delivery_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 38: {
        nof_mandatory_ies--;
        nas_pdu.id = id;
        HANDLE_CODE(nas_pdu.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void nas_non_delivery_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  nas_pdu.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.end_obj();
}

ng_reset_ies_container::ng_reset_ies_container() : cause(15, crit_e::ignore), reset_type(88, crit_e::reject) {}
SRSASN_CODE ng_reset_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(cause.pack(bref));
  HANDLE_CODE(reset_type.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_reset_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 88: {
        nof_mandatory_ies--;
        reset_type.id = id;
        HANDLE_CODE(reset_type.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(reset_type.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ng_reset_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  cause.to_json(j);
  j.write_fieldname("");
  reset_type.to_json(j);
  j.end_obj();
}

ng_reset_ack_ies_container::ng_reset_ack_ies_container() :
  ue_associated_lc_ng_conn_list(111, crit_e::ignore), crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ng_reset_ack_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += ue_associated_lc_ng_conn_list_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (ue_associated_lc_ng_conn_list_present) {
    HANDLE_CODE(ue_associated_lc_ng_conn_list.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_reset_ack_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 111: {
        ue_associated_lc_ng_conn_list_present = true;
        ue_associated_lc_ng_conn_list.id      = id;
        HANDLE_CODE(ue_associated_lc_ng_conn_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_associated_lc_ng_conn_list.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ng_reset_ack_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (ue_associated_lc_ng_conn_list_present) {
    j.write_fieldname("");
    ue_associated_lc_ng_conn_list.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

ng_setup_fail_ies_container::ng_setup_fail_ies_container() :
  cause(15, crit_e::ignore), time_to_wait(107, crit_e::ignore), crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ng_setup_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += time_to_wait_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(cause.pack(bref));
  if (time_to_wait_present) {
    HANDLE_CODE(time_to_wait.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_setup_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 107: {
        time_to_wait_present = true;
        time_to_wait.id      = id;
        HANDLE_CODE(time_to_wait.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_to_wait.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ng_setup_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  cause.to_json(j);
  if (time_to_wait_present) {
    j.write_fieldname("");
    time_to_wait.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

ng_setup_request_ies_container::ng_setup_request_ies_container() :
  global_ran_node_id(27, crit_e::reject),
  ran_node_name(82, crit_e::ignore),
  supported_ta_list(102, crit_e::reject),
  default_paging_drx(21, crit_e::ignore),
  ue_retention_info(147, crit_e::ignore),
  nb_iot_default_paging_drx(204, crit_e::ignore),
  extended_ran_node_name(273, crit_e::ignore)
{
}
SRSASN_CODE ng_setup_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ran_node_name_present ? 1 : 0;
  nof_ies += ue_retention_info_present ? 1 : 0;
  nof_ies += nb_iot_default_paging_drx_present ? 1 : 0;
  nof_ies += extended_ran_node_name_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(global_ran_node_id.pack(bref));
  if (ran_node_name_present) {
    HANDLE_CODE(ran_node_name.pack(bref));
  }
  HANDLE_CODE(supported_ta_list.pack(bref));
  HANDLE_CODE(default_paging_drx.pack(bref));
  if (ue_retention_info_present) {
    HANDLE_CODE(ue_retention_info.pack(bref));
  }
  if (nb_iot_default_paging_drx_present) {
    HANDLE_CODE(nb_iot_default_paging_drx.pack(bref));
  }
  if (extended_ran_node_name_present) {
    HANDLE_CODE(extended_ran_node_name.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_setup_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 27: {
        nof_mandatory_ies--;
        global_ran_node_id.id = id;
        HANDLE_CODE(global_ran_node_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(global_ran_node_id.value.unpack(bref));
        break;
      }
      case 82: {
        ran_node_name_present = true;
        ran_node_name.id      = id;
        HANDLE_CODE(ran_node_name.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_node_name.value.unpack(bref));
        break;
      }
      case 102: {
        nof_mandatory_ies--;
        supported_ta_list.id = id;
        HANDLE_CODE(supported_ta_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(supported_ta_list.value.unpack(bref));
        break;
      }
      case 21: {
        nof_mandatory_ies--;
        default_paging_drx.id = id;
        HANDLE_CODE(default_paging_drx.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(default_paging_drx.value.unpack(bref));
        break;
      }
      case 147: {
        ue_retention_info_present = true;
        ue_retention_info.id      = id;
        HANDLE_CODE(ue_retention_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_retention_info.value.unpack(bref));
        break;
      }
      case 204: {
        nb_iot_default_paging_drx_present = true;
        nb_iot_default_paging_drx.id      = id;
        HANDLE_CODE(nb_iot_default_paging_drx.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nb_iot_default_paging_drx.value.unpack(bref));
        break;
      }
      case 273: {
        extended_ran_node_name_present = true;
        extended_ran_node_name.id      = id;
        HANDLE_CODE(extended_ran_node_name.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_ran_node_name.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ng_setup_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  global_ran_node_id.to_json(j);
  if (ran_node_name_present) {
    j.write_fieldname("");
    ran_node_name.to_json(j);
  }
  j.write_fieldname("");
  supported_ta_list.to_json(j);
  j.write_fieldname("");
  default_paging_drx.to_json(j);
  if (ue_retention_info_present) {
    j.write_fieldname("");
    ue_retention_info.to_json(j);
  }
  if (nb_iot_default_paging_drx_present) {
    j.write_fieldname("");
    nb_iot_default_paging_drx.to_json(j);
  }
  if (extended_ran_node_name_present) {
    j.write_fieldname("");
    extended_ran_node_name.to_json(j);
  }
  j.end_obj();
}

ng_setup_resp_ies_container::ng_setup_resp_ies_container() :
  amf_name(1, crit_e::reject),
  served_guami_list(96, crit_e::reject),
  relative_amf_capacity(86, crit_e::ignore),
  plmn_support_list(80, crit_e::reject),
  crit_diagnostics(19, crit_e::ignore),
  ue_retention_info(147, crit_e::ignore),
  iab_supported(200, crit_e::ignore),
  extended_amf_name(274, crit_e::ignore)
{
}
SRSASN_CODE ng_setup_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += ue_retention_info_present ? 1 : 0;
  nof_ies += iab_supported_present ? 1 : 0;
  nof_ies += extended_amf_name_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_name.pack(bref));
  HANDLE_CODE(served_guami_list.pack(bref));
  HANDLE_CODE(relative_amf_capacity.pack(bref));
  HANDLE_CODE(plmn_support_list.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (ue_retention_info_present) {
    HANDLE_CODE(ue_retention_info.pack(bref));
  }
  if (iab_supported_present) {
    HANDLE_CODE(iab_supported.pack(bref));
  }
  if (extended_amf_name_present) {
    HANDLE_CODE(extended_amf_name.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_setup_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 1: {
        nof_mandatory_ies--;
        amf_name.id = id;
        HANDLE_CODE(amf_name.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_name.value.unpack(bref));
        break;
      }
      case 96: {
        nof_mandatory_ies--;
        served_guami_list.id = id;
        HANDLE_CODE(served_guami_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(served_guami_list.value.unpack(bref));
        break;
      }
      case 86: {
        nof_mandatory_ies--;
        relative_amf_capacity.id = id;
        HANDLE_CODE(relative_amf_capacity.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(relative_amf_capacity.value.unpack(bref));
        break;
      }
      case 80: {
        nof_mandatory_ies--;
        plmn_support_list.id = id;
        HANDLE_CODE(plmn_support_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(plmn_support_list.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      case 147: {
        ue_retention_info_present = true;
        ue_retention_info.id      = id;
        HANDLE_CODE(ue_retention_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_retention_info.value.unpack(bref));
        break;
      }
      case 200: {
        iab_supported_present = true;
        iab_supported.id      = id;
        HANDLE_CODE(iab_supported.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(iab_supported.value.unpack(bref));
        break;
      }
      case 274: {
        extended_amf_name_present = true;
        extended_amf_name.id      = id;
        HANDLE_CODE(extended_amf_name.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_amf_name.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ng_setup_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_name.to_json(j);
  j.write_fieldname("");
  served_guami_list.to_json(j);
  j.write_fieldname("");
  relative_amf_capacity.to_json(j);
  j.write_fieldname("");
  plmn_support_list.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (ue_retention_info_present) {
    j.write_fieldname("");
    ue_retention_info.to_json(j);
  }
  if (iab_supported_present) {
    j.write_fieldname("");
    iab_supported.to_json(j);
  }
  if (extended_amf_name_present) {
    j.write_fieldname("");
    extended_amf_name.to_json(j);
  }
  j.end_obj();
}

overload_start_ies_container::overload_start_ies_container() :
  amf_overload_resp(2, crit_e::reject),
  amf_traffic_load_reduction_ind(9, crit_e::ignore),
  overload_start_nssai_list(49, crit_e::ignore)
{
}
SRSASN_CODE overload_start_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += amf_overload_resp_present ? 1 : 0;
  nof_ies += amf_traffic_load_reduction_ind_present ? 1 : 0;
  nof_ies += overload_start_nssai_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (amf_overload_resp_present) {
    HANDLE_CODE(amf_overload_resp.pack(bref));
  }
  if (amf_traffic_load_reduction_ind_present) {
    HANDLE_CODE(amf_traffic_load_reduction_ind.pack(bref));
  }
  if (overload_start_nssai_list_present) {
    HANDLE_CODE(overload_start_nssai_list.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE overload_start_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 2: {
        amf_overload_resp_present = true;
        amf_overload_resp.id      = id;
        HANDLE_CODE(amf_overload_resp.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_overload_resp.value.unpack(bref));
        break;
      }
      case 9: {
        amf_traffic_load_reduction_ind_present = true;
        amf_traffic_load_reduction_ind.id      = id;
        HANDLE_CODE(amf_traffic_load_reduction_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_traffic_load_reduction_ind.value.unpack(bref));
        break;
      }
      case 49: {
        overload_start_nssai_list_present = true;
        overload_start_nssai_list.id      = id;
        HANDLE_CODE(overload_start_nssai_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(overload_start_nssai_list.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void overload_start_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (amf_overload_resp_present) {
    j.write_fieldname("");
    amf_overload_resp.to_json(j);
  }
  if (amf_traffic_load_reduction_ind_present) {
    j.write_fieldname("");
    amf_traffic_load_reduction_ind.to_json(j);
  }
  if (overload_start_nssai_list_present) {
    j.write_fieldname("");
    overload_start_nssai_list.to_json(j);
  }
  j.end_obj();
}

pdu_session_res_modify_confirm_ies_container::pdu_session_res_modify_confirm_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  pdu_session_res_modify_list_mod_cfm(62, crit_e::ignore),
  pdu_session_res_failed_to_modify_list_mod_cfm(131, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE pdu_session_res_modify_confirm_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += pdu_session_res_modify_list_mod_cfm_present ? 1 : 0;
  nof_ies += pdu_session_res_failed_to_modify_list_mod_cfm_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (pdu_session_res_modify_list_mod_cfm_present) {
    HANDLE_CODE(pdu_session_res_modify_list_mod_cfm.pack(bref));
  }
  if (pdu_session_res_failed_to_modify_list_mod_cfm_present) {
    HANDLE_CODE(pdu_session_res_failed_to_modify_list_mod_cfm.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_confirm_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 62: {
        pdu_session_res_modify_list_mod_cfm_present = true;
        pdu_session_res_modify_list_mod_cfm.id      = id;
        HANDLE_CODE(pdu_session_res_modify_list_mod_cfm.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_modify_list_mod_cfm.value.unpack(bref));
        break;
      }
      case 131: {
        pdu_session_res_failed_to_modify_list_mod_cfm_present = true;
        pdu_session_res_failed_to_modify_list_mod_cfm.id      = id;
        HANDLE_CODE(pdu_session_res_failed_to_modify_list_mod_cfm.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_failed_to_modify_list_mod_cfm.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_confirm_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (pdu_session_res_modify_list_mod_cfm_present) {
    j.write_fieldname("");
    pdu_session_res_modify_list_mod_cfm.to_json(j);
  }
  if (pdu_session_res_failed_to_modify_list_mod_cfm_present) {
    j.write_fieldname("");
    pdu_session_res_failed_to_modify_list_mod_cfm.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

pdu_session_res_modify_ind_ies_container::pdu_session_res_modify_ind_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  pdu_session_res_modify_list_mod_ind(63, crit_e::reject),
  user_location_info(121, crit_e::ignore)
{
}
SRSASN_CODE pdu_session_res_modify_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += user_location_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(pdu_session_res_modify_list_mod_ind.pack(bref));
  if (user_location_info_present) {
    HANDLE_CODE(user_location_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 63: {
        nof_mandatory_ies--;
        pdu_session_res_modify_list_mod_ind.id = id;
        HANDLE_CODE(pdu_session_res_modify_list_mod_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_modify_list_mod_ind.value.unpack(bref));
        break;
      }
      case 121: {
        user_location_info_present = true;
        user_location_info.id      = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  pdu_session_res_modify_list_mod_ind.to_json(j);
  if (user_location_info_present) {
    j.write_fieldname("");
    user_location_info.to_json(j);
  }
  j.end_obj();
}

pdu_session_res_modify_request_ies_container::pdu_session_res_modify_request_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  ran_paging_prio(83, crit_e::ignore),
  pdu_session_res_modify_list_mod_req(64, crit_e::reject)
{
}
SRSASN_CODE pdu_session_res_modify_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ran_paging_prio_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (ran_paging_prio_present) {
    HANDLE_CODE(ran_paging_prio.pack(bref));
  }
  HANDLE_CODE(pdu_session_res_modify_list_mod_req.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 83: {
        ran_paging_prio_present = true;
        ran_paging_prio.id      = id;
        HANDLE_CODE(ran_paging_prio.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_paging_prio.value.unpack(bref));
        break;
      }
      case 64: {
        nof_mandatory_ies--;
        pdu_session_res_modify_list_mod_req.id = id;
        HANDLE_CODE(pdu_session_res_modify_list_mod_req.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_modify_list_mod_req.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (ran_paging_prio_present) {
    j.write_fieldname("");
    ran_paging_prio.to_json(j);
  }
  j.write_fieldname("");
  pdu_session_res_modify_list_mod_req.to_json(j);
  j.end_obj();
}

pdu_session_res_modify_resp_ies_container::pdu_session_res_modify_resp_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  pdu_session_res_modify_list_mod_res(65, crit_e::ignore),
  pdu_session_res_failed_to_modify_list_mod_res(54, crit_e::ignore),
  user_location_info(121, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE pdu_session_res_modify_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += pdu_session_res_modify_list_mod_res_present ? 1 : 0;
  nof_ies += pdu_session_res_failed_to_modify_list_mod_res_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (pdu_session_res_modify_list_mod_res_present) {
    HANDLE_CODE(pdu_session_res_modify_list_mod_res.pack(bref));
  }
  if (pdu_session_res_failed_to_modify_list_mod_res_present) {
    HANDLE_CODE(pdu_session_res_failed_to_modify_list_mod_res.pack(bref));
  }
  if (user_location_info_present) {
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 65: {
        pdu_session_res_modify_list_mod_res_present = true;
        pdu_session_res_modify_list_mod_res.id      = id;
        HANDLE_CODE(pdu_session_res_modify_list_mod_res.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_modify_list_mod_res.value.unpack(bref));
        break;
      }
      case 54: {
        pdu_session_res_failed_to_modify_list_mod_res_present = true;
        pdu_session_res_failed_to_modify_list_mod_res.id      = id;
        HANDLE_CODE(pdu_session_res_failed_to_modify_list_mod_res.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_failed_to_modify_list_mod_res.value.unpack(bref));
        break;
      }
      case 121: {
        user_location_info_present = true;
        user_location_info.id      = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (pdu_session_res_modify_list_mod_res_present) {
    j.write_fieldname("");
    pdu_session_res_modify_list_mod_res.to_json(j);
  }
  if (pdu_session_res_failed_to_modify_list_mod_res_present) {
    j.write_fieldname("");
    pdu_session_res_failed_to_modify_list_mod_res.to_json(j);
  }
  if (user_location_info_present) {
    j.write_fieldname("");
    user_location_info.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

pdu_session_res_notify_ies_container::pdu_session_res_notify_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  pdu_session_res_notify_list(66, crit_e::reject),
  pdu_session_res_released_list_not(67, crit_e::ignore),
  user_location_info(121, crit_e::ignore)
{
}
SRSASN_CODE pdu_session_res_notify_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += pdu_session_res_notify_list_present ? 1 : 0;
  nof_ies += pdu_session_res_released_list_not_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (pdu_session_res_notify_list_present) {
    HANDLE_CODE(pdu_session_res_notify_list.pack(bref));
  }
  if (pdu_session_res_released_list_not_present) {
    HANDLE_CODE(pdu_session_res_released_list_not.pack(bref));
  }
  if (user_location_info_present) {
    HANDLE_CODE(user_location_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_notify_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 66: {
        pdu_session_res_notify_list_present = true;
        pdu_session_res_notify_list.id      = id;
        HANDLE_CODE(pdu_session_res_notify_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_notify_list.value.unpack(bref));
        break;
      }
      case 67: {
        pdu_session_res_released_list_not_present = true;
        pdu_session_res_released_list_not.id      = id;
        HANDLE_CODE(pdu_session_res_released_list_not.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_released_list_not.value.unpack(bref));
        break;
      }
      case 121: {
        user_location_info_present = true;
        user_location_info.id      = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_notify_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (pdu_session_res_notify_list_present) {
    j.write_fieldname("");
    pdu_session_res_notify_list.to_json(j);
  }
  if (pdu_session_res_released_list_not_present) {
    j.write_fieldname("");
    pdu_session_res_released_list_not.to_json(j);
  }
  if (user_location_info_present) {
    j.write_fieldname("");
    user_location_info.to_json(j);
  }
  j.end_obj();
}

pdu_session_res_release_cmd_ies_container::pdu_session_res_release_cmd_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  ran_paging_prio(83, crit_e::ignore),
  nas_pdu(38, crit_e::ignore),
  pdu_session_res_to_release_list_rel_cmd(79, crit_e::reject)
{
}
SRSASN_CODE pdu_session_res_release_cmd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ran_paging_prio_present ? 1 : 0;
  nof_ies += nas_pdu_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (ran_paging_prio_present) {
    HANDLE_CODE(ran_paging_prio.pack(bref));
  }
  if (nas_pdu_present) {
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  HANDLE_CODE(pdu_session_res_to_release_list_rel_cmd.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_release_cmd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 83: {
        ran_paging_prio_present = true;
        ran_paging_prio.id      = id;
        HANDLE_CODE(ran_paging_prio.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_paging_prio.value.unpack(bref));
        break;
      }
      case 38: {
        nas_pdu_present = true;
        nas_pdu.id      = id;
        HANDLE_CODE(nas_pdu.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.value.unpack(bref));
        break;
      }
      case 79: {
        nof_mandatory_ies--;
        pdu_session_res_to_release_list_rel_cmd.id = id;
        HANDLE_CODE(pdu_session_res_to_release_list_rel_cmd.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_to_release_list_rel_cmd.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_release_cmd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (ran_paging_prio_present) {
    j.write_fieldname("");
    ran_paging_prio.to_json(j);
  }
  if (nas_pdu_present) {
    j.write_fieldname("");
    nas_pdu.to_json(j);
  }
  j.write_fieldname("");
  pdu_session_res_to_release_list_rel_cmd.to_json(j);
  j.end_obj();
}

pdu_session_res_release_resp_ies_container::pdu_session_res_release_resp_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  pdu_session_res_released_list_rel_res(70, crit_e::ignore),
  user_location_info(121, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE pdu_session_res_release_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += user_location_info_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(pdu_session_res_released_list_rel_res.pack(bref));
  if (user_location_info_present) {
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_release_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 70: {
        nof_mandatory_ies--;
        pdu_session_res_released_list_rel_res.id = id;
        HANDLE_CODE(pdu_session_res_released_list_rel_res.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_released_list_rel_res.value.unpack(bref));
        break;
      }
      case 121: {
        user_location_info_present = true;
        user_location_info.id      = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_release_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  pdu_session_res_released_list_rel_res.to_json(j);
  if (user_location_info_present) {
    j.write_fieldname("");
    user_location_info.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

pdu_session_res_setup_request_ies_container::pdu_session_res_setup_request_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  ran_paging_prio(83, crit_e::ignore),
  nas_pdu(38, crit_e::reject),
  pdu_session_res_setup_list_su_req(74, crit_e::reject),
  ue_aggr_max_bit_rate(110, crit_e::ignore),
  ue_slice_max_bit_rate_list(335, crit_e::ignore)
{
}
SRSASN_CODE pdu_session_res_setup_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ran_paging_prio_present ? 1 : 0;
  nof_ies += nas_pdu_present ? 1 : 0;
  nof_ies += ue_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += ue_slice_max_bit_rate_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (ran_paging_prio_present) {
    HANDLE_CODE(ran_paging_prio.pack(bref));
  }
  if (nas_pdu_present) {
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  HANDLE_CODE(pdu_session_res_setup_list_su_req.pack(bref));
  if (ue_aggr_max_bit_rate_present) {
    HANDLE_CODE(ue_aggr_max_bit_rate.pack(bref));
  }
  if (ue_slice_max_bit_rate_list_present) {
    HANDLE_CODE(ue_slice_max_bit_rate_list.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 83: {
        ran_paging_prio_present = true;
        ran_paging_prio.id      = id;
        HANDLE_CODE(ran_paging_prio.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_paging_prio.value.unpack(bref));
        break;
      }
      case 38: {
        nas_pdu_present = true;
        nas_pdu.id      = id;
        HANDLE_CODE(nas_pdu.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.value.unpack(bref));
        break;
      }
      case 74: {
        nof_mandatory_ies--;
        pdu_session_res_setup_list_su_req.id = id;
        HANDLE_CODE(pdu_session_res_setup_list_su_req.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_setup_list_su_req.value.unpack(bref));
        break;
      }
      case 110: {
        ue_aggr_max_bit_rate_present = true;
        ue_aggr_max_bit_rate.id      = id;
        HANDLE_CODE(ue_aggr_max_bit_rate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_aggr_max_bit_rate.value.unpack(bref));
        break;
      }
      case 335: {
        ue_slice_max_bit_rate_list_present = true;
        ue_slice_max_bit_rate_list.id      = id;
        HANDLE_CODE(ue_slice_max_bit_rate_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_slice_max_bit_rate_list.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (ran_paging_prio_present) {
    j.write_fieldname("");
    ran_paging_prio.to_json(j);
  }
  if (nas_pdu_present) {
    j.write_fieldname("");
    nas_pdu.to_json(j);
  }
  j.write_fieldname("");
  pdu_session_res_setup_list_su_req.to_json(j);
  if (ue_aggr_max_bit_rate_present) {
    j.write_fieldname("");
    ue_aggr_max_bit_rate.to_json(j);
  }
  if (ue_slice_max_bit_rate_list_present) {
    j.write_fieldname("");
    ue_slice_max_bit_rate_list.to_json(j);
  }
  j.end_obj();
}

pdu_session_res_setup_resp_ies_container::pdu_session_res_setup_resp_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  pdu_session_res_setup_list_su_res(75, crit_e::ignore),
  pdu_session_res_failed_to_setup_list_su_res(58, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore),
  user_location_info(121, crit_e::ignore)
{
}
SRSASN_CODE pdu_session_res_setup_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += pdu_session_res_setup_list_su_res_present ? 1 : 0;
  nof_ies += pdu_session_res_failed_to_setup_list_su_res_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (pdu_session_res_setup_list_su_res_present) {
    HANDLE_CODE(pdu_session_res_setup_list_su_res.pack(bref));
  }
  if (pdu_session_res_failed_to_setup_list_su_res_present) {
    HANDLE_CODE(pdu_session_res_failed_to_setup_list_su_res.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (user_location_info_present) {
    HANDLE_CODE(user_location_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 75: {
        pdu_session_res_setup_list_su_res_present = true;
        pdu_session_res_setup_list_su_res.id      = id;
        HANDLE_CODE(pdu_session_res_setup_list_su_res.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_setup_list_su_res.value.unpack(bref));
        break;
      }
      case 58: {
        pdu_session_res_failed_to_setup_list_su_res_present = true;
        pdu_session_res_failed_to_setup_list_su_res.id      = id;
        HANDLE_CODE(pdu_session_res_failed_to_setup_list_su_res.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_failed_to_setup_list_su_res.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      case 121: {
        user_location_info_present = true;
        user_location_info.id      = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (pdu_session_res_setup_list_su_res_present) {
    j.write_fieldname("");
    pdu_session_res_setup_list_su_res.to_json(j);
  }
  if (pdu_session_res_failed_to_setup_list_su_res_present) {
    j.write_fieldname("");
    pdu_session_res_failed_to_setup_list_su_res.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (user_location_info_present) {
    j.write_fieldname("");
    user_location_info.to_json(j);
  }
  j.end_obj();
}

pws_cancel_request_ies_container::pws_cancel_request_ies_container() :
  msg_id(35, crit_e::reject),
  serial_num(95, crit_e::reject),
  warning_area_list(122, crit_e::ignore),
  cancel_all_warning_msgs(14, crit_e::reject)
{
}
SRSASN_CODE pws_cancel_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += warning_area_list_present ? 1 : 0;
  nof_ies += cancel_all_warning_msgs_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(msg_id.pack(bref));
  HANDLE_CODE(serial_num.pack(bref));
  if (warning_area_list_present) {
    HANDLE_CODE(warning_area_list.pack(bref));
  }
  if (cancel_all_warning_msgs_present) {
    HANDLE_CODE(cancel_all_warning_msgs.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_cancel_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 35: {
        nof_mandatory_ies--;
        msg_id.id = id;
        HANDLE_CODE(msg_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(msg_id.value.unpack(bref));
        break;
      }
      case 95: {
        nof_mandatory_ies--;
        serial_num.id = id;
        HANDLE_CODE(serial_num.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(serial_num.value.unpack(bref));
        break;
      }
      case 122: {
        warning_area_list_present = true;
        warning_area_list.id      = id;
        HANDLE_CODE(warning_area_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(warning_area_list.value.unpack(bref));
        break;
      }
      case 14: {
        cancel_all_warning_msgs_present = true;
        cancel_all_warning_msgs.id      = id;
        HANDLE_CODE(cancel_all_warning_msgs.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cancel_all_warning_msgs.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pws_cancel_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  msg_id.to_json(j);
  j.write_fieldname("");
  serial_num.to_json(j);
  if (warning_area_list_present) {
    j.write_fieldname("");
    warning_area_list.to_json(j);
  }
  if (cancel_all_warning_msgs_present) {
    j.write_fieldname("");
    cancel_all_warning_msgs.to_json(j);
  }
  j.end_obj();
}

pws_cancel_resp_ies_container::pws_cancel_resp_ies_container() :
  msg_id(35, crit_e::reject),
  serial_num(95, crit_e::reject),
  broadcast_cancelled_area_list(12, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE pws_cancel_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += broadcast_cancelled_area_list_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(msg_id.pack(bref));
  HANDLE_CODE(serial_num.pack(bref));
  if (broadcast_cancelled_area_list_present) {
    HANDLE_CODE(broadcast_cancelled_area_list.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_cancel_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 35: {
        nof_mandatory_ies--;
        msg_id.id = id;
        HANDLE_CODE(msg_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(msg_id.value.unpack(bref));
        break;
      }
      case 95: {
        nof_mandatory_ies--;
        serial_num.id = id;
        HANDLE_CODE(serial_num.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(serial_num.value.unpack(bref));
        break;
      }
      case 12: {
        broadcast_cancelled_area_list_present = true;
        broadcast_cancelled_area_list.id      = id;
        HANDLE_CODE(broadcast_cancelled_area_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(broadcast_cancelled_area_list.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pws_cancel_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  msg_id.to_json(j);
  j.write_fieldname("");
  serial_num.to_json(j);
  if (broadcast_cancelled_area_list_present) {
    j.write_fieldname("");
    broadcast_cancelled_area_list.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

pws_fail_ind_ies_container::pws_fail_ind_ies_container() :
  pws_failed_cell_id_list(81, crit_e::reject), global_ran_node_id(27, crit_e::reject)
{
}
SRSASN_CODE pws_fail_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(pws_failed_cell_id_list.pack(bref));
  HANDLE_CODE(global_ran_node_id.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_fail_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 81: {
        nof_mandatory_ies--;
        pws_failed_cell_id_list.id = id;
        HANDLE_CODE(pws_failed_cell_id_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pws_failed_cell_id_list.value.unpack(bref));
        break;
      }
      case 27: {
        nof_mandatory_ies--;
        global_ran_node_id.id = id;
        HANDLE_CODE(global_ran_node_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(global_ran_node_id.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pws_fail_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  pws_failed_cell_id_list.to_json(j);
  j.write_fieldname("");
  global_ran_node_id.to_json(j);
  j.end_obj();
}

pws_restart_ind_ies_container::pws_restart_ind_ies_container() :
  cell_id_list_for_restart(16, crit_e::reject),
  global_ran_node_id(27, crit_e::reject),
  tai_list_for_restart(104, crit_e::reject),
  emergency_area_id_list_for_restart(23, crit_e::reject)
{
}
SRSASN_CODE pws_restart_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += emergency_area_id_list_for_restart_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(cell_id_list_for_restart.pack(bref));
  HANDLE_CODE(global_ran_node_id.pack(bref));
  HANDLE_CODE(tai_list_for_restart.pack(bref));
  if (emergency_area_id_list_for_restart_present) {
    HANDLE_CODE(emergency_area_id_list_for_restart.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_restart_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 16: {
        nof_mandatory_ies--;
        cell_id_list_for_restart.id = id;
        HANDLE_CODE(cell_id_list_for_restart.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cell_id_list_for_restart.value.unpack(bref));
        break;
      }
      case 27: {
        nof_mandatory_ies--;
        global_ran_node_id.id = id;
        HANDLE_CODE(global_ran_node_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(global_ran_node_id.value.unpack(bref));
        break;
      }
      case 104: {
        nof_mandatory_ies--;
        tai_list_for_restart.id = id;
        HANDLE_CODE(tai_list_for_restart.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tai_list_for_restart.value.unpack(bref));
        break;
      }
      case 23: {
        emergency_area_id_list_for_restart_present = true;
        emergency_area_id_list_for_restart.id      = id;
        HANDLE_CODE(emergency_area_id_list_for_restart.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(emergency_area_id_list_for_restart.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pws_restart_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  cell_id_list_for_restart.to_json(j);
  j.write_fieldname("");
  global_ran_node_id.to_json(j);
  j.write_fieldname("");
  tai_list_for_restart.to_json(j);
  if (emergency_area_id_list_for_restart_present) {
    j.write_fieldname("");
    emergency_area_id_list_for_restart.to_json(j);
  }
  j.end_obj();
}

paging_ies_container::paging_ies_container() :
  ue_paging_id(115, crit_e::ignore),
  paging_drx(50, crit_e::ignore),
  tai_list_for_paging(103, crit_e::ignore),
  paging_prio(52, crit_e::ignore),
  ue_radio_cap_for_paging(118, crit_e::ignore),
  paging_origin(51, crit_e::ignore),
  assist_data_for_paging(11, crit_e::ignore),
  nb_iot_paging_e_drx_info(203, crit_e::ignore),
  nb_iot_paging_drx(202, crit_e::ignore),
  enhanced_coverage_restrict(205, crit_e::ignore),
  wus_assist_info(208, crit_e::ignore),
  eutra_paginge_drx_info(223, crit_e::ignore),
  ce_mode_brestricted(222, crit_e::ignore),
  nr_paginge_drx_info(332, crit_e::ignore),
  paging_cause(342, crit_e::ignore),
  pe_ip_sassist_info(344, crit_e::ignore)
{
}
SRSASN_CODE paging_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += paging_drx_present ? 1 : 0;
  nof_ies += paging_prio_present ? 1 : 0;
  nof_ies += ue_radio_cap_for_paging_present ? 1 : 0;
  nof_ies += paging_origin_present ? 1 : 0;
  nof_ies += assist_data_for_paging_present ? 1 : 0;
  nof_ies += nb_iot_paging_e_drx_info_present ? 1 : 0;
  nof_ies += nb_iot_paging_drx_present ? 1 : 0;
  nof_ies += enhanced_coverage_restrict_present ? 1 : 0;
  nof_ies += wus_assist_info_present ? 1 : 0;
  nof_ies += eutra_paginge_drx_info_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += nr_paginge_drx_info_present ? 1 : 0;
  nof_ies += paging_cause_present ? 1 : 0;
  nof_ies += pe_ip_sassist_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(ue_paging_id.pack(bref));
  if (paging_drx_present) {
    HANDLE_CODE(paging_drx.pack(bref));
  }
  HANDLE_CODE(tai_list_for_paging.pack(bref));
  if (paging_prio_present) {
    HANDLE_CODE(paging_prio.pack(bref));
  }
  if (ue_radio_cap_for_paging_present) {
    HANDLE_CODE(ue_radio_cap_for_paging.pack(bref));
  }
  if (paging_origin_present) {
    HANDLE_CODE(paging_origin.pack(bref));
  }
  if (assist_data_for_paging_present) {
    HANDLE_CODE(assist_data_for_paging.pack(bref));
  }
  if (nb_iot_paging_e_drx_info_present) {
    HANDLE_CODE(nb_iot_paging_e_drx_info.pack(bref));
  }
  if (nb_iot_paging_drx_present) {
    HANDLE_CODE(nb_iot_paging_drx.pack(bref));
  }
  if (enhanced_coverage_restrict_present) {
    HANDLE_CODE(enhanced_coverage_restrict.pack(bref));
  }
  if (wus_assist_info_present) {
    HANDLE_CODE(wus_assist_info.pack(bref));
  }
  if (eutra_paginge_drx_info_present) {
    HANDLE_CODE(eutra_paginge_drx_info.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (nr_paginge_drx_info_present) {
    HANDLE_CODE(nr_paginge_drx_info.pack(bref));
  }
  if (paging_cause_present) {
    HANDLE_CODE(paging_cause.pack(bref));
  }
  if (pe_ip_sassist_info_present) {
    HANDLE_CODE(pe_ip_sassist_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE paging_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 115: {
        nof_mandatory_ies--;
        ue_paging_id.id = id;
        HANDLE_CODE(ue_paging_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_paging_id.value.unpack(bref));
        break;
      }
      case 50: {
        paging_drx_present = true;
        paging_drx.id      = id;
        HANDLE_CODE(paging_drx.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_drx.value.unpack(bref));
        break;
      }
      case 103: {
        nof_mandatory_ies--;
        tai_list_for_paging.id = id;
        HANDLE_CODE(tai_list_for_paging.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tai_list_for_paging.value.unpack(bref));
        break;
      }
      case 52: {
        paging_prio_present = true;
        paging_prio.id      = id;
        HANDLE_CODE(paging_prio.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_prio.value.unpack(bref));
        break;
      }
      case 118: {
        ue_radio_cap_for_paging_present = true;
        ue_radio_cap_for_paging.id      = id;
        HANDLE_CODE(ue_radio_cap_for_paging.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_for_paging.value.unpack(bref));
        break;
      }
      case 51: {
        paging_origin_present = true;
        paging_origin.id      = id;
        HANDLE_CODE(paging_origin.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_origin.value.unpack(bref));
        break;
      }
      case 11: {
        assist_data_for_paging_present = true;
        assist_data_for_paging.id      = id;
        HANDLE_CODE(assist_data_for_paging.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(assist_data_for_paging.value.unpack(bref));
        break;
      }
      case 203: {
        nb_iot_paging_e_drx_info_present = true;
        nb_iot_paging_e_drx_info.id      = id;
        HANDLE_CODE(nb_iot_paging_e_drx_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nb_iot_paging_e_drx_info.value.unpack(bref));
        break;
      }
      case 202: {
        nb_iot_paging_drx_present = true;
        nb_iot_paging_drx.id      = id;
        HANDLE_CODE(nb_iot_paging_drx.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nb_iot_paging_drx.value.unpack(bref));
        break;
      }
      case 205: {
        enhanced_coverage_restrict_present = true;
        enhanced_coverage_restrict.id      = id;
        HANDLE_CODE(enhanced_coverage_restrict.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(enhanced_coverage_restrict.value.unpack(bref));
        break;
      }
      case 208: {
        wus_assist_info_present = true;
        wus_assist_info.id      = id;
        HANDLE_CODE(wus_assist_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(wus_assist_info.value.unpack(bref));
        break;
      }
      case 223: {
        eutra_paginge_drx_info_present = true;
        eutra_paginge_drx_info.id      = id;
        HANDLE_CODE(eutra_paginge_drx_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(eutra_paginge_drx_info.value.unpack(bref));
        break;
      }
      case 222: {
        ce_mode_brestricted_present = true;
        ce_mode_brestricted.id      = id;
        HANDLE_CODE(ce_mode_brestricted.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_brestricted.value.unpack(bref));
        break;
      }
      case 332: {
        nr_paginge_drx_info_present = true;
        nr_paginge_drx_info.id      = id;
        HANDLE_CODE(nr_paginge_drx_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_paginge_drx_info.value.unpack(bref));
        break;
      }
      case 342: {
        paging_cause_present = true;
        paging_cause.id      = id;
        HANDLE_CODE(paging_cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_cause.value.unpack(bref));
        break;
      }
      case 344: {
        pe_ip_sassist_info_present = true;
        pe_ip_sassist_info.id      = id;
        HANDLE_CODE(pe_ip_sassist_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pe_ip_sassist_info.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void paging_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  ue_paging_id.to_json(j);
  if (paging_drx_present) {
    j.write_fieldname("");
    paging_drx.to_json(j);
  }
  j.write_fieldname("");
  tai_list_for_paging.to_json(j);
  if (paging_prio_present) {
    j.write_fieldname("");
    paging_prio.to_json(j);
  }
  if (ue_radio_cap_for_paging_present) {
    j.write_fieldname("");
    ue_radio_cap_for_paging.to_json(j);
  }
  if (paging_origin_present) {
    j.write_fieldname("");
    paging_origin.to_json(j);
  }
  if (assist_data_for_paging_present) {
    j.write_fieldname("");
    assist_data_for_paging.to_json(j);
  }
  if (nb_iot_paging_e_drx_info_present) {
    j.write_fieldname("");
    nb_iot_paging_e_drx_info.to_json(j);
  }
  if (nb_iot_paging_drx_present) {
    j.write_fieldname("");
    nb_iot_paging_drx.to_json(j);
  }
  if (enhanced_coverage_restrict_present) {
    j.write_fieldname("");
    enhanced_coverage_restrict.to_json(j);
  }
  if (wus_assist_info_present) {
    j.write_fieldname("");
    wus_assist_info.to_json(j);
  }
  if (eutra_paginge_drx_info_present) {
    j.write_fieldname("");
    eutra_paginge_drx_info.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_fieldname("");
    ce_mode_brestricted.to_json(j);
  }
  if (nr_paginge_drx_info_present) {
    j.write_fieldname("");
    nr_paginge_drx_info.to_json(j);
  }
  if (paging_cause_present) {
    j.write_fieldname("");
    paging_cause.to_json(j);
  }
  if (pe_ip_sassist_info_present) {
    j.write_fieldname("");
    pe_ip_sassist_info.to_json(j);
  }
  j.end_obj();
}

path_switch_request_ies_container::path_switch_request_ies_container() :
  ran_ue_ngap_id(85, crit_e::reject),
  source_amf_ue_ngap_id(100, crit_e::reject),
  user_location_info(121, crit_e::ignore),
  ue_security_cap(119, crit_e::ignore),
  pdu_session_res_to_be_switched_dl_list(76, crit_e::reject),
  pdu_session_res_failed_to_setup_list_ps_req(57, crit_e::ignore),
  rrc_resume_cause(237, crit_e::ignore),
  red_cap_ind(333, crit_e::ignore)
{
}
SRSASN_CODE path_switch_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 5;
  nof_ies += pdu_session_res_failed_to_setup_list_ps_req_present ? 1 : 0;
  nof_ies += rrc_resume_cause_present ? 1 : 0;
  nof_ies += red_cap_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(source_amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(user_location_info.pack(bref));
  HANDLE_CODE(ue_security_cap.pack(bref));
  HANDLE_CODE(pdu_session_res_to_be_switched_dl_list.pack(bref));
  if (pdu_session_res_failed_to_setup_list_ps_req_present) {
    HANDLE_CODE(pdu_session_res_failed_to_setup_list_ps_req.pack(bref));
  }
  if (rrc_resume_cause_present) {
    HANDLE_CODE(rrc_resume_cause.pack(bref));
  }
  if (red_cap_ind_present) {
    HANDLE_CODE(red_cap_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 5;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 100: {
        nof_mandatory_ies--;
        source_amf_ue_ngap_id.id = id;
        HANDLE_CODE(source_amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 121: {
        nof_mandatory_ies--;
        user_location_info.id = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      case 119: {
        nof_mandatory_ies--;
        ue_security_cap.id = id;
        HANDLE_CODE(ue_security_cap.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_security_cap.value.unpack(bref));
        break;
      }
      case 76: {
        nof_mandatory_ies--;
        pdu_session_res_to_be_switched_dl_list.id = id;
        HANDLE_CODE(pdu_session_res_to_be_switched_dl_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_to_be_switched_dl_list.value.unpack(bref));
        break;
      }
      case 57: {
        pdu_session_res_failed_to_setup_list_ps_req_present = true;
        pdu_session_res_failed_to_setup_list_ps_req.id      = id;
        HANDLE_CODE(pdu_session_res_failed_to_setup_list_ps_req.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_failed_to_setup_list_ps_req.value.unpack(bref));
        break;
      }
      case 237: {
        rrc_resume_cause_present = true;
        rrc_resume_cause.id      = id;
        HANDLE_CODE(rrc_resume_cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_resume_cause.value.unpack(bref));
        break;
      }
      case 333: {
        red_cap_ind_present = true;
        red_cap_ind.id      = id;
        HANDLE_CODE(red_cap_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(red_cap_ind.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void path_switch_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  source_amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  user_location_info.to_json(j);
  j.write_fieldname("");
  ue_security_cap.to_json(j);
  j.write_fieldname("");
  pdu_session_res_to_be_switched_dl_list.to_json(j);
  if (pdu_session_res_failed_to_setup_list_ps_req_present) {
    j.write_fieldname("");
    pdu_session_res_failed_to_setup_list_ps_req.to_json(j);
  }
  if (rrc_resume_cause_present) {
    j.write_fieldname("");
    rrc_resume_cause.to_json(j);
  }
  if (red_cap_ind_present) {
    j.write_fieldname("");
    red_cap_ind.to_json(j);
  }
  j.end_obj();
}

path_switch_request_ack_ies_container::path_switch_request_ack_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  ue_security_cap(119, crit_e::reject),
  security_context(93, crit_e::reject),
  new_security_context_ind(41, crit_e::reject),
  pdu_session_res_switched_list(77, crit_e::ignore),
  pdu_session_res_released_list_ps_ack(68, crit_e::ignore),
  allowed_nssai(0, crit_e::reject),
  core_network_assist_info_for_inactive(18, crit_e::ignore),
  rrc_inactive_transition_report_request(91, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore),
  redirection_voice_fallback(146, crit_e::ignore),
  cn_assisted_ran_tuning(165, crit_e::ignore),
  srvcc_operation_possible(177, crit_e::ignore),
  enhanced_coverage_restrict(205, crit_e::ignore),
  extended_connected_time(206, crit_e::ignore),
  ue_diff_info(209, crit_e::ignore),
  nr_v2x_services_authorized(216, crit_e::ignore),
  ltev2x_services_authorized(215, crit_e::ignore),
  nr_ue_sidelink_aggr_max_bitrate(218, crit_e::ignore),
  lte_ue_sidelink_aggr_max_bitrate(217, crit_e::ignore),
  pc5_qos_params(219, crit_e::ignore),
  ce_mode_brestricted(222, crit_e::ignore),
  ue_up_c_iot_support(234, crit_e::ignore),
  ue_radio_cap_id(264, crit_e::reject),
  management_based_mdt_plmn_list(254, crit_e::ignore),
  time_sync_assist_info(326, crit_e::ignore),
  five_g_pro_se_authorized(345, crit_e::ignore),
  five_g_pro_se_ue_pc5_aggr_max_bit_rate(346, crit_e::ignore),
  five_g_pro_se_pc5_qos_params(347, crit_e::ignore),
  management_based_mdt_plmn_mod_list(359, crit_e::ignore)
{
}
SRSASN_CODE path_switch_request_ack_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 5;
  nof_ies += ue_security_cap_present ? 1 : 0;
  nof_ies += new_security_context_ind_present ? 1 : 0;
  nof_ies += pdu_session_res_released_list_ps_ack_present ? 1 : 0;
  nof_ies += core_network_assist_info_for_inactive_present ? 1 : 0;
  nof_ies += rrc_inactive_transition_report_request_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += redirection_voice_fallback_present ? 1 : 0;
  nof_ies += cn_assisted_ran_tuning_present ? 1 : 0;
  nof_ies += srvcc_operation_possible_present ? 1 : 0;
  nof_ies += enhanced_coverage_restrict_present ? 1 : 0;
  nof_ies += extended_connected_time_present ? 1 : 0;
  nof_ies += ue_diff_info_present ? 1 : 0;
  nof_ies += nr_v2x_services_authorized_present ? 1 : 0;
  nof_ies += ltev2x_services_authorized_present ? 1 : 0;
  nof_ies += nr_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += lte_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += pc5_qos_params_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += ue_up_c_iot_support_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += management_based_mdt_plmn_list_present ? 1 : 0;
  nof_ies += time_sync_assist_info_present ? 1 : 0;
  nof_ies += five_g_pro_se_authorized_present ? 1 : 0;
  nof_ies += five_g_pro_se_ue_pc5_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += five_g_pro_se_pc5_qos_params_present ? 1 : 0;
  nof_ies += management_based_mdt_plmn_mod_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (ue_security_cap_present) {
    HANDLE_CODE(ue_security_cap.pack(bref));
  }
  HANDLE_CODE(security_context.pack(bref));
  if (new_security_context_ind_present) {
    HANDLE_CODE(new_security_context_ind.pack(bref));
  }
  HANDLE_CODE(pdu_session_res_switched_list.pack(bref));
  if (pdu_session_res_released_list_ps_ack_present) {
    HANDLE_CODE(pdu_session_res_released_list_ps_ack.pack(bref));
  }
  HANDLE_CODE(allowed_nssai.pack(bref));
  if (core_network_assist_info_for_inactive_present) {
    HANDLE_CODE(core_network_assist_info_for_inactive.pack(bref));
  }
  if (rrc_inactive_transition_report_request_present) {
    HANDLE_CODE(rrc_inactive_transition_report_request.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (redirection_voice_fallback_present) {
    HANDLE_CODE(redirection_voice_fallback.pack(bref));
  }
  if (cn_assisted_ran_tuning_present) {
    HANDLE_CODE(cn_assisted_ran_tuning.pack(bref));
  }
  if (srvcc_operation_possible_present) {
    HANDLE_CODE(srvcc_operation_possible.pack(bref));
  }
  if (enhanced_coverage_restrict_present) {
    HANDLE_CODE(enhanced_coverage_restrict.pack(bref));
  }
  if (extended_connected_time_present) {
    HANDLE_CODE(extended_connected_time.pack(bref));
  }
  if (ue_diff_info_present) {
    HANDLE_CODE(ue_diff_info.pack(bref));
  }
  if (nr_v2x_services_authorized_present) {
    HANDLE_CODE(nr_v2x_services_authorized.pack(bref));
  }
  if (ltev2x_services_authorized_present) {
    HANDLE_CODE(ltev2x_services_authorized.pack(bref));
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (pc5_qos_params_present) {
    HANDLE_CODE(pc5_qos_params.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (ue_up_c_iot_support_present) {
    HANDLE_CODE(ue_up_c_iot_support.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (management_based_mdt_plmn_list_present) {
    HANDLE_CODE(management_based_mdt_plmn_list.pack(bref));
  }
  if (time_sync_assist_info_present) {
    HANDLE_CODE(time_sync_assist_info.pack(bref));
  }
  if (five_g_pro_se_authorized_present) {
    HANDLE_CODE(five_g_pro_se_authorized.pack(bref));
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.pack(bref));
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    HANDLE_CODE(five_g_pro_se_pc5_qos_params.pack(bref));
  }
  if (management_based_mdt_plmn_mod_list_present) {
    HANDLE_CODE(management_based_mdt_plmn_mod_list.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ack_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 5;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 119: {
        ue_security_cap_present = true;
        ue_security_cap.id      = id;
        HANDLE_CODE(ue_security_cap.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_security_cap.value.unpack(bref));
        break;
      }
      case 93: {
        nof_mandatory_ies--;
        security_context.id = id;
        HANDLE_CODE(security_context.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_context.value.unpack(bref));
        break;
      }
      case 41: {
        new_security_context_ind_present = true;
        new_security_context_ind.id      = id;
        HANDLE_CODE(new_security_context_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(new_security_context_ind.value.unpack(bref));
        break;
      }
      case 77: {
        nof_mandatory_ies--;
        pdu_session_res_switched_list.id = id;
        HANDLE_CODE(pdu_session_res_switched_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_switched_list.value.unpack(bref));
        break;
      }
      case 68: {
        pdu_session_res_released_list_ps_ack_present = true;
        pdu_session_res_released_list_ps_ack.id      = id;
        HANDLE_CODE(pdu_session_res_released_list_ps_ack.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_released_list_ps_ack.value.unpack(bref));
        break;
      }
      case 0: {
        nof_mandatory_ies--;
        allowed_nssai.id = id;
        HANDLE_CODE(allowed_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(allowed_nssai.value.unpack(bref));
        break;
      }
      case 18: {
        core_network_assist_info_for_inactive_present = true;
        core_network_assist_info_for_inactive.id      = id;
        HANDLE_CODE(core_network_assist_info_for_inactive.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(core_network_assist_info_for_inactive.value.unpack(bref));
        break;
      }
      case 91: {
        rrc_inactive_transition_report_request_present = true;
        rrc_inactive_transition_report_request.id      = id;
        HANDLE_CODE(rrc_inactive_transition_report_request.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_inactive_transition_report_request.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      case 146: {
        redirection_voice_fallback_present = true;
        redirection_voice_fallback.id      = id;
        HANDLE_CODE(redirection_voice_fallback.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redirection_voice_fallback.value.unpack(bref));
        break;
      }
      case 165: {
        cn_assisted_ran_tuning_present = true;
        cn_assisted_ran_tuning.id      = id;
        HANDLE_CODE(cn_assisted_ran_tuning.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_assisted_ran_tuning.value.unpack(bref));
        break;
      }
      case 177: {
        srvcc_operation_possible_present = true;
        srvcc_operation_possible.id      = id;
        HANDLE_CODE(srvcc_operation_possible.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(srvcc_operation_possible.value.unpack(bref));
        break;
      }
      case 205: {
        enhanced_coverage_restrict_present = true;
        enhanced_coverage_restrict.id      = id;
        HANDLE_CODE(enhanced_coverage_restrict.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(enhanced_coverage_restrict.value.unpack(bref));
        break;
      }
      case 206: {
        extended_connected_time_present = true;
        extended_connected_time.id      = id;
        HANDLE_CODE(extended_connected_time.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_connected_time.value.unpack(bref));
        break;
      }
      case 209: {
        ue_diff_info_present = true;
        ue_diff_info.id      = id;
        HANDLE_CODE(ue_diff_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_diff_info.value.unpack(bref));
        break;
      }
      case 216: {
        nr_v2x_services_authorized_present = true;
        nr_v2x_services_authorized.id      = id;
        HANDLE_CODE(nr_v2x_services_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_v2x_services_authorized.value.unpack(bref));
        break;
      }
      case 215: {
        ltev2x_services_authorized_present = true;
        ltev2x_services_authorized.id      = id;
        HANDLE_CODE(ltev2x_services_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ltev2x_services_authorized.value.unpack(bref));
        break;
      }
      case 218: {
        nr_ue_sidelink_aggr_max_bitrate_present = true;
        nr_ue_sidelink_aggr_max_bitrate.id      = id;
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.value.unpack(bref));
        break;
      }
      case 217: {
        lte_ue_sidelink_aggr_max_bitrate_present = true;
        lte_ue_sidelink_aggr_max_bitrate.id      = id;
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.value.unpack(bref));
        break;
      }
      case 219: {
        pc5_qos_params_present = true;
        pc5_qos_params.id      = id;
        HANDLE_CODE(pc5_qos_params.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pc5_qos_params.value.unpack(bref));
        break;
      }
      case 222: {
        ce_mode_brestricted_present = true;
        ce_mode_brestricted.id      = id;
        HANDLE_CODE(ce_mode_brestricted.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_brestricted.value.unpack(bref));
        break;
      }
      case 234: {
        ue_up_c_iot_support_present = true;
        ue_up_c_iot_support.id      = id;
        HANDLE_CODE(ue_up_c_iot_support.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_up_c_iot_support.value.unpack(bref));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        ue_radio_cap_id.id      = id;
        HANDLE_CODE(ue_radio_cap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.value.unpack(bref));
        break;
      }
      case 254: {
        management_based_mdt_plmn_list_present = true;
        management_based_mdt_plmn_list.id      = id;
        HANDLE_CODE(management_based_mdt_plmn_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(management_based_mdt_plmn_list.value.unpack(bref));
        break;
      }
      case 326: {
        time_sync_assist_info_present = true;
        time_sync_assist_info.id      = id;
        HANDLE_CODE(time_sync_assist_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_sync_assist_info.value.unpack(bref));
        break;
      }
      case 345: {
        five_g_pro_se_authorized_present = true;
        five_g_pro_se_authorized.id      = id;
        HANDLE_CODE(five_g_pro_se_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_authorized.value.unpack(bref));
        break;
      }
      case 346: {
        five_g_pro_se_ue_pc5_aggr_max_bit_rate_present = true;
        five_g_pro_se_ue_pc5_aggr_max_bit_rate.id      = id;
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.value.unpack(bref));
        break;
      }
      case 347: {
        five_g_pro_se_pc5_qos_params_present = true;
        five_g_pro_se_pc5_qos_params.id      = id;
        HANDLE_CODE(five_g_pro_se_pc5_qos_params.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_pc5_qos_params.value.unpack(bref));
        break;
      }
      case 359: {
        management_based_mdt_plmn_mod_list_present = true;
        management_based_mdt_plmn_mod_list.id      = id;
        HANDLE_CODE(management_based_mdt_plmn_mod_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(management_based_mdt_plmn_mod_list.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void path_switch_request_ack_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (ue_security_cap_present) {
    j.write_fieldname("");
    ue_security_cap.to_json(j);
  }
  j.write_fieldname("");
  security_context.to_json(j);
  if (new_security_context_ind_present) {
    j.write_fieldname("");
    new_security_context_ind.to_json(j);
  }
  j.write_fieldname("");
  pdu_session_res_switched_list.to_json(j);
  if (pdu_session_res_released_list_ps_ack_present) {
    j.write_fieldname("");
    pdu_session_res_released_list_ps_ack.to_json(j);
  }
  j.write_fieldname("");
  allowed_nssai.to_json(j);
  if (core_network_assist_info_for_inactive_present) {
    j.write_fieldname("");
    core_network_assist_info_for_inactive.to_json(j);
  }
  if (rrc_inactive_transition_report_request_present) {
    j.write_fieldname("");
    rrc_inactive_transition_report_request.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (redirection_voice_fallback_present) {
    j.write_fieldname("");
    redirection_voice_fallback.to_json(j);
  }
  if (cn_assisted_ran_tuning_present) {
    j.write_fieldname("");
    cn_assisted_ran_tuning.to_json(j);
  }
  if (srvcc_operation_possible_present) {
    j.write_fieldname("");
    srvcc_operation_possible.to_json(j);
  }
  if (enhanced_coverage_restrict_present) {
    j.write_fieldname("");
    enhanced_coverage_restrict.to_json(j);
  }
  if (extended_connected_time_present) {
    j.write_fieldname("");
    extended_connected_time.to_json(j);
  }
  if (ue_diff_info_present) {
    j.write_fieldname("");
    ue_diff_info.to_json(j);
  }
  if (nr_v2x_services_authorized_present) {
    j.write_fieldname("");
    nr_v2x_services_authorized.to_json(j);
  }
  if (ltev2x_services_authorized_present) {
    j.write_fieldname("");
    ltev2x_services_authorized.to_json(j);
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    j.write_fieldname("");
    nr_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    j.write_fieldname("");
    lte_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (pc5_qos_params_present) {
    j.write_fieldname("");
    pc5_qos_params.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_fieldname("");
    ce_mode_brestricted.to_json(j);
  }
  if (ue_up_c_iot_support_present) {
    j.write_fieldname("");
    ue_up_c_iot_support.to_json(j);
  }
  if (ue_radio_cap_id_present) {
    j.write_fieldname("");
    ue_radio_cap_id.to_json(j);
  }
  if (management_based_mdt_plmn_list_present) {
    j.write_fieldname("");
    management_based_mdt_plmn_list.to_json(j);
  }
  if (time_sync_assist_info_present) {
    j.write_fieldname("");
    time_sync_assist_info.to_json(j);
  }
  if (five_g_pro_se_authorized_present) {
    j.write_fieldname("");
    five_g_pro_se_authorized.to_json(j);
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    j.write_fieldname("");
    five_g_pro_se_ue_pc5_aggr_max_bit_rate.to_json(j);
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    j.write_fieldname("");
    five_g_pro_se_pc5_qos_params.to_json(j);
  }
  if (management_based_mdt_plmn_mod_list_present) {
    j.write_fieldname("");
    management_based_mdt_plmn_mod_list.to_json(j);
  }
  j.end_obj();
}

path_switch_request_fail_ies_container::path_switch_request_fail_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  pdu_session_res_released_list_ps_fail(69, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE path_switch_request_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(pdu_session_res_released_list_ps_fail.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 69: {
        nof_mandatory_ies--;
        pdu_session_res_released_list_ps_fail.id = id;
        HANDLE_CODE(pdu_session_res_released_list_ps_fail.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_released_list_ps_fail.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void path_switch_request_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  pdu_session_res_released_list_ps_fail.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE private_ie_container_empty_l::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  return SRSASN_SUCCESS;
}
SRSASN_CODE private_ie_container_empty_l::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);
  if (nof_ies > 0) {
    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void private_ie_container_empty_l::to_json(json_writer& j) const
{
  j.start_obj();
  j.end_obj();
}

// PrivateMessage ::= SEQUENCE
SRSASN_CODE private_msg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(private_ies.pack(bref));

  bref.align_bytes_zero();

  return SRSASN_SUCCESS;
}
SRSASN_CODE private_msg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(private_ies.unpack(bref));

  bref.align_bytes();

  return SRSASN_SUCCESS;
}
void private_msg_s::to_json(json_writer& j) const
{
  j.start_array();
  j.start_obj();
  j.start_obj("PrivateMessage");
  j.write_fieldname("privateIEs");
  private_ies.to_json(j);
  j.end_obj();
  j.end_obj();
  j.end_array();
}

ran_cp_relocation_ind_ies_container::ran_cp_relocation_ind_ies_container() :
  ran_ue_ngap_id(85, crit_e::reject),
  five_g_s_tmsi(26, crit_e::reject),
  eutra_cgi(25, crit_e::ignore),
  tai(213, crit_e::ignore),
  ul_cp_security_info(211, crit_e::reject)
{
}
SRSASN_CODE ran_cp_relocation_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 5;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(five_g_s_tmsi.pack(bref));
  HANDLE_CODE(eutra_cgi.pack(bref));
  HANDLE_CODE(tai.pack(bref));
  HANDLE_CODE(ul_cp_security_info.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cp_relocation_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 5;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 26: {
        nof_mandatory_ies--;
        five_g_s_tmsi.id = id;
        HANDLE_CODE(five_g_s_tmsi.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_s_tmsi.value.unpack(bref));
        break;
      }
      case 25: {
        nof_mandatory_ies--;
        eutra_cgi.id = id;
        HANDLE_CODE(eutra_cgi.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(eutra_cgi.value.unpack(bref));
        break;
      }
      case 213: {
        nof_mandatory_ies--;
        tai.id = id;
        HANDLE_CODE(tai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tai.value.unpack(bref));
        break;
      }
      case 211: {
        nof_mandatory_ies--;
        ul_cp_security_info.id = id;
        HANDLE_CODE(ul_cp_security_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ul_cp_security_info.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ran_cp_relocation_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  five_g_s_tmsi.to_json(j);
  j.write_fieldname("");
  eutra_cgi.to_json(j);
  j.write_fieldname("");
  tai.to_json(j);
  j.write_fieldname("");
  ul_cp_security_info.to_json(j);
  j.end_obj();
}

ran_cfg_upd_ies_container::ran_cfg_upd_ies_container() :
  ran_node_name(82, crit_e::ignore),
  supported_ta_list(102, crit_e::reject),
  default_paging_drx(21, crit_e::ignore),
  global_ran_node_id(27, crit_e::ignore),
  ngran_tnl_assoc_to_rem_list(167, crit_e::reject),
  nb_iot_default_paging_drx(204, crit_e::ignore),
  extended_ran_node_name(273, crit_e::ignore)
{
}
SRSASN_CODE ran_cfg_upd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += ran_node_name_present ? 1 : 0;
  nof_ies += supported_ta_list_present ? 1 : 0;
  nof_ies += default_paging_drx_present ? 1 : 0;
  nof_ies += global_ran_node_id_present ? 1 : 0;
  nof_ies += ngran_tnl_assoc_to_rem_list_present ? 1 : 0;
  nof_ies += nb_iot_default_paging_drx_present ? 1 : 0;
  nof_ies += extended_ran_node_name_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (ran_node_name_present) {
    HANDLE_CODE(ran_node_name.pack(bref));
  }
  if (supported_ta_list_present) {
    HANDLE_CODE(supported_ta_list.pack(bref));
  }
  if (default_paging_drx_present) {
    HANDLE_CODE(default_paging_drx.pack(bref));
  }
  if (global_ran_node_id_present) {
    HANDLE_CODE(global_ran_node_id.pack(bref));
  }
  if (ngran_tnl_assoc_to_rem_list_present) {
    HANDLE_CODE(ngran_tnl_assoc_to_rem_list.pack(bref));
  }
  if (nb_iot_default_paging_drx_present) {
    HANDLE_CODE(nb_iot_default_paging_drx.pack(bref));
  }
  if (extended_ran_node_name_present) {
    HANDLE_CODE(extended_ran_node_name.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cfg_upd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 82: {
        ran_node_name_present = true;
        ran_node_name.id      = id;
        HANDLE_CODE(ran_node_name.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_node_name.value.unpack(bref));
        break;
      }
      case 102: {
        supported_ta_list_present = true;
        supported_ta_list.id      = id;
        HANDLE_CODE(supported_ta_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(supported_ta_list.value.unpack(bref));
        break;
      }
      case 21: {
        default_paging_drx_present = true;
        default_paging_drx.id      = id;
        HANDLE_CODE(default_paging_drx.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(default_paging_drx.value.unpack(bref));
        break;
      }
      case 27: {
        global_ran_node_id_present = true;
        global_ran_node_id.id      = id;
        HANDLE_CODE(global_ran_node_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(global_ran_node_id.value.unpack(bref));
        break;
      }
      case 167: {
        ngran_tnl_assoc_to_rem_list_present = true;
        ngran_tnl_assoc_to_rem_list.id      = id;
        HANDLE_CODE(ngran_tnl_assoc_to_rem_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ngran_tnl_assoc_to_rem_list.value.unpack(bref));
        break;
      }
      case 204: {
        nb_iot_default_paging_drx_present = true;
        nb_iot_default_paging_drx.id      = id;
        HANDLE_CODE(nb_iot_default_paging_drx.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nb_iot_default_paging_drx.value.unpack(bref));
        break;
      }
      case 273: {
        extended_ran_node_name_present = true;
        extended_ran_node_name.id      = id;
        HANDLE_CODE(extended_ran_node_name.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_ran_node_name.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ran_cfg_upd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (ran_node_name_present) {
    j.write_fieldname("");
    ran_node_name.to_json(j);
  }
  if (supported_ta_list_present) {
    j.write_fieldname("");
    supported_ta_list.to_json(j);
  }
  if (default_paging_drx_present) {
    j.write_fieldname("");
    default_paging_drx.to_json(j);
  }
  if (global_ran_node_id_present) {
    j.write_fieldname("");
    global_ran_node_id.to_json(j);
  }
  if (ngran_tnl_assoc_to_rem_list_present) {
    j.write_fieldname("");
    ngran_tnl_assoc_to_rem_list.to_json(j);
  }
  if (nb_iot_default_paging_drx_present) {
    j.write_fieldname("");
    nb_iot_default_paging_drx.to_json(j);
  }
  if (extended_ran_node_name_present) {
    j.write_fieldname("");
    extended_ran_node_name.to_json(j);
  }
  j.end_obj();
}

ran_cfg_upd_fail_ies_container::ran_cfg_upd_fail_ies_container() :
  cause(15, crit_e::ignore), time_to_wait(107, crit_e::ignore), crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ran_cfg_upd_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += time_to_wait_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(cause.pack(bref));
  if (time_to_wait_present) {
    HANDLE_CODE(time_to_wait.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cfg_upd_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 107: {
        time_to_wait_present = true;
        time_to_wait.id      = id;
        HANDLE_CODE(time_to_wait.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_to_wait.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ran_cfg_upd_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  cause.to_json(j);
  if (time_to_wait_present) {
    j.write_fieldname("");
    time_to_wait.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

rrc_inactive_transition_report_ies_container::rrc_inactive_transition_report_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  rrc_state(92, crit_e::ignore),
  user_location_info(121, crit_e::ignore)
{
}
SRSASN_CODE rrc_inactive_transition_report_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(rrc_state.pack(bref));
  HANDLE_CODE(user_location_info.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE rrc_inactive_transition_report_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 92: {
        nof_mandatory_ies--;
        rrc_state.id = id;
        HANDLE_CODE(rrc_state.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_state.value.unpack(bref));
        break;
      }
      case 121: {
        nof_mandatory_ies--;
        user_location_info.id = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void rrc_inactive_transition_report_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  rrc_state.to_json(j);
  j.write_fieldname("");
  user_location_info.to_json(j);
  j.end_obj();
}

reroute_nas_request_ies_container::reroute_nas_request_ies_container() :
  ran_ue_ngap_id(85, crit_e::reject),
  amf_ue_ngap_id(10, crit_e::ignore),
  ngap_msg(42, crit_e::reject),
  amf_set_id(3, crit_e::reject),
  allowed_nssai(0, crit_e::reject),
  source_to_target_amf_info_reroute(171, crit_e::ignore)
{
}
SRSASN_CODE reroute_nas_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += amf_ue_ngap_id_present ? 1 : 0;
  nof_ies += allowed_nssai_present ? 1 : 0;
  nof_ies += source_to_target_amf_info_reroute_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (amf_ue_ngap_id_present) {
    HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  }
  HANDLE_CODE(ngap_msg.pack(bref));
  HANDLE_CODE(amf_set_id.pack(bref));
  if (allowed_nssai_present) {
    HANDLE_CODE(allowed_nssai.pack(bref));
  }
  if (source_to_target_amf_info_reroute_present) {
    HANDLE_CODE(source_to_target_amf_info_reroute.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE reroute_nas_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 10: {
        amf_ue_ngap_id_present = true;
        amf_ue_ngap_id.id      = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 42: {
        nof_mandatory_ies--;
        ngap_msg.id = id;
        HANDLE_CODE(ngap_msg.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ngap_msg.value.unpack(bref));
        break;
      }
      case 3: {
        nof_mandatory_ies--;
        amf_set_id.id = id;
        HANDLE_CODE(amf_set_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_set_id.value.unpack(bref));
        break;
      }
      case 0: {
        allowed_nssai_present = true;
        allowed_nssai.id      = id;
        HANDLE_CODE(allowed_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(allowed_nssai.value.unpack(bref));
        break;
      }
      case 171: {
        source_to_target_amf_info_reroute_present = true;
        source_to_target_amf_info_reroute.id      = id;
        HANDLE_CODE(source_to_target_amf_info_reroute.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_to_target_amf_info_reroute.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void reroute_nas_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (amf_ue_ngap_id_present) {
    j.write_fieldname("");
    amf_ue_ngap_id.to_json(j);
  }
  j.write_fieldname("");
  ngap_msg.to_json(j);
  j.write_fieldname("");
  amf_set_id.to_json(j);
  if (allowed_nssai_present) {
    j.write_fieldname("");
    allowed_nssai.to_json(j);
  }
  if (source_to_target_amf_info_reroute_present) {
    j.write_fieldname("");
    source_to_target_amf_info_reroute.to_json(j);
  }
  j.end_obj();
}

secondary_rat_data_usage_report_ies_container::secondary_rat_data_usage_report_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  pdu_session_res_secondary_rat_usage_list(142, crit_e::ignore),
  ho_flag(143, crit_e::ignore),
  user_location_info(121, crit_e::ignore)
{
}
SRSASN_CODE secondary_rat_data_usage_report_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ho_flag_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(pdu_session_res_secondary_rat_usage_list.pack(bref));
  if (ho_flag_present) {
    HANDLE_CODE(ho_flag.pack(bref));
  }
  if (user_location_info_present) {
    HANDLE_CODE(user_location_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE secondary_rat_data_usage_report_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 142: {
        nof_mandatory_ies--;
        pdu_session_res_secondary_rat_usage_list.id = id;
        HANDLE_CODE(pdu_session_res_secondary_rat_usage_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_secondary_rat_usage_list.value.unpack(bref));
        break;
      }
      case 143: {
        ho_flag_present = true;
        ho_flag.id      = id;
        HANDLE_CODE(ho_flag.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ho_flag.value.unpack(bref));
        break;
      }
      case 121: {
        user_location_info_present = true;
        user_location_info.id      = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void secondary_rat_data_usage_report_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  pdu_session_res_secondary_rat_usage_list.to_json(j);
  if (ho_flag_present) {
    j.write_fieldname("");
    ho_flag.to_json(j);
  }
  if (user_location_info_present) {
    j.write_fieldname("");
    user_location_info.to_json(j);
  }
  j.end_obj();
}

trace_fail_ind_ies_container::trace_fail_ind_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  ngran_trace_id(44, crit_e::ignore),
  cause(15, crit_e::ignore)
{
}
SRSASN_CODE trace_fail_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(ngran_trace_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_fail_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 44: {
        nof_mandatory_ies--;
        ngran_trace_id.id = id;
        HANDLE_CODE(ngran_trace_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ngran_trace_id.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void trace_fail_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ngran_trace_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.end_obj();
}

trace_start_ies_container::trace_start_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject), ran_ue_ngap_id(85, crit_e::reject), trace_activation(108, crit_e::ignore)
{
}
SRSASN_CODE trace_start_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(trace_activation.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_start_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 108: {
        nof_mandatory_ies--;
        trace_activation.id = id;
        HANDLE_CODE(trace_activation.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trace_activation.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void trace_start_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  trace_activation.to_json(j);
  j.end_obj();
}

ue_context_mod_fail_ies_container::ue_context_mod_fail_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  cause(15, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ue_context_mod_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_mod_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

ue_context_mod_request_ies_container::ue_context_mod_request_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  ran_paging_prio(83, crit_e::ignore),
  security_key(94, crit_e::reject),
  idx_to_rfsp(31, crit_e::ignore),
  ue_aggr_max_bit_rate(110, crit_e::ignore),
  ue_security_cap(119, crit_e::reject),
  core_network_assist_info_for_inactive(18, crit_e::ignore),
  emergency_fallback_ind(24, crit_e::reject),
  new_amf_ue_ngap_id(40, crit_e::reject),
  rrc_inactive_transition_report_request(91, crit_e::ignore),
  new_guami(162, crit_e::reject),
  cn_assisted_ran_tuning(165, crit_e::ignore),
  srvcc_operation_possible(177, crit_e::ignore),
  iab_authorized(199, crit_e::ignore),
  nr_v2x_services_authorized(216, crit_e::ignore),
  ltev2x_services_authorized(215, crit_e::ignore),
  nr_ue_sidelink_aggr_max_bitrate(218, crit_e::ignore),
  lte_ue_sidelink_aggr_max_bitrate(217, crit_e::ignore),
  pc5_qos_params(219, crit_e::ignore),
  ue_radio_cap_id(264, crit_e::reject),
  rg_level_wireline_access_characteristics(238, crit_e::ignore),
  time_sync_assist_info(326, crit_e::ignore),
  q_mcc_onfig_info(328, crit_e::ignore),
  qmc_deactivation(329, crit_e::ignore),
  ue_slice_max_bit_rate_list(335, crit_e::ignore),
  management_based_mdt_plmn_mod_list(359, crit_e::ignore),
  five_g_pro_se_authorized(345, crit_e::ignore),
  five_g_pro_se_ue_pc5_aggr_max_bit_rate(346, crit_e::ignore),
  five_g_pro_se_pc5_qos_params(347, crit_e::ignore)
{
}
SRSASN_CODE ue_context_mod_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += ran_paging_prio_present ? 1 : 0;
  nof_ies += security_key_present ? 1 : 0;
  nof_ies += idx_to_rfsp_present ? 1 : 0;
  nof_ies += ue_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += ue_security_cap_present ? 1 : 0;
  nof_ies += core_network_assist_info_for_inactive_present ? 1 : 0;
  nof_ies += emergency_fallback_ind_present ? 1 : 0;
  nof_ies += new_amf_ue_ngap_id_present ? 1 : 0;
  nof_ies += rrc_inactive_transition_report_request_present ? 1 : 0;
  nof_ies += new_guami_present ? 1 : 0;
  nof_ies += cn_assisted_ran_tuning_present ? 1 : 0;
  nof_ies += srvcc_operation_possible_present ? 1 : 0;
  nof_ies += iab_authorized_present ? 1 : 0;
  nof_ies += nr_v2x_services_authorized_present ? 1 : 0;
  nof_ies += ltev2x_services_authorized_present ? 1 : 0;
  nof_ies += nr_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += lte_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += pc5_qos_params_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += rg_level_wireline_access_characteristics_present ? 1 : 0;
  nof_ies += time_sync_assist_info_present ? 1 : 0;
  nof_ies += q_mcc_onfig_info_present ? 1 : 0;
  nof_ies += qmc_deactivation_present ? 1 : 0;
  nof_ies += ue_slice_max_bit_rate_list_present ? 1 : 0;
  nof_ies += management_based_mdt_plmn_mod_list_present ? 1 : 0;
  nof_ies += five_g_pro_se_authorized_present ? 1 : 0;
  nof_ies += five_g_pro_se_ue_pc5_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += five_g_pro_se_pc5_qos_params_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (ran_paging_prio_present) {
    HANDLE_CODE(ran_paging_prio.pack(bref));
  }
  if (security_key_present) {
    HANDLE_CODE(security_key.pack(bref));
  }
  if (idx_to_rfsp_present) {
    HANDLE_CODE(idx_to_rfsp.pack(bref));
  }
  if (ue_aggr_max_bit_rate_present) {
    HANDLE_CODE(ue_aggr_max_bit_rate.pack(bref));
  }
  if (ue_security_cap_present) {
    HANDLE_CODE(ue_security_cap.pack(bref));
  }
  if (core_network_assist_info_for_inactive_present) {
    HANDLE_CODE(core_network_assist_info_for_inactive.pack(bref));
  }
  if (emergency_fallback_ind_present) {
    HANDLE_CODE(emergency_fallback_ind.pack(bref));
  }
  if (new_amf_ue_ngap_id_present) {
    HANDLE_CODE(new_amf_ue_ngap_id.pack(bref));
  }
  if (rrc_inactive_transition_report_request_present) {
    HANDLE_CODE(rrc_inactive_transition_report_request.pack(bref));
  }
  if (new_guami_present) {
    HANDLE_CODE(new_guami.pack(bref));
  }
  if (cn_assisted_ran_tuning_present) {
    HANDLE_CODE(cn_assisted_ran_tuning.pack(bref));
  }
  if (srvcc_operation_possible_present) {
    HANDLE_CODE(srvcc_operation_possible.pack(bref));
  }
  if (iab_authorized_present) {
    HANDLE_CODE(iab_authorized.pack(bref));
  }
  if (nr_v2x_services_authorized_present) {
    HANDLE_CODE(nr_v2x_services_authorized.pack(bref));
  }
  if (ltev2x_services_authorized_present) {
    HANDLE_CODE(ltev2x_services_authorized.pack(bref));
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (pc5_qos_params_present) {
    HANDLE_CODE(pc5_qos_params.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (rg_level_wireline_access_characteristics_present) {
    HANDLE_CODE(rg_level_wireline_access_characteristics.pack(bref));
  }
  if (time_sync_assist_info_present) {
    HANDLE_CODE(time_sync_assist_info.pack(bref));
  }
  if (q_mcc_onfig_info_present) {
    HANDLE_CODE(q_mcc_onfig_info.pack(bref));
  }
  if (qmc_deactivation_present) {
    HANDLE_CODE(qmc_deactivation.pack(bref));
  }
  if (ue_slice_max_bit_rate_list_present) {
    HANDLE_CODE(ue_slice_max_bit_rate_list.pack(bref));
  }
  if (management_based_mdt_plmn_mod_list_present) {
    HANDLE_CODE(management_based_mdt_plmn_mod_list.pack(bref));
  }
  if (five_g_pro_se_authorized_present) {
    HANDLE_CODE(five_g_pro_se_authorized.pack(bref));
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.pack(bref));
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    HANDLE_CODE(five_g_pro_se_pc5_qos_params.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 83: {
        ran_paging_prio_present = true;
        ran_paging_prio.id      = id;
        HANDLE_CODE(ran_paging_prio.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_paging_prio.value.unpack(bref));
        break;
      }
      case 94: {
        security_key_present = true;
        security_key.id      = id;
        HANDLE_CODE(security_key.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_key.value.unpack(bref));
        break;
      }
      case 31: {
        idx_to_rfsp_present = true;
        idx_to_rfsp.id      = id;
        HANDLE_CODE(idx_to_rfsp.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(idx_to_rfsp.value.unpack(bref));
        break;
      }
      case 110: {
        ue_aggr_max_bit_rate_present = true;
        ue_aggr_max_bit_rate.id      = id;
        HANDLE_CODE(ue_aggr_max_bit_rate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_aggr_max_bit_rate.value.unpack(bref));
        break;
      }
      case 119: {
        ue_security_cap_present = true;
        ue_security_cap.id      = id;
        HANDLE_CODE(ue_security_cap.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_security_cap.value.unpack(bref));
        break;
      }
      case 18: {
        core_network_assist_info_for_inactive_present = true;
        core_network_assist_info_for_inactive.id      = id;
        HANDLE_CODE(core_network_assist_info_for_inactive.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(core_network_assist_info_for_inactive.value.unpack(bref));
        break;
      }
      case 24: {
        emergency_fallback_ind_present = true;
        emergency_fallback_ind.id      = id;
        HANDLE_CODE(emergency_fallback_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(emergency_fallback_ind.value.unpack(bref));
        break;
      }
      case 40: {
        new_amf_ue_ngap_id_present = true;
        new_amf_ue_ngap_id.id      = id;
        HANDLE_CODE(new_amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(new_amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 91: {
        rrc_inactive_transition_report_request_present = true;
        rrc_inactive_transition_report_request.id      = id;
        HANDLE_CODE(rrc_inactive_transition_report_request.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_inactive_transition_report_request.value.unpack(bref));
        break;
      }
      case 162: {
        new_guami_present = true;
        new_guami.id      = id;
        HANDLE_CODE(new_guami.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(new_guami.value.unpack(bref));
        break;
      }
      case 165: {
        cn_assisted_ran_tuning_present = true;
        cn_assisted_ran_tuning.id      = id;
        HANDLE_CODE(cn_assisted_ran_tuning.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_assisted_ran_tuning.value.unpack(bref));
        break;
      }
      case 177: {
        srvcc_operation_possible_present = true;
        srvcc_operation_possible.id      = id;
        HANDLE_CODE(srvcc_operation_possible.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(srvcc_operation_possible.value.unpack(bref));
        break;
      }
      case 199: {
        iab_authorized_present = true;
        iab_authorized.id      = id;
        HANDLE_CODE(iab_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(iab_authorized.value.unpack(bref));
        break;
      }
      case 216: {
        nr_v2x_services_authorized_present = true;
        nr_v2x_services_authorized.id      = id;
        HANDLE_CODE(nr_v2x_services_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_v2x_services_authorized.value.unpack(bref));
        break;
      }
      case 215: {
        ltev2x_services_authorized_present = true;
        ltev2x_services_authorized.id      = id;
        HANDLE_CODE(ltev2x_services_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ltev2x_services_authorized.value.unpack(bref));
        break;
      }
      case 218: {
        nr_ue_sidelink_aggr_max_bitrate_present = true;
        nr_ue_sidelink_aggr_max_bitrate.id      = id;
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.value.unpack(bref));
        break;
      }
      case 217: {
        lte_ue_sidelink_aggr_max_bitrate_present = true;
        lte_ue_sidelink_aggr_max_bitrate.id      = id;
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.value.unpack(bref));
        break;
      }
      case 219: {
        pc5_qos_params_present = true;
        pc5_qos_params.id      = id;
        HANDLE_CODE(pc5_qos_params.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pc5_qos_params.value.unpack(bref));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        ue_radio_cap_id.id      = id;
        HANDLE_CODE(ue_radio_cap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.value.unpack(bref));
        break;
      }
      case 238: {
        rg_level_wireline_access_characteristics_present = true;
        rg_level_wireline_access_characteristics.id      = id;
        HANDLE_CODE(rg_level_wireline_access_characteristics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rg_level_wireline_access_characteristics.value.unpack(bref));
        break;
      }
      case 326: {
        time_sync_assist_info_present = true;
        time_sync_assist_info.id      = id;
        HANDLE_CODE(time_sync_assist_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_sync_assist_info.value.unpack(bref));
        break;
      }
      case 328: {
        q_mcc_onfig_info_present = true;
        q_mcc_onfig_info.id      = id;
        HANDLE_CODE(q_mcc_onfig_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(q_mcc_onfig_info.value.unpack(bref));
        break;
      }
      case 329: {
        qmc_deactivation_present = true;
        qmc_deactivation.id      = id;
        HANDLE_CODE(qmc_deactivation.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(qmc_deactivation.value.unpack(bref));
        break;
      }
      case 335: {
        ue_slice_max_bit_rate_list_present = true;
        ue_slice_max_bit_rate_list.id      = id;
        HANDLE_CODE(ue_slice_max_bit_rate_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_slice_max_bit_rate_list.value.unpack(bref));
        break;
      }
      case 359: {
        management_based_mdt_plmn_mod_list_present = true;
        management_based_mdt_plmn_mod_list.id      = id;
        HANDLE_CODE(management_based_mdt_plmn_mod_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(management_based_mdt_plmn_mod_list.value.unpack(bref));
        break;
      }
      case 345: {
        five_g_pro_se_authorized_present = true;
        five_g_pro_se_authorized.id      = id;
        HANDLE_CODE(five_g_pro_se_authorized.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_authorized.value.unpack(bref));
        break;
      }
      case 346: {
        five_g_pro_se_ue_pc5_aggr_max_bit_rate_present = true;
        five_g_pro_se_ue_pc5_aggr_max_bit_rate.id      = id;
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.value.unpack(bref));
        break;
      }
      case 347: {
        five_g_pro_se_pc5_qos_params_present = true;
        five_g_pro_se_pc5_qos_params.id      = id;
        HANDLE_CODE(five_g_pro_se_pc5_qos_params.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_pc5_qos_params.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_mod_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (ran_paging_prio_present) {
    j.write_fieldname("");
    ran_paging_prio.to_json(j);
  }
  if (security_key_present) {
    j.write_fieldname("");
    security_key.to_json(j);
  }
  if (idx_to_rfsp_present) {
    j.write_fieldname("");
    idx_to_rfsp.to_json(j);
  }
  if (ue_aggr_max_bit_rate_present) {
    j.write_fieldname("");
    ue_aggr_max_bit_rate.to_json(j);
  }
  if (ue_security_cap_present) {
    j.write_fieldname("");
    ue_security_cap.to_json(j);
  }
  if (core_network_assist_info_for_inactive_present) {
    j.write_fieldname("");
    core_network_assist_info_for_inactive.to_json(j);
  }
  if (emergency_fallback_ind_present) {
    j.write_fieldname("");
    emergency_fallback_ind.to_json(j);
  }
  if (new_amf_ue_ngap_id_present) {
    j.write_fieldname("");
    new_amf_ue_ngap_id.to_json(j);
  }
  if (rrc_inactive_transition_report_request_present) {
    j.write_fieldname("");
    rrc_inactive_transition_report_request.to_json(j);
  }
  if (new_guami_present) {
    j.write_fieldname("");
    new_guami.to_json(j);
  }
  if (cn_assisted_ran_tuning_present) {
    j.write_fieldname("");
    cn_assisted_ran_tuning.to_json(j);
  }
  if (srvcc_operation_possible_present) {
    j.write_fieldname("");
    srvcc_operation_possible.to_json(j);
  }
  if (iab_authorized_present) {
    j.write_fieldname("");
    iab_authorized.to_json(j);
  }
  if (nr_v2x_services_authorized_present) {
    j.write_fieldname("");
    nr_v2x_services_authorized.to_json(j);
  }
  if (ltev2x_services_authorized_present) {
    j.write_fieldname("");
    ltev2x_services_authorized.to_json(j);
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    j.write_fieldname("");
    nr_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    j.write_fieldname("");
    lte_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (pc5_qos_params_present) {
    j.write_fieldname("");
    pc5_qos_params.to_json(j);
  }
  if (ue_radio_cap_id_present) {
    j.write_fieldname("");
    ue_radio_cap_id.to_json(j);
  }
  if (rg_level_wireline_access_characteristics_present) {
    j.write_fieldname("");
    rg_level_wireline_access_characteristics.to_json(j);
  }
  if (time_sync_assist_info_present) {
    j.write_fieldname("");
    time_sync_assist_info.to_json(j);
  }
  if (q_mcc_onfig_info_present) {
    j.write_fieldname("");
    q_mcc_onfig_info.to_json(j);
  }
  if (qmc_deactivation_present) {
    j.write_fieldname("");
    qmc_deactivation.to_json(j);
  }
  if (ue_slice_max_bit_rate_list_present) {
    j.write_fieldname("");
    ue_slice_max_bit_rate_list.to_json(j);
  }
  if (management_based_mdt_plmn_mod_list_present) {
    j.write_fieldname("");
    management_based_mdt_plmn_mod_list.to_json(j);
  }
  if (five_g_pro_se_authorized_present) {
    j.write_fieldname("");
    five_g_pro_se_authorized.to_json(j);
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    j.write_fieldname("");
    five_g_pro_se_ue_pc5_aggr_max_bit_rate.to_json(j);
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    j.write_fieldname("");
    five_g_pro_se_pc5_qos_params.to_json(j);
  }
  j.end_obj();
}

ue_context_mod_resp_ies_container::ue_context_mod_resp_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  rrc_state(92, crit_e::ignore),
  user_location_info(121, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ue_context_mod_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += rrc_state_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (rrc_state_present) {
    HANDLE_CODE(rrc_state.pack(bref));
  }
  if (user_location_info_present) {
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 92: {
        rrc_state_present = true;
        rrc_state.id      = id;
        HANDLE_CODE(rrc_state.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_state.value.unpack(bref));
        break;
      }
      case 121: {
        user_location_info_present = true;
        user_location_info.id      = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_mod_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (rrc_state_present) {
    j.write_fieldname("");
    rrc_state.to_json(j);
  }
  if (user_location_info_present) {
    j.write_fieldname("");
    user_location_info.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

ue_context_release_cmd_ies_container::ue_context_release_cmd_ies_container() :
  ue_ngap_ids(114, crit_e::reject), cause(15, crit_e::ignore)
{
}
SRSASN_CODE ue_context_release_cmd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(ue_ngap_ids.pack(bref));
  HANDLE_CODE(cause.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_cmd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 114: {
        nof_mandatory_ies--;
        ue_ngap_ids.id = id;
        HANDLE_CODE(ue_ngap_ids.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_ngap_ids.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_release_cmd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  ue_ngap_ids.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  j.end_obj();
}

ue_context_release_complete_ies_container::ue_context_release_complete_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  user_location_info(121, crit_e::ignore),
  info_on_recommended_cells_and_ran_nodes_for_paging(32, crit_e::ignore),
  pdu_session_res_list_cxt_rel_cpl(60, crit_e::reject),
  crit_diagnostics(19, crit_e::ignore),
  paging_assis_datafor_c_ecapab_ue(207, crit_e::ignore)
{
}
SRSASN_CODE ue_context_release_complete_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += user_location_info_present ? 1 : 0;
  nof_ies += info_on_recommended_cells_and_ran_nodes_for_paging_present ? 1 : 0;
  nof_ies += pdu_session_res_list_cxt_rel_cpl_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += paging_assis_datafor_c_ecapab_ue_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (user_location_info_present) {
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (info_on_recommended_cells_and_ran_nodes_for_paging_present) {
    HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.pack(bref));
  }
  if (pdu_session_res_list_cxt_rel_cpl_present) {
    HANDLE_CODE(pdu_session_res_list_cxt_rel_cpl.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_complete_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 121: {
        user_location_info_present = true;
        user_location_info.id      = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      case 32: {
        info_on_recommended_cells_and_ran_nodes_for_paging_present = true;
        info_on_recommended_cells_and_ran_nodes_for_paging.id      = id;
        HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.value.unpack(bref));
        break;
      }
      case 60: {
        pdu_session_res_list_cxt_rel_cpl_present = true;
        pdu_session_res_list_cxt_rel_cpl.id      = id;
        HANDLE_CODE(pdu_session_res_list_cxt_rel_cpl.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_list_cxt_rel_cpl.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      case 207: {
        paging_assis_datafor_c_ecapab_ue_present = true;
        paging_assis_datafor_c_ecapab_ue.id      = id;
        HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_release_complete_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (user_location_info_present) {
    j.write_fieldname("");
    user_location_info.to_json(j);
  }
  if (info_on_recommended_cells_and_ran_nodes_for_paging_present) {
    j.write_fieldname("");
    info_on_recommended_cells_and_ran_nodes_for_paging.to_json(j);
  }
  if (pdu_session_res_list_cxt_rel_cpl_present) {
    j.write_fieldname("");
    pdu_session_res_list_cxt_rel_cpl.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    j.write_fieldname("");
    paging_assis_datafor_c_ecapab_ue.to_json(j);
  }
  j.end_obj();
}

ue_context_release_request_ies_container::ue_context_release_request_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  pdu_session_res_list_cxt_rel_req(133, crit_e::reject),
  cause(15, crit_e::ignore)
{
}
SRSASN_CODE ue_context_release_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += pdu_session_res_list_cxt_rel_req_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (pdu_session_res_list_cxt_rel_req_present) {
    HANDLE_CODE(pdu_session_res_list_cxt_rel_req.pack(bref));
  }
  HANDLE_CODE(cause.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 133: {
        pdu_session_res_list_cxt_rel_req_present = true;
        pdu_session_res_list_cxt_rel_req.id      = id;
        HANDLE_CODE(pdu_session_res_list_cxt_rel_req.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_list_cxt_rel_req.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_release_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (pdu_session_res_list_cxt_rel_req_present) {
    j.write_fieldname("");
    pdu_session_res_list_cxt_rel_req.to_json(j);
  }
  j.write_fieldname("");
  cause.to_json(j);
  j.end_obj();
}

ue_context_resume_fail_ies_container::ue_context_resume_fail_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  cause(15, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ue_context_resume_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_resume_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

ue_context_resume_request_ies_container::ue_context_resume_request_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  rrc_resume_cause(237, crit_e::ignore),
  pdu_session_res_resume_list_res_req(232, crit_e::reject),
  pdu_session_res_failed_to_resume_list_res_req(229, crit_e::reject),
  suspend_request_ind(235, crit_e::ignore),
  info_on_recommended_cells_and_ran_nodes_for_paging(32, crit_e::ignore),
  paging_assis_datafor_c_ecapab_ue(207, crit_e::ignore)
{
}
SRSASN_CODE ue_context_resume_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += pdu_session_res_resume_list_res_req_present ? 1 : 0;
  nof_ies += pdu_session_res_failed_to_resume_list_res_req_present ? 1 : 0;
  nof_ies += suspend_request_ind_present ? 1 : 0;
  nof_ies += info_on_recommended_cells_and_ran_nodes_for_paging_present ? 1 : 0;
  nof_ies += paging_assis_datafor_c_ecapab_ue_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(rrc_resume_cause.pack(bref));
  if (pdu_session_res_resume_list_res_req_present) {
    HANDLE_CODE(pdu_session_res_resume_list_res_req.pack(bref));
  }
  if (pdu_session_res_failed_to_resume_list_res_req_present) {
    HANDLE_CODE(pdu_session_res_failed_to_resume_list_res_req.pack(bref));
  }
  if (suspend_request_ind_present) {
    HANDLE_CODE(suspend_request_ind.pack(bref));
  }
  if (info_on_recommended_cells_and_ran_nodes_for_paging_present) {
    HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.pack(bref));
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 237: {
        nof_mandatory_ies--;
        rrc_resume_cause.id = id;
        HANDLE_CODE(rrc_resume_cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_resume_cause.value.unpack(bref));
        break;
      }
      case 232: {
        pdu_session_res_resume_list_res_req_present = true;
        pdu_session_res_resume_list_res_req.id      = id;
        HANDLE_CODE(pdu_session_res_resume_list_res_req.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_resume_list_res_req.value.unpack(bref));
        break;
      }
      case 229: {
        pdu_session_res_failed_to_resume_list_res_req_present = true;
        pdu_session_res_failed_to_resume_list_res_req.id      = id;
        HANDLE_CODE(pdu_session_res_failed_to_resume_list_res_req.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_failed_to_resume_list_res_req.value.unpack(bref));
        break;
      }
      case 235: {
        suspend_request_ind_present = true;
        suspend_request_ind.id      = id;
        HANDLE_CODE(suspend_request_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(suspend_request_ind.value.unpack(bref));
        break;
      }
      case 32: {
        info_on_recommended_cells_and_ran_nodes_for_paging_present = true;
        info_on_recommended_cells_and_ran_nodes_for_paging.id      = id;
        HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.value.unpack(bref));
        break;
      }
      case 207: {
        paging_assis_datafor_c_ecapab_ue_present = true;
        paging_assis_datafor_c_ecapab_ue.id      = id;
        HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_resume_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  rrc_resume_cause.to_json(j);
  if (pdu_session_res_resume_list_res_req_present) {
    j.write_fieldname("");
    pdu_session_res_resume_list_res_req.to_json(j);
  }
  if (pdu_session_res_failed_to_resume_list_res_req_present) {
    j.write_fieldname("");
    pdu_session_res_failed_to_resume_list_res_req.to_json(j);
  }
  if (suspend_request_ind_present) {
    j.write_fieldname("");
    suspend_request_ind.to_json(j);
  }
  if (info_on_recommended_cells_and_ran_nodes_for_paging_present) {
    j.write_fieldname("");
    info_on_recommended_cells_and_ran_nodes_for_paging.to_json(j);
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    j.write_fieldname("");
    paging_assis_datafor_c_ecapab_ue.to_json(j);
  }
  j.end_obj();
}

ue_context_resume_resp_ies_container::ue_context_resume_resp_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  pdu_session_res_resume_list_res_res(233, crit_e::reject),
  pdu_session_res_failed_to_resume_list_res_res(230, crit_e::reject),
  security_context(93, crit_e::reject),
  suspend_resp_ind(236, crit_e::ignore),
  extended_connected_time(206, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ue_context_resume_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += pdu_session_res_resume_list_res_res_present ? 1 : 0;
  nof_ies += pdu_session_res_failed_to_resume_list_res_res_present ? 1 : 0;
  nof_ies += security_context_present ? 1 : 0;
  nof_ies += suspend_resp_ind_present ? 1 : 0;
  nof_ies += extended_connected_time_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (pdu_session_res_resume_list_res_res_present) {
    HANDLE_CODE(pdu_session_res_resume_list_res_res.pack(bref));
  }
  if (pdu_session_res_failed_to_resume_list_res_res_present) {
    HANDLE_CODE(pdu_session_res_failed_to_resume_list_res_res.pack(bref));
  }
  if (security_context_present) {
    HANDLE_CODE(security_context.pack(bref));
  }
  if (suspend_resp_ind_present) {
    HANDLE_CODE(suspend_resp_ind.pack(bref));
  }
  if (extended_connected_time_present) {
    HANDLE_CODE(extended_connected_time.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 233: {
        pdu_session_res_resume_list_res_res_present = true;
        pdu_session_res_resume_list_res_res.id      = id;
        HANDLE_CODE(pdu_session_res_resume_list_res_res.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_resume_list_res_res.value.unpack(bref));
        break;
      }
      case 230: {
        pdu_session_res_failed_to_resume_list_res_res_present = true;
        pdu_session_res_failed_to_resume_list_res_res.id      = id;
        HANDLE_CODE(pdu_session_res_failed_to_resume_list_res_res.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_failed_to_resume_list_res_res.value.unpack(bref));
        break;
      }
      case 93: {
        security_context_present = true;
        security_context.id      = id;
        HANDLE_CODE(security_context.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_context.value.unpack(bref));
        break;
      }
      case 236: {
        suspend_resp_ind_present = true;
        suspend_resp_ind.id      = id;
        HANDLE_CODE(suspend_resp_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(suspend_resp_ind.value.unpack(bref));
        break;
      }
      case 206: {
        extended_connected_time_present = true;
        extended_connected_time.id      = id;
        HANDLE_CODE(extended_connected_time.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_connected_time.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_resume_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (pdu_session_res_resume_list_res_res_present) {
    j.write_fieldname("");
    pdu_session_res_resume_list_res_res.to_json(j);
  }
  if (pdu_session_res_failed_to_resume_list_res_res_present) {
    j.write_fieldname("");
    pdu_session_res_failed_to_resume_list_res_res.to_json(j);
  }
  if (security_context_present) {
    j.write_fieldname("");
    security_context.to_json(j);
  }
  if (suspend_resp_ind_present) {
    j.write_fieldname("");
    suspend_resp_ind.to_json(j);
  }
  if (extended_connected_time_present) {
    j.write_fieldname("");
    extended_connected_time.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

ue_context_suspend_fail_ies_container::ue_context_suspend_fail_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  cause(15, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ue_context_suspend_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        cause.id = id;
        HANDLE_CODE(cause.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_suspend_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

ue_context_suspend_request_ies_container::ue_context_suspend_request_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  info_on_recommended_cells_and_ran_nodes_for_paging(32, crit_e::ignore),
  paging_assis_datafor_c_ecapab_ue(207, crit_e::ignore),
  pdu_session_res_suspend_list_sus_req(231, crit_e::reject)
{
}
SRSASN_CODE ue_context_suspend_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += info_on_recommended_cells_and_ran_nodes_for_paging_present ? 1 : 0;
  nof_ies += paging_assis_datafor_c_ecapab_ue_present ? 1 : 0;
  nof_ies += pdu_session_res_suspend_list_sus_req_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (info_on_recommended_cells_and_ran_nodes_for_paging_present) {
    HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.pack(bref));
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.pack(bref));
  }
  if (pdu_session_res_suspend_list_sus_req_present) {
    HANDLE_CODE(pdu_session_res_suspend_list_sus_req.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 32: {
        info_on_recommended_cells_and_ran_nodes_for_paging_present = true;
        info_on_recommended_cells_and_ran_nodes_for_paging.id      = id;
        HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.value.unpack(bref));
        break;
      }
      case 207: {
        paging_assis_datafor_c_ecapab_ue_present = true;
        paging_assis_datafor_c_ecapab_ue.id      = id;
        HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.value.unpack(bref));
        break;
      }
      case 231: {
        pdu_session_res_suspend_list_sus_req_present = true;
        pdu_session_res_suspend_list_sus_req.id      = id;
        HANDLE_CODE(pdu_session_res_suspend_list_sus_req.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdu_session_res_suspend_list_sus_req.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_suspend_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (info_on_recommended_cells_and_ran_nodes_for_paging_present) {
    j.write_fieldname("");
    info_on_recommended_cells_and_ran_nodes_for_paging.to_json(j);
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    j.write_fieldname("");
    paging_assis_datafor_c_ecapab_ue.to_json(j);
  }
  if (pdu_session_res_suspend_list_sus_req_present) {
    j.write_fieldname("");
    pdu_session_res_suspend_list_sus_req.to_json(j);
  }
  j.end_obj();
}

ue_context_suspend_resp_ies_container::ue_context_suspend_resp_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  security_context(93, crit_e::reject),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ue_context_suspend_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += security_context_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (security_context_present) {
    HANDLE_CODE(security_context.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 93: {
        security_context_present = true;
        security_context.id      = id;
        HANDLE_CODE(security_context.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_context.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_suspend_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (security_context_present) {
    j.write_fieldname("");
    security_context.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

ue_info_transfer_ies_container::ue_info_transfer_ies_container() :
  five_g_s_tmsi(26, crit_e::reject),
  nb_iot_ue_prio(210, crit_e::ignore),
  ue_radio_cap(117, crit_e::ignore),
  s_nssai(148, crit_e::ignore),
  allowed_nssai(0, crit_e::ignore),
  ue_diff_info(209, crit_e::ignore),
  masked_imeisv(34, crit_e::ignore)
{
}
SRSASN_CODE ue_info_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += nb_iot_ue_prio_present ? 1 : 0;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  nof_ies += s_nssai_present ? 1 : 0;
  nof_ies += allowed_nssai_present ? 1 : 0;
  nof_ies += ue_diff_info_present ? 1 : 0;
  nof_ies += masked_imeisv_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(five_g_s_tmsi.pack(bref));
  if (nb_iot_ue_prio_present) {
    HANDLE_CODE(nb_iot_ue_prio.pack(bref));
  }
  if (ue_radio_cap_present) {
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (s_nssai_present) {
    HANDLE_CODE(s_nssai.pack(bref));
  }
  if (allowed_nssai_present) {
    HANDLE_CODE(allowed_nssai.pack(bref));
  }
  if (ue_diff_info_present) {
    HANDLE_CODE(ue_diff_info.pack(bref));
  }
  if (masked_imeisv_present) {
    HANDLE_CODE(masked_imeisv.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_info_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 26: {
        nof_mandatory_ies--;
        five_g_s_tmsi.id = id;
        HANDLE_CODE(five_g_s_tmsi.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_s_tmsi.value.unpack(bref));
        break;
      }
      case 210: {
        nb_iot_ue_prio_present = true;
        nb_iot_ue_prio.id      = id;
        HANDLE_CODE(nb_iot_ue_prio.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nb_iot_ue_prio.value.unpack(bref));
        break;
      }
      case 117: {
        ue_radio_cap_present = true;
        ue_radio_cap.id      = id;
        HANDLE_CODE(ue_radio_cap.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.value.unpack(bref));
        break;
      }
      case 148: {
        s_nssai_present = true;
        s_nssai.id      = id;
        HANDLE_CODE(s_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(s_nssai.value.unpack(bref));
        break;
      }
      case 0: {
        allowed_nssai_present = true;
        allowed_nssai.id      = id;
        HANDLE_CODE(allowed_nssai.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(allowed_nssai.value.unpack(bref));
        break;
      }
      case 209: {
        ue_diff_info_present = true;
        ue_diff_info.id      = id;
        HANDLE_CODE(ue_diff_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_diff_info.value.unpack(bref));
        break;
      }
      case 34: {
        masked_imeisv_present = true;
        masked_imeisv.id      = id;
        HANDLE_CODE(masked_imeisv.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(masked_imeisv.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_info_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  five_g_s_tmsi.to_json(j);
  if (nb_iot_ue_prio_present) {
    j.write_fieldname("");
    nb_iot_ue_prio.to_json(j);
  }
  if (ue_radio_cap_present) {
    j.write_fieldname("");
    ue_radio_cap.to_json(j);
  }
  if (s_nssai_present) {
    j.write_fieldname("");
    s_nssai.to_json(j);
  }
  if (allowed_nssai_present) {
    j.write_fieldname("");
    allowed_nssai.to_json(j);
  }
  if (ue_diff_info_present) {
    j.write_fieldname("");
    ue_diff_info.to_json(j);
  }
  if (masked_imeisv_present) {
    j.write_fieldname("");
    masked_imeisv.to_json(j);
  }
  j.end_obj();
}

ue_radio_cap_check_request_ies_container::ue_radio_cap_check_request_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  ue_radio_cap(117, crit_e::ignore),
  ue_radio_cap_id(264, crit_e::reject)
{
}
SRSASN_CODE ue_radio_cap_check_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  if (ue_radio_cap_present) {
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_check_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 117: {
        ue_radio_cap_present = true;
        ue_radio_cap.id      = id;
        HANDLE_CODE(ue_radio_cap.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.value.unpack(bref));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        ue_radio_cap_id.id      = id;
        HANDLE_CODE(ue_radio_cap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_radio_cap_check_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  if (ue_radio_cap_present) {
    j.write_fieldname("");
    ue_radio_cap.to_json(j);
  }
  if (ue_radio_cap_id_present) {
    j.write_fieldname("");
    ue_radio_cap_id.to_json(j);
  }
  j.end_obj();
}

ue_radio_cap_check_resp_ies_container::ue_radio_cap_check_resp_ies_container() :
  amf_ue_ngap_id(10, crit_e::ignore),
  ran_ue_ngap_id(85, crit_e::ignore),
  ims_voice_support_ind(30, crit_e::reject),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ue_radio_cap_check_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(ims_voice_support_ind.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_check_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 30: {
        nof_mandatory_ies--;
        ims_voice_support_ind.id = id;
        HANDLE_CODE(ims_voice_support_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ims_voice_support_ind.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_radio_cap_check_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ims_voice_support_ind.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

ue_radio_cap_id_map_resp_ies_container::ue_radio_cap_id_map_resp_ies_container() :
  ue_radio_cap_id(264, crit_e::reject), ue_radio_cap(117, crit_e::ignore), crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE ue_radio_cap_id_map_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(ue_radio_cap_id.pack(bref));
  HANDLE_CODE(ue_radio_cap.pack(bref));
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_id_map_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 264: {
        nof_mandatory_ies--;
        ue_radio_cap_id.id = id;
        HANDLE_CODE(ue_radio_cap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.value.unpack(bref));
        break;
      }
      case 117: {
        nof_mandatory_ies--;
        ue_radio_cap.id = id;
        HANDLE_CODE(ue_radio_cap.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_radio_cap_id_map_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  ue_radio_cap_id.to_json(j);
  j.write_fieldname("");
  ue_radio_cap.to_json(j);
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

ue_radio_cap_info_ind_ies_container::ue_radio_cap_info_ind_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  ue_radio_cap(117, crit_e::ignore),
  ue_radio_cap_for_paging(118, crit_e::ignore),
  ue_radio_cap_eutra_format(265, crit_e::ignore)
{
}
SRSASN_CODE ue_radio_cap_info_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ue_radio_cap_for_paging_present ? 1 : 0;
  nof_ies += ue_radio_cap_eutra_format_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(ue_radio_cap.pack(bref));
  if (ue_radio_cap_for_paging_present) {
    HANDLE_CODE(ue_radio_cap_for_paging.pack(bref));
  }
  if (ue_radio_cap_eutra_format_present) {
    HANDLE_CODE(ue_radio_cap_eutra_format.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_info_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 117: {
        nof_mandatory_ies--;
        ue_radio_cap.id = id;
        HANDLE_CODE(ue_radio_cap.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.value.unpack(bref));
        break;
      }
      case 118: {
        ue_radio_cap_for_paging_present = true;
        ue_radio_cap_for_paging.id      = id;
        HANDLE_CODE(ue_radio_cap_for_paging.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_for_paging.value.unpack(bref));
        break;
      }
      case 265: {
        ue_radio_cap_eutra_format_present = true;
        ue_radio_cap_eutra_format.id      = id;
        HANDLE_CODE(ue_radio_cap_eutra_format.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_eutra_format.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_radio_cap_info_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ue_radio_cap.to_json(j);
  if (ue_radio_cap_for_paging_present) {
    j.write_fieldname("");
    ue_radio_cap_for_paging.to_json(j);
  }
  if (ue_radio_cap_eutra_format_present) {
    j.write_fieldname("");
    ue_radio_cap_eutra_format.to_json(j);
  }
  j.end_obj();
}

ue_tnla_binding_release_request_ies_container::ue_tnla_binding_release_request_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject), ran_ue_ngap_id(85, crit_e::reject)
{
}
SRSASN_CODE ue_tnla_binding_release_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_tnla_binding_release_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_tnla_binding_release_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.end_obj();
}

ul_nas_transport_ies_container::ul_nas_transport_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  nas_pdu(38, crit_e::reject),
  user_location_info(121, crit_e::ignore),
  w_agf_id_info(239, crit_e::reject),
  tngf_id_info(246, crit_e::reject),
  twif_id_info(247, crit_e::reject)
{
}
SRSASN_CODE ul_nas_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += w_agf_id_info_present ? 1 : 0;
  nof_ies += tngf_id_info_present ? 1 : 0;
  nof_ies += twif_id_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(nas_pdu.pack(bref));
  HANDLE_CODE(user_location_info.pack(bref));
  if (w_agf_id_info_present) {
    HANDLE_CODE(w_agf_id_info.pack(bref));
  }
  if (tngf_id_info_present) {
    HANDLE_CODE(tngf_id_info.pack(bref));
  }
  if (twif_id_info_present) {
    HANDLE_CODE(twif_id_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_nas_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 38: {
        nof_mandatory_ies--;
        nas_pdu.id = id;
        HANDLE_CODE(nas_pdu.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.value.unpack(bref));
        break;
      }
      case 121: {
        nof_mandatory_ies--;
        user_location_info.id = id;
        HANDLE_CODE(user_location_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.value.unpack(bref));
        break;
      }
      case 239: {
        w_agf_id_info_present = true;
        w_agf_id_info.id      = id;
        HANDLE_CODE(w_agf_id_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(w_agf_id_info.value.unpack(bref));
        break;
      }
      case 246: {
        tngf_id_info_present = true;
        tngf_id_info.id      = id;
        HANDLE_CODE(tngf_id_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tngf_id_info.value.unpack(bref));
        break;
      }
      case 247: {
        twif_id_info_present = true;
        twif_id_info.id      = id;
        HANDLE_CODE(twif_id_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(twif_id_info.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ul_nas_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  nas_pdu.to_json(j);
  j.write_fieldname("");
  user_location_info.to_json(j);
  if (w_agf_id_info_present) {
    j.write_fieldname("");
    w_agf_id_info.to_json(j);
  }
  if (tngf_id_info_present) {
    j.write_fieldname("");
    tngf_id_info.to_json(j);
  }
  if (twif_id_info_present) {
    j.write_fieldname("");
    twif_id_info.to_json(j);
  }
  j.end_obj();
}

ul_non_ue_associated_nrppa_transport_ies_container::ul_non_ue_associated_nrppa_transport_ies_container() :
  routing_id(89, crit_e::reject), nrppa_pdu(46, crit_e::reject)
{
}
SRSASN_CODE ul_non_ue_associated_nrppa_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(routing_id.pack(bref));
  HANDLE_CODE(nrppa_pdu.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_non_ue_associated_nrppa_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 89: {
        nof_mandatory_ies--;
        routing_id.id = id;
        HANDLE_CODE(routing_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(routing_id.value.unpack(bref));
        break;
      }
      case 46: {
        nof_mandatory_ies--;
        nrppa_pdu.id = id;
        HANDLE_CODE(nrppa_pdu.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nrppa_pdu.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ul_non_ue_associated_nrppa_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  routing_id.to_json(j);
  j.write_fieldname("");
  nrppa_pdu.to_json(j);
  j.end_obj();
}

ul_ran_cfg_transfer_ies_container::ul_ran_cfg_transfer_ies_container() :
  son_cfg_transfer_ul(99, crit_e::ignore),
  endc_son_cfg_transfer_ul(158, crit_e::ignore),
  intersys_son_cfg_transfer_ul(251, crit_e::ignore)
{
}
SRSASN_CODE ul_ran_cfg_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += son_cfg_transfer_ul_present ? 1 : 0;
  nof_ies += endc_son_cfg_transfer_ul_present ? 1 : 0;
  nof_ies += intersys_son_cfg_transfer_ul_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (son_cfg_transfer_ul_present) {
    HANDLE_CODE(son_cfg_transfer_ul.pack(bref));
  }
  if (endc_son_cfg_transfer_ul_present) {
    HANDLE_CODE(endc_son_cfg_transfer_ul.pack(bref));
  }
  if (intersys_son_cfg_transfer_ul_present) {
    HANDLE_CODE(intersys_son_cfg_transfer_ul.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ran_cfg_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 99: {
        son_cfg_transfer_ul_present = true;
        son_cfg_transfer_ul.id      = id;
        HANDLE_CODE(son_cfg_transfer_ul.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(son_cfg_transfer_ul.value.unpack(bref));
        break;
      }
      case 158: {
        endc_son_cfg_transfer_ul_present = true;
        endc_son_cfg_transfer_ul.id      = id;
        HANDLE_CODE(endc_son_cfg_transfer_ul.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(endc_son_cfg_transfer_ul.value.unpack(bref));
        break;
      }
      case 251: {
        intersys_son_cfg_transfer_ul_present = true;
        intersys_son_cfg_transfer_ul.id      = id;
        HANDLE_CODE(intersys_son_cfg_transfer_ul.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(intersys_son_cfg_transfer_ul.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ul_ran_cfg_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (son_cfg_transfer_ul_present) {
    j.write_fieldname("");
    son_cfg_transfer_ul.to_json(j);
  }
  if (endc_son_cfg_transfer_ul_present) {
    j.write_fieldname("");
    endc_son_cfg_transfer_ul.to_json(j);
  }
  if (intersys_son_cfg_transfer_ul_present) {
    j.write_fieldname("");
    intersys_son_cfg_transfer_ul.to_json(j);
  }
  j.end_obj();
}

ul_ran_early_status_transfer_ies_container::ul_ran_early_status_transfer_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  early_status_transfer_transparent_container(268, crit_e::reject)
{
}
SRSASN_CODE ul_ran_early_status_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(early_status_transfer_transparent_container.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ran_early_status_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 268: {
        nof_mandatory_ies--;
        early_status_transfer_transparent_container.id = id;
        HANDLE_CODE(early_status_transfer_transparent_container.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(early_status_transfer_transparent_container.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ul_ran_early_status_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  early_status_transfer_transparent_container.to_json(j);
  j.end_obj();
}

ul_ran_status_transfer_ies_container::ul_ran_status_transfer_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  ran_status_transfer_transparent_container(84, crit_e::reject)
{
}
SRSASN_CODE ul_ran_status_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_status_transfer_transparent_container.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ran_status_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 84: {
        nof_mandatory_ies--;
        ran_status_transfer_transparent_container.id = id;
        HANDLE_CODE(ran_status_transfer_transparent_container.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_status_transfer_transparent_container.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ul_ran_status_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_status_transfer_transparent_container.to_json(j);
  j.end_obj();
}

ul_ue_associated_nrppa_transport_ies_container::ul_ue_associated_nrppa_transport_ies_container() :
  amf_ue_ngap_id(10, crit_e::reject),
  ran_ue_ngap_id(85, crit_e::reject),
  routing_id(89, crit_e::reject),
  nrppa_pdu(46, crit_e::reject)
{
}
SRSASN_CODE ul_ue_associated_nrppa_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(amf_ue_ngap_id.pack(bref));
  HANDLE_CODE(ran_ue_ngap_id.pack(bref));
  HANDLE_CODE(routing_id.pack(bref));
  HANDLE_CODE(nrppa_pdu.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ue_associated_nrppa_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        amf_ue_ngap_id.id = id;
        HANDLE_CODE(amf_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        ran_ue_ngap_id.id = id;
        HANDLE_CODE(ran_ue_ngap_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_ue_ngap_id.value.unpack(bref));
        break;
      }
      case 89: {
        nof_mandatory_ies--;
        routing_id.id = id;
        HANDLE_CODE(routing_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(routing_id.value.unpack(bref));
        break;
      }
      case 46: {
        nof_mandatory_ies--;
        nrppa_pdu.id = id;
        HANDLE_CODE(nrppa_pdu.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nrppa_pdu.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ul_ue_associated_nrppa_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  amf_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  ran_ue_ngap_id.to_json(j);
  j.write_fieldname("");
  routing_id.to_json(j);
  j.write_fieldname("");
  nrppa_pdu.to_json(j);
  j.end_obj();
}

write_replace_warning_request_ies_container::write_replace_warning_request_ies_container() :
  msg_id(35, crit_e::reject),
  serial_num(95, crit_e::reject),
  warning_area_list(122, crit_e::ignore),
  repeat_period(87, crit_e::reject),
  nof_broadcasts_requested(47, crit_e::reject),
  warning_type(125, crit_e::ignore),
  warning_security_info(124, crit_e::ignore),
  data_coding_scheme(20, crit_e::ignore),
  warning_msg_contents(123, crit_e::ignore),
  concurrent_warning_msg_ind(17, crit_e::reject),
  warning_area_coordinates(141, crit_e::ignore)
{
}
SRSASN_CODE write_replace_warning_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += warning_area_list_present ? 1 : 0;
  nof_ies += warning_type_present ? 1 : 0;
  nof_ies += warning_security_info_present ? 1 : 0;
  nof_ies += data_coding_scheme_present ? 1 : 0;
  nof_ies += warning_msg_contents_present ? 1 : 0;
  nof_ies += concurrent_warning_msg_ind_present ? 1 : 0;
  nof_ies += warning_area_coordinates_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(msg_id.pack(bref));
  HANDLE_CODE(serial_num.pack(bref));
  if (warning_area_list_present) {
    HANDLE_CODE(warning_area_list.pack(bref));
  }
  HANDLE_CODE(repeat_period.pack(bref));
  HANDLE_CODE(nof_broadcasts_requested.pack(bref));
  if (warning_type_present) {
    HANDLE_CODE(warning_type.pack(bref));
  }
  if (warning_security_info_present) {
    HANDLE_CODE(warning_security_info.pack(bref));
  }
  if (data_coding_scheme_present) {
    HANDLE_CODE(data_coding_scheme.pack(bref));
  }
  if (warning_msg_contents_present) {
    HANDLE_CODE(warning_msg_contents.pack(bref));
  }
  if (concurrent_warning_msg_ind_present) {
    HANDLE_CODE(concurrent_warning_msg_ind.pack(bref));
  }
  if (warning_area_coordinates_present) {
    HANDLE_CODE(warning_area_coordinates.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE write_replace_warning_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 35: {
        nof_mandatory_ies--;
        msg_id.id = id;
        HANDLE_CODE(msg_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(msg_id.value.unpack(bref));
        break;
      }
      case 95: {
        nof_mandatory_ies--;
        serial_num.id = id;
        HANDLE_CODE(serial_num.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(serial_num.value.unpack(bref));
        break;
      }
      case 122: {
        warning_area_list_present = true;
        warning_area_list.id      = id;
        HANDLE_CODE(warning_area_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(warning_area_list.value.unpack(bref));
        break;
      }
      case 87: {
        nof_mandatory_ies--;
        repeat_period.id = id;
        HANDLE_CODE(repeat_period.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(repeat_period.value.unpack(bref));
        break;
      }
      case 47: {
        nof_mandatory_ies--;
        nof_broadcasts_requested.id = id;
        HANDLE_CODE(nof_broadcasts_requested.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nof_broadcasts_requested.value.unpack(bref));
        break;
      }
      case 125: {
        warning_type_present = true;
        warning_type.id      = id;
        HANDLE_CODE(warning_type.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(warning_type.value.unpack(bref));
        break;
      }
      case 124: {
        warning_security_info_present = true;
        warning_security_info.id      = id;
        HANDLE_CODE(warning_security_info.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(warning_security_info.value.unpack(bref));
        break;
      }
      case 20: {
        data_coding_scheme_present = true;
        data_coding_scheme.id      = id;
        HANDLE_CODE(data_coding_scheme.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(data_coding_scheme.value.unpack(bref));
        break;
      }
      case 123: {
        warning_msg_contents_present = true;
        warning_msg_contents.id      = id;
        HANDLE_CODE(warning_msg_contents.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(warning_msg_contents.value.unpack(bref));
        break;
      }
      case 17: {
        concurrent_warning_msg_ind_present = true;
        concurrent_warning_msg_ind.id      = id;
        HANDLE_CODE(concurrent_warning_msg_ind.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(concurrent_warning_msg_ind.value.unpack(bref));
        break;
      }
      case 141: {
        warning_area_coordinates_present = true;
        warning_area_coordinates.id      = id;
        HANDLE_CODE(warning_area_coordinates.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(warning_area_coordinates.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void write_replace_warning_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  msg_id.to_json(j);
  j.write_fieldname("");
  serial_num.to_json(j);
  if (warning_area_list_present) {
    j.write_fieldname("");
    warning_area_list.to_json(j);
  }
  j.write_fieldname("");
  repeat_period.to_json(j);
  j.write_fieldname("");
  nof_broadcasts_requested.to_json(j);
  if (warning_type_present) {
    j.write_fieldname("");
    warning_type.to_json(j);
  }
  if (warning_security_info_present) {
    j.write_fieldname("");
    warning_security_info.to_json(j);
  }
  if (data_coding_scheme_present) {
    j.write_fieldname("");
    data_coding_scheme.to_json(j);
  }
  if (warning_msg_contents_present) {
    j.write_fieldname("");
    warning_msg_contents.to_json(j);
  }
  if (concurrent_warning_msg_ind_present) {
    j.write_fieldname("");
    concurrent_warning_msg_ind.to_json(j);
  }
  if (warning_area_coordinates_present) {
    j.write_fieldname("");
    warning_area_coordinates.to_json(j);
  }
  j.end_obj();
}

write_replace_warning_resp_ies_container::write_replace_warning_resp_ies_container() :
  msg_id(35, crit_e::reject),
  serial_num(95, crit_e::reject),
  broadcast_completed_area_list(13, crit_e::ignore),
  crit_diagnostics(19, crit_e::ignore)
{
}
SRSASN_CODE write_replace_warning_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += broadcast_completed_area_list_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  HANDLE_CODE(msg_id.pack(bref));
  HANDLE_CODE(serial_num.pack(bref));
  if (broadcast_completed_area_list_present) {
    HANDLE_CODE(broadcast_completed_area_list.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE write_replace_warning_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    switch (id) {
      case 35: {
        nof_mandatory_ies--;
        msg_id.id = id;
        HANDLE_CODE(msg_id.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(msg_id.value.unpack(bref));
        break;
      }
      case 95: {
        nof_mandatory_ies--;
        serial_num.id = id;
        HANDLE_CODE(serial_num.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(serial_num.value.unpack(bref));
        break;
      }
      case 13: {
        broadcast_completed_area_list_present = true;
        broadcast_completed_area_list.id      = id;
        HANDLE_CODE(broadcast_completed_area_list.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(broadcast_completed_area_list.value.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        crit_diagnostics.id      = id;
        HANDLE_CODE(crit_diagnostics.crit.unpack(bref));
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.value.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void write_replace_warning_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("");
  msg_id.to_json(j);
  j.write_fieldname("");
  serial_num.to_json(j);
  if (broadcast_completed_area_list_present) {
    j.write_fieldname("");
    broadcast_completed_area_list.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_fieldname("");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}
